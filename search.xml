<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Core的学习扩展和封装（三）</title>
      <link href="/2020/04/04/Core%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%89%A9%E5%B1%95%E5%92%8C%E5%B0%81%E8%A3%85%EF%BC%88%E4%B8%89%EF%BC%89/"/>
      <url>/2020/04/04/Core%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%89%A9%E5%B1%95%E5%92%8C%E5%B0%81%E8%A3%85%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ol><li>autofac如何获取一个接口的所有实现？</li><li>autofac通过配置文件使用</li><li>一个接口多是心啊，构造函数该注入那个？</li><li>Exception Order 是不是可以跨类库？</li><li>autofac 相比较于IServiceCollection有哪些优势？为啥要替换？</li></ol><p>.net Framework环境授权：<br>    * 在登陆的时候写入Session<br>    * 在需要控制权限的方法上标记一个权限特性，实现在方法执行前对Session进行判断<br>    * 如果有Session，就有权限<br>.net core环境授权：<br>    * 来自于AuthenticationHttpContextExtensions扩展类提供的方法实现<br>    * 6大方法，可以自行扩展这6个方法；需要自定义一个hander<br>    * 分别实现6个方法，需要指定Core中使用权限验证<br>    * 如果使用了Sechme验证，验证不通过的时候，就默认跳转到Account/Login</p><h2 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h2><p>整合AutoFac代替Core原生的容器</p><h3 id="添加程序包"><a href="#添加程序包" class="headerlink" title="添加程序包"></a>添加程序包</h3><ol><li>Autofac</li><li>Autofac.Extensions.DependencyInjection</li></ol><h3 id="修改ConfigureServices方法"><a href="#修改ConfigureServices方法" class="headerlink" title="修改ConfigureServices方法"></a>修改ConfigureServices方法</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public IserviceProvider ConfigureServices(IserviceCollection services)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;原来的代码不变</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;新增代码</span><br><span class="line">    &#x2F;&#x2F;实例一个容器</span><br><span class="line">    ContainerBuilder containerBuilder &#x3D; new ContainerBuilder();</span><br><span class="line">    &#x2F;&#x2F;注册服务</span><br><span class="line">    containerBuilder.RegisterModule&lt;CustomAutofacModule&gt;();</span><br><span class="line">    &#x2F;&#x2F;services默认的注册服务，还需要autofac容器全权接管</span><br><span class="line">    containerBuilder.Populate(services);</span><br><span class="line">    &#x2F;&#x2F;返回</span><br><span class="line">    IContainer container &#x3D; containerbuilder.Build();</span><br><span class="line">    return new AutofacServiceProvider(container);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="CustomAutofacModule类"><a href="#CustomAutofacModule类" class="headerlink" title="CustomAutofacModule类"></a>CustomAutofacModule类</h3><p><a href="/images/20200407154538.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/20200407154538.png" class="lazyload"></a></p><h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><h3 id="引入AOP的依赖包"><a href="#引入AOP的依赖包" class="headerlink" title="引入AOP的依赖包"></a>引入AOP的依赖包</h3><ol><li>Autofac.Extas.DynamicProxy</li></ol><h3 id="添加CustomAutofacAop"><a href="#添加CustomAutofacAop" class="headerlink" title="添加CustomAutofacAop"></a>添加CustomAutofacAop</h3><p><a href="/images/20200407153546.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/20200407153546.png" class="lazyload"></a></p><p><a href="/images/20200407154112.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/20200407154112.png" class="lazyload"></a></p><h2 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h2><h3 id="ExceptionFilter"><a href="#ExceptionFilter" class="headerlink" title="ExceptionFilter"></a>ExceptionFilter</h3><p>全局调用<br><a href="/images/20200407161430.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/20200407161430.png" class="lazyload"></a></p><h3 id="IActionFilter"><a href="#IActionFilter" class="headerlink" title="IActionFilter"></a>IActionFilter</h3><p>可以添加日志使用<br><a href="/images/20200407161559.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/20200407161559.png" class="lazyload"></a></p><h4 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h4><p><a href="/images/20200407162352.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/20200407162352.png" class="lazyload"></a></p><h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><p><a href="/images/20200407161850.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/20200407161850.png" class="lazyload"></a></p><h3 id="TypeFilter和ServiceFilter的区别"><a href="#TypeFilter和ServiceFilter的区别" class="headerlink" title="TypeFilter和ServiceFilter的区别"></a>TypeFilter和ServiceFilter的区别</h3><blockquote><p>ServiceFilter在使用特性时需要先注册特性到容器中</p></blockquote><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">services.AddScoped&lt;CustomActionFilterAttribute&gt;();</span><br></pre></td></tr></table></figure></div><h2 id="autofac一个接口多个实现"><a href="#autofac一个接口多个实现" class="headerlink" title="autofac一个接口多个实现"></a>autofac一个接口多个实现</h2><ol><li><strong>下面这种时是实现所有引用接口的类</strong></li></ol><h3 id="通过As注册"><a href="#通过As注册" class="headerlink" title="通过As注册"></a>通过As注册</h3><p><a href="/images/20200408145603.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/20200408145603.png" class="lazyload"></a></p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p><a href="/images/20200408145955.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/20200408145955.png" class="lazyload"></a></p><h2 id="autofac通过配置文件注册服务"><a href="#autofac通过配置文件注册服务" class="headerlink" title="autofac通过配置文件注册服务"></a>autofac通过配置文件注册服务</h2><p><a href="/images/20200408150137.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/20200408150137.png" class="lazyload"></a></p><h3 id="配置文件autofac-json"><a href="#配置文件autofac-json" class="headerlink" title="配置文件autofac.json"></a>配置文件autofac.json</h3><p><a href="/images/20200408150244.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/20200408150244.png" class="lazyload"></a></p><ol start="2"><li><strong>下面这种时是实现固定引用接口的类</strong></li></ol><h3 id="通过Named注册"><a href="#通过Named注册" class="headerlink" title="通过Named注册"></a>通过Named注册</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;取个名字</span><br><span class="line">builder.RegisterType&lt;NewsHelper&gt;().Named&lt;INewsHelper&gt;(&quot;news&quot;);</span><br><span class="line">builder.RegisterType&lt;SubjectHelper&gt;().Named&lt;INewsHelper&gt;(&quot;subject&quot;);</span><br></pre></td></tr></table></figure></div><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">namespace test.Controllers</span><br><span class="line">&#123;</span><br><span class="line">    public class HomeController : Controller</span><br><span class="line">    &#123; </span><br><span class="line">        private IServiceGetter getter;</span><br><span class="line"> </span><br><span class="line">        public HomeController(IServiceGetter getter)</span><br><span class="line">        &#123;  </span><br><span class="line">            this.getter &#x3D; getter;</span><br><span class="line">        &#125;</span><br><span class="line">        public ActionResult Index()</span><br><span class="line">        &#123; </span><br><span class="line">            ViewBag.Message &#x3D; getter.GetByName&lt;INewsHelper&gt;(&quot;subject&quot;).GetNewInfo(1);</span><br><span class="line">            return View();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="权限Filter"><a href="#权限Filter" class="headerlink" title="权限Filter"></a>权限Filter</h2><p>老的方式<br><a href="/images/20200408214515.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/20200408214515.png" class="lazyload"></a></p><h3 id="1-通过中间件"><a href="#1-通过中间件" class="headerlink" title="1. 通过中间件"></a>1. 通过中间件</h3><p>设置自己的schema的handler</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">services.AddAuthenticationCore(options &#x3D;&gt; options.AddScheme&lt;MyHandler&gt;(&quot;myScheme&quot;,&quot;demomyScheme&quot;));</span><br></pre></td></tr></table></figure></div><p>标识在当前系统中使用这个权限认证</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.UseAuthentication();</span><br></pre></td></tr></table></figure></div><h4 id="登陆"><a href="#登陆" class="headerlink" title="登陆"></a>登陆</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">app.Map(&quot;&#x2F;login&quot;,builder &#x3D;&gt; builder.Use(next &#x3D;&gt;&#123;</span><br><span class="line">    return async (context) &#x3D;&gt;&#123;</span><br><span class="line">        var claimaIdentity &#x3D; new ClaimsIdentity();&#x2F;&#x2F;可以把这个ClaimsIdentity理解成一个身份证</span><br><span class="line">        claimaIdentity.AddClaim(new Claim(ClaimTypes.Name,&quot;Linsan&quot;))；&#x2F;&#x2F;用户信息的载体</span><br><span class="line">        &#x2F;&#x2F;Scheme 可以理解为 跟身份证对应的一个标识</span><br><span class="line">        await context.SignInAsync(&quot;myScheme&quot;,new ClaimsPrincipal(claimIdentity));</span><br><span class="line">        await context.Response.WriteAsync(&quot;lallal&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure></div><h4 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">app.Map(&quot;&#x2F;logout&quot;,builder &#x3D;&gt;builder.Use(next &#x3D;&gt;&#123;</span><br><span class="line">    return async (context) &#x3D;&gt; &#123;</span><br><span class="line">        await context.SignOutAsync(&quot;myScheme&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure></div><h4 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">app.Use(next &#x3D;&gt; &#123;</span><br><span class="line">    return async (context) &#x3D;&gt;&#123;</span><br><span class="line">        var result &#x3D; await context.AuthenticateAsync(&quot;myScheme&quot;);</span><br><span class="line">        if(result?.Principal !&#x3D; null)</span><br><span class="line">        &#123;</span><br><span class="line">            context.User &#x3D; result.Principal;</span><br><span class="line">            await next(context);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            await context.ChallengeAsync(&quot;myScheme&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div><h4 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">app.Use(async(context,next)&#x3D;&gt;&#123;</span><br><span class="line">    var user &#x3D; context.User;</span><br><span class="line">    if(user.Identity.Name.Equals(&quot;Richard&quot;))&#x2F;&#x2F;user?.Identity?.IsAuthenticated这里没有授权检测，只是检查了下名称</span><br><span class="line">    &#123;</span><br><span class="line">        await next();</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        await context.ForbidAsync(&quot;myScheme&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div><h3 id="2-在MVC中使用"><a href="#2-在MVC中使用" class="headerlink" title="2.在MVC中使用"></a>2.在MVC中使用</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">services.AddAuthentication(options &#x3D;&gt; &#123;</span><br><span class="line">    options.DefaultScheme &#x3D; CookieAuthenticationDefaults.AuthenticationScheme;</span><br><span class="line">&#125;).AddCookie(options &#x3D;&gt; &#123;</span><br><span class="line">    options.LoginPath &#x3D; new PathString(&quot;&#x2F;Account&#x2F;Login&quot;);</span><br><span class="line">    options.ClaimsIssuer &#x3D; &quot;Cookie&quot;;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div><p>支持Policy认证授权的服务</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;指定需要通过策略验证的策略类</span><br><span class="line">services.AddSingleton&lt;IAuthorizationHandler,AdvacedRequirement&gt;();</span><br><span class="line">services.AddAuthorization(options &#x3D;&gt; &#123;</span><br><span class="line">    options.AddPolicy(&quot;Advanced&quot;,policy&#x3D;&gt;&#123;</span><br><span class="line">        policy.AddRequirements(new NameAuthorizationRequirement(&quot;1&quot;));</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).AddAuthentication(options &#x3D;&gt; &#123;</span><br><span class="line">    options.DefaultScheme &#x3D; CookieAuthenticationDefaults.AuthenticationScheme;</span><br><span class="line">&#125;).AddCookie(options &#x3D;&gt; &#123;</span><br><span class="line">    options.LoginPath &#x3D; new PathString(&quot;&#x2F;Account&#x2F;Login&quot;);</span><br><span class="line">    options.ClaimsIssuer &#x3D; &quot;Cookie&quot;;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div><p><strong>AdvacedRequirement策略类</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class AdvancedRequirement : AuthorizationHandler&lt;NameAuthorizationRequirement&gt;,IAuthorizationRequirement</span><br><span class="line">&#123;</span><br><span class="line">    protected override Task HandleRequirementAsync(AuthorizationHandlerContext context,NameAuthorizationRequirement requirement)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;这里可以把用户信息获取到以后通过数据库进行验证</span><br><span class="line">        &#x2F;&#x2F;这里就可以做一个规则验证</span><br><span class="line">        if(context.User !&#x3D; null &amp;&amp; context.User.HasClaim(c &#x3D;&gt; c.Type &#x3D;&#x3D; ClaimTypes.Sid))</span><br><span class="line">        &#123;</span><br><span class="line">            string sid &#x3D; context.User.FindFirst(c &#x3D;&gt; c.Type &#x3D;&#x3D; ClaimTypes.Sid).Value;</span><br><span class="line">            if(!sid.Equals(requirement.RequiredName))</span><br><span class="line">            &#123;</span><br><span class="line">                context.Succeed(requirement);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return Task.CompletedTask;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>标识在当前系统中使用这个权限认证</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.UseAuthentication();</span><br></pre></td></tr></table></figure></div><h4 id="登陆-1"><a href="#登陆-1" class="headerlink" title="登陆"></a>登陆</h4><p>写入用户信息</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;把一个CurrentUser，转换成一个claimIdentiy（把一个登陆用户转换成一个身份证）</span><br><span class="line">var claimIdentity &#x3D; new ClaimsIdentity(&quot;Cookie&quot;);</span><br><span class="line">claimIdentity.AddClaim(new Claim(ClaimTypes.NameIdentifier,currentUser.Id.ToString()));</span><br><span class="line">claimIdentity.AddClaim(new Claim(ClaimTypes.Name,currentUser.Name));</span><br><span class="line">claimIdentity.AddClaim(new Claim(ClaimTypes.Email,currentUser.Email));</span><br><span class="line">claimIdentity.AddClaim(new Claim(ClaimTypes.Role,currentUser.Role));</span><br><span class="line">var claimsPrincipal &#x3D; new ClaimsPrincipal(claimIdentity);</span><br><span class="line">&#x2F;&#x2F;在上面注册AddAuthentication时，指定了默认的Scheme，在这里便可以不子啊指定Scheme。</span><br><span class="line">&#x2F;&#x2F; 这里的SignIn不是MyHandler里的SignIn</span><br><span class="line">HttpContext.SignInAsync(claimsPrincipal).Wait();&#x2F;&#x2F;写到cookie</span><br></pre></td></tr></table></figure></div><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Authorize(AuthenticationSchemes &#x3D; CookieAuthenticationDefaults.AuthenticationScheme)]</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> .Net Core </tag>
            
            <tag> Autofac </tag>
            
            <tag> AOP </tag>
            
            <tag> Filter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Core的学习扩展和封装（二）</title>
      <link href="/2020/04/04/Core%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%89%A9%E5%B1%95%E5%92%8C%E5%B0%81%E8%A3%85%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2020/04/04/Core%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%89%A9%E5%B1%95%E5%92%8C%E5%B0%81%E8%A3%85%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="appsettings-json"><a href="#appsettings-json" class="headerlink" title="appsettings.json"></a>appsettings.json</h2><p>对应framework中的webconfig，存储格式为json</p><h2 id="Log4Net整合"><a href="#Log4Net整合" class="headerlink" title="Log4Net整合"></a>Log4Net整合</h2><ol><li><p>引入log4net<br> Microsoft.Extensions.Logging.Log4Net.AspNetCore<br> 添加Log4Net配置文件（设置配置文件为始终复制，默认配置文件放在根目录下）</p></li><li><p>注入ILoggerFactory<br><a href="/images/20200404150534.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/20200404150534.png" class="lazyload"></a></p></li><li><p>创建ILogger对象<br><a href="/images/20200404151039.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/20200404151039.png" class="lazyload"></a></p></li><li><p>写日志</p></li></ol><p><a href="/images/20200404154425.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/20200404154425.png" class="lazyload"></a></p><h2 id="ServiceCollection容器"><a href="#ServiceCollection容器" class="headerlink" title="ServiceCollection容器"></a>ServiceCollection容器</h2><h3 id="实例化一个容器"><a href="#实例化一个容器" class="headerlink" title="实例化一个容器"></a>实例化一个容器</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;实例化容器</span><br><span class="line">IServiceCollection container &#x3D; new ServiceCollection();</span><br></pre></td></tr></table></figure></div><h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;瞬时生命周期</span><br><span class="line">container.AddTransient&lt;ITestServiceA,TestServiceA&gt;();</span><br><span class="line">&#x2F;&#x2F;单例生命周期，在容器中永远只有当前这一个</span><br><span class="line">container.AddSingleton&lt;ITestServiceA,TestServiceA&gt;();</span><br><span class="line">container.AddSingleton&lt;ITestServiceA&gt;(new TestServiceA());</span><br><span class="line">&#x2F;&#x2F;当前请求作用域内，只有当前这个实力</span><br><span class="line">container.AddScoped&lt;ITestServiceC,TestServiceC&gt;();</span><br></pre></td></tr></table></figure></div><h3 id="获取服务"><a href="#获取服务" class="headerlink" title="获取服务"></a>获取服务</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ServiceProvider provider &#x3D; container.BuildServiceProvider();</span><br><span class="line">ITestServiceA testA &#x3D; provider.GetService&lt;ITestServiceA&gt;();</span><br><span class="line">testA.Show();</span><br><span class="line"></span><br><span class="line">IServiceScope scope &#x3D; provider.CreateScope();</span><br><span class="line">var testC &#x3D; scope.ServiceProvider.GetService&lt;ITestServiceC&gt;();</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> .Net Core </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Core的学习扩展和封装（四）</title>
      <link href="/2020/04/04/Core%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%89%A9%E5%B1%95%E5%92%8C%E5%B0%81%E8%A3%85%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
      <url>/2020/04/04/Core%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%89%A9%E5%B1%95%E5%92%8C%E5%B0%81%E8%A3%85%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>framework环境下；19个事件，是一个全家桶，把所有需要的东西全部封装在内了，如果需要扩展，就注册不同的事件，进行扩展，但是执行顺序是固定不变的。<br>core把每一个执行快自由组装，自行调整顺序，最终形成一个链子一样</p><h2 id="系统中间件"><a href="#系统中间件" class="headerlink" title="系统中间件"></a>系统中间件</h2><h3 id="终结者Run"><a href="#终结者Run" class="headerlink" title="终结者Run"></a>终结者Run</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;执行后不继续往下执行，直接返回</span><br><span class="line">app.Run(c&#x3D;&gt;c.Response.WriteAsync(&quot;终结者&quot;));</span><br></pre></td></tr></table></figure></div><h3 id="Use"><a href="#Use" class="headerlink" title="Use"></a>Use</h3><ol><li>第一种<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;next是一个返回值，作为下一个中间件的参数</span><br><span class="line">app.Use(next &#x3D;&gt;</span><br><span class="line">&#123; </span><br><span class="line">    await context.Response.WriteAsync(&quot;this is middleware&quot;);</span><br><span class="line">    return new RequestDelegate(async context &#x3D;&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        await context.Response.WriteAsync(&quot;this is middleware start&quot;);</span><br><span class="line">        await next.Invoke(context);</span><br><span class="line">        await context.Response.WriteAsync(&quot;this is middleware end&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div></li><li>第二种属于扩展方法<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">app.Use(async(context,next)&#x3D;&gt;</span><br><span class="line">&#123;</span><br><span class="line">    await context.Response.WriteAsync(&quot;start&quot;);</span><br><span class="line">    await next();</span><br><span class="line">    await context.Response.WriteAsync(&quot;end&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div></li></ol><h3 id="UseWhen"><a href="#UseWhen" class="headerlink" title="UseWhen"></a>UseWhen</h3><p>UseWhen可以对HttpContext检测后，增加处理环节，原来的流程还是正常执行</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">app.UseWhen(context&#x3D;&gt;&#123;</span><br><span class="line">    &#x2F;&#x2F;返回判断结果</span><br><span class="line">    return context.Request.Query.ContainsKey(&quot;name&quot;);</span><br><span class="line">&#125;,appBuilder&#x3D;&gt;&#123;</span><br><span class="line">    &#x2F;&#x2F;判断条件如果是true这执行这里的代码</span><br><span class="line">    appBuilder.Use(async (context,next)&#x3D;&gt;&#123;</span><br><span class="line">        await context.Response.WriteAsync(&quot;111&quot;);</span><br><span class="line">        await next();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>根据条件指定中间件，指向终结点，没有next<br>最好不要在中间件里面判断条件选择分支；而是一个中间件只做一件事儿，多个中间件就做多个事儿</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.Map(&quot;&#x2F;Home&quot;,app.Run(async context &#x3D;&gt; </span><br><span class="line">&#123;</span><br><span class="line">    await context.Response.WriteAsync(&quot;111111&quot;);</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure></div><h3 id="MapWhen"><a href="#MapWhen" class="headerlink" title="MapWhen"></a>MapWhen</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">app.MapWhen(context&#x3D;&gt;</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;判断条件</span><br><span class="line">    return context.Request.Query.ContainsKey(&quot;name&quot;);</span><br><span class="line">    &#x2F;&#x2F;拒绝浏览器</span><br><span class="line">&#125;,app.Run(async context &#x3D;&gt;</span><br><span class="line">&#123;</span><br><span class="line">    await context.Response.WriteAsync(&quot;111&quot;);</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure></div><h3 id="自定义中间件"><a href="#自定义中间件" class="headerlink" title="自定义中间件"></a>自定义中间件</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.UseMiddleware&lt;FirstMiddleWare&gt;();</span><br></pre></td></tr></table></figure></div><h4 id="自定义中间件代码"><a href="#自定义中间件代码" class="headerlink" title="自定义中间件代码"></a>自定义中间件代码</h4><p><a href="/images/20200408212316.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/20200408212316.png" class="lazyload"></a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> .Net Core </tag>
            
            <tag> 管道处理模型 </tag>
            
            <tag> 中间件 </tag>
            
            <tag> Middleware </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Core的学习扩展和封装（一）</title>
      <link href="/2020/04/04/Core%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%89%A9%E5%B1%95%E5%92%8C%E5%B0%81%E8%A3%85%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2020/04/04/Core%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%89%A9%E5%B1%95%E5%92%8C%E5%B0%81%E8%A3%85%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Framework和Core的区别"><a href="#Framework和Core的区别" class="headerlink" title="Framework和Core的区别"></a>Framework和Core的区别</h2><p><a href="/images/20200404134059.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/20200404134059.png" class="lazyload"></a></p><p>Framework下程序从global开始执行；网站寄宿在IIS上，IIS监控端口，做转发，由Framework站点做业务逻辑处理，响应请求<br>framework里面，都是一家全部封装好了，可以通过注册事件，添加业务逻辑，全部按照封装好的顺序执行</p><p>Core：其实是一个控制台，程序从Program中的Main方法进入；Main方法通过CreateWebHostBuilder创建主机，然后引用Startup固定类<br>core里面，都需要自己拼装</p><p>Core内置IOC，进入Startup方法后先注入IConfiguration，Startup方法自带两个方法，被运行时环境调用</p><h3 id="ConfigureServices"><a href="#ConfigureServices" class="headerlink" title="ConfigureServices"></a>ConfigureServices</h3><p><a href="/images/20200404134728.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/20200404134728.png" class="lazyload"></a></p><p>配置内容，注册服务</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;注册中间件MVC</span><br><span class="line">services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_2);</span><br></pre></td></tr></table></figure></div><h3 id="Configure"><a href="#Configure" class="headerlink" title="Configure"></a>Configure</h3><p><a href="/images/20200404135007.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/20200404135007.png" class="lazyload"></a></p><p>判断开发环境,使用注册的服务</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;使用MVC</span><br><span class="line">app.UseMvc(routes &#x3D;&gt;</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;配置路由</span><br><span class="line">    routes.MapRoute(</span><br><span class="line">        name:&quot;default&quot;,</span><br><span class="line">        template:&quot;&#123;controller&#x3D;Home&#125;&#x2F;&#123;action&#x3D;Index&#125;&#x2F;&#123;id?&#125;&quot;</span><br><span class="line">    );</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div><p><a href="/images/20200404135752.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/20200404135752.png" class="lazyload"></a></p><p>run：短路器，执行后不在继续向下执行</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> .Net Core </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lucene.Net全文检索解读 七大对象学习</title>
      <link href="/2020/02/27/Lucene%20Net%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2%E8%A7%A3%E8%AF%BB%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2020/02/27/Lucene%20Net%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2%E8%A7%A3%E8%AF%BB%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>lucene.net：全文检索的工具包，不是应用，只是一个类库，完成了全文检索的功能</p><p><em>就是把数据拆分，然后存起来，查询时先拆分，然后匹配结果</em></p><p>Lucene.Net 3.0.3<br>Lucene.Net.Analysis.Pangu 2.4.1<br><a href="http://pangusegment.codeplex.com/" target="_blank" rel="noopener">http://pangusegment.codeplex.com/</a></p><h2 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h2><p>分词器，负责把字符串拆分成原子字或词，包含了标准分词，直接空格拆分</p><p>基础扩展分词器，用逗号分隔<br><a href="/images/20200227172705.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/20200227172705.png" class="lazyload"></a></p><blockquote><p>一般实现中文分词，可以结合<strong>盘古中文分词</strong>了来使用（盘古分词从后往前匹配原子词句）</p></blockquote><h2 id="Document"><a href="#Document" class="headerlink" title="Document"></a>Document</h2><p>表示数据结构，定义存储数据的格式</p><h2 id="Index"><a href="#Index" class="headerlink" title="Index"></a>Index</h2><p>索引的读写类</p><h2 id="QueryParser"><a href="#QueryParser" class="headerlink" title="QueryParser"></a>QueryParser</h2><p>查询解析器，负责解析查询语句（做比较大于，等于等）</p><h2 id="Search"><a href="#Search" class="headerlink" title="Search"></a>Search</h2><p>负责各种查询类，命令解析后得到的就是查询类</p><p><strong>TermQuery：单元查询</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">--找出title包含张三的</span><br><span class="line">new Term(&quot;title&quot;,&quot;张三&quot;) </span><br><span class="line">--QueryParser</span><br><span class="line">title:张三</span><br></pre></td></tr></table></figure></div><p><strong>BoolenQuery：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">new Term(&quot;title&quot;,&quot;张三&quot;) or new Term(&quot;title&quot;,&quot;李四&quot;)</span><br><span class="line">--QueryParser</span><br><span class="line">title:张三 + title:李四</span><br><span class="line">new Term(&quot;title&quot;,&quot;张三&quot;) and new Term(&quot;title&quot;,&quot;李四&quot;)</span><br><span class="line">title:张三  title:李四</span><br></pre></td></tr></table></figure></div><p><strong>WildcardQuery：通配符</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">new Term(&quot;title&quot;,&quot;张?&quot;)</span><br><span class="line">new Term(&quot;title&quot;,&quot;张*&quot;)</span><br><span class="line">title:张?</span><br><span class="line">title:张*</span><br></pre></td></tr></table></figure></div><p><strong>PhraseQuery：执行距离</strong></p><p><strong>没有蘑菇的提莫</strong>： 包含没有，包含提莫，而且二者的距离不能超过5</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">title:&quot;没有 提莫&quot;~5</span><br></pre></td></tr></table></figure></div><p><strong>PrefixQuery：前缀查询</strong></p><p>以XX开始</p><p><strong>FuzzyQuery：近似查询</strong></p><p>ibhone = iphone</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">title:ibhone~</span><br></pre></td></tr></table></figure></div><p><strong>RangeQuery：范围查询</strong></p><p>查询价格区间</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">price:[1,100] &#123;1,100&#125;</span><br></pre></td></tr></table></figure></div><h2 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h2><p>索引存储类，负责文件夹等等</p><h2 id="Util"><a href="#Util" class="headerlink" title="Util"></a>Util</h2><p>常见工具类库</p>]]></content>
      
      
      <categories>
          
          <category> Lucene.Net </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分词 </tag>
            
            <tag> 数据库 </tag>
            
            <tag> 索引 </tag>
            
            <tag> 全文索引 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库索引和数据库优化</title>
      <link href="/2020/02/26/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96/"/>
      <url>/2020/02/26/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>数据库索引和数据库优化</p><p>数据库执行一个T-SQL的执行过程<br><a href="/images/20200226110912.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/20200226110912.png" class="lazyload"></a></p><p>执行计划：<br>可以缓存，存储过程/参数化查询</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">--不能缓存</span><br><span class="line">select * from User where id&#x3D;1</span><br><span class="line">select * from User where id&#x3D;2</span><br><span class="line">--可以缓存</span><br><span class="line">select * from User where id&#x3D;@id</span><br></pre></td></tr></table></figure></div><h2 id="数据库是什么？"><a href="#数据库是什么？" class="headerlink" title="数据库是什么？"></a>数据库是什么？</h2><p>数据库就是把东西有序放好，还能随时找到的工具<br>应用程序，有序的数据管理—-数据在硬盘（持久化：唯一的，多线程操作需要加锁；速度慢，可以SSD加快速度）<br>1000w数据等于2G，那找个东西很慢，怎样性能能好一点？就是索引</p><p><a href="/images/20200226111727.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/20200226111727.png" class="lazyload"></a></p><h2 id="Page"><a href="#Page" class="headerlink" title="Page"></a>Page</h2><h3 id="普通Page"><a href="#普通Page" class="headerlink" title="普通Page"></a>普通Page</h3><blockquote><p>8kb/page 任何一条数据不能跨页存储：数据长度不能超过8096，char Heap<br>text存储超过8kb，会存在另外一个特殊的page（一个连续的page页专门存储text），数据也之存储位置（效率肯定很低）<br>int/DateTime：可以放入一个page（设计数据库的时候，字段类型空间范围尽量小一些）<br>8个page形成一个Extent（扩展区）,多个Extent合体叫堆，所以数据都是存在堆上的</p></blockquote><h3 id="IAM-Page"><a href="#IAM-Page" class="headerlink" title="IAM Page"></a>IAM Page</h3><p>管理数据页，记录好数据页在硬盘的具体位置</p><h3 id="文本-图像-Page"><a href="#文本-图像-Page" class="headerlink" title="文本/图像 Page"></a>文本/图像 Page</h3><p>存储文本或者二进制图片的Page</p><h3 id="Index（索引）-Page"><a href="#Index（索引）-Page" class="headerlink" title="Index（索引） Page"></a>Index（索引） Page</h3><p>索引页：数据&amp;位置<br>索引是一个独立的，重复的存储；体积小，扫描快</p><h4 id="聚集索引（聚簇索引）"><a href="#聚集索引（聚簇索引）" class="headerlink" title="聚集索引（聚簇索引）"></a>聚集索引（聚簇索引）</h4><p>换聚集索引，很耗时，很多硬盘操作，生成环境不建议<br>只能有一个聚集索引，但是聚集索引可以包含多个列（字段）<br>一般是自增主键/创建时间/价格<br>因为数据物理排序，当然查询快<br>非常适合大于，小于，between，还有order by</p><h4 id="非聚集索引"><a href="#非聚集索引" class="headerlink" title="非聚集索引"></a>非聚集索引</h4><p>不影响数据的物理排序，但是重复存储一个数据和位置<br>找数据，先找索引–快速定位–拿到数据<br>查找快，但是有维护索引的成本<br>非聚集索引，可以多个，每个索引也可以多个字段</p><p>使用场景：适合经常查询的字段，名称/账号</p><p>非聚集索引和聚集所以都不能运算，不能like’% %’，索引条件在前</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">--不能走索引</span><br><span class="line">select * from User where Id-1&gt;10</span><br><span class="line">--可以走索引</span><br><span class="line">select * from User where Id &gt;11</span><br></pre></td></tr></table></figure></div><p>建立索引的原则/建议：</p><blockquote><p>1：主键是必须建立索引的（推荐数值主键，性能最高）<br>2：外键列也要索引<br>3：经常查询列的建立索引<br>4：经常在where里面<br>5：order by/group by/distinct<br>6：聚合运算/where条件时，先索引字段</p></blockquote><p>不推荐索引：</p><blockquote><p>1：基本不怎么查询<br>2：重复值比较多的不要索引（sex性别/state）<br>3：text/image<br>4：尽量不要太多索引</p></blockquote><p><strong>where多个条件时，先写索引字段</strong></p><h2 id="执行计划"><a href="#执行计划" class="headerlink" title="执行计划"></a>执行计划</h2><p>提交sql语句，数据库查询优化器，经过分析生成，指定多个查询方式<br>数据库制定执行计划是按照使用资源最少，而不是时间最短</p><p><a href="/iamges/20200226120145.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/iamges/20200226120145.png" class="lazyload"></a></p><p>线条约粗，代表影响的行数越多</p><blockquote><p>Estimated Number of Rows：受影响的行数<br>Estimated Row Size：影响的字节数<br>Estimated Data Size：影响的数据大小</p></blockquote><p><a href="/iamges/20200226120513.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/iamges/20200226120513.png" class="lazyload"></a></p><h3 id="Table-Scan-全表扫描，性能最差"><a href="#Table-Scan-全表扫描，性能最差" class="headerlink" title="Table Scan 全表扫描，性能最差"></a>Table Scan 全表扫描，性能最差</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--表内没有索引</span><br><span class="line">select top 100 * from User</span><br></pre></td></tr></table></figure></div><h3 id="Cluster-Index-Scan-性能最差，同上-虽然有聚集索引，其实也是全表扫描"><a href="#Cluster-Index-Scan-性能最差，同上-虽然有聚集索引，其实也是全表扫描" class="headerlink" title="Cluster Index Scan 性能最差，同上 虽然有聚集索引，其实也是全表扫描"></a>Cluster Index Scan 性能最差，同上 虽然有聚集索引，其实也是全表扫描</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--表内有索引</span><br><span class="line">select top 100 * from User</span><br></pre></td></tr></table></figure></div><h3 id="Index-Seek-NonClustered-性能非常高（索引查找）"><a href="#Index-Seek-NonClustered-性能非常高（索引查找）" class="headerlink" title="Index Seek(NonClustered) 性能非常高（索引查找）"></a>Index Seek(NonClustered) 性能非常高（索引查找）</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--productId是非聚集索引</span><br><span class="line">select top 100 * from User where productId &#x3D; 1000</span><br></pre></td></tr></table></figure></div><h3 id="Index-Scan-先index-在扫描"><a href="#Index-Scan-先index-在扫描" class="headerlink" title="Index Scan 先index 在扫描"></a>Index Scan 先index 在扫描</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">--强制查询的时候使用某索引</span><br><span class="line">select * </span><br><span class="line">from User</span><br><span class="line">with(index&#x3D;索引名)</span><br></pre></td></tr></table></figure></div><h3 id="Cluster-Index-Seek-性能最高"><a href="#Cluster-Index-Seek-性能最高" class="headerlink" title="Cluster Index Seek 性能最高"></a>Cluster Index Seek 性能最高</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--id是聚集索引</span><br><span class="line">select * from User where Id &gt;10 and Id &lt;100&gt;</span><br></pre></td></tr></table></figure></div><blockquote><p>一般出现问题，看看执行计划，找出scan，换索引</p></blockquote><h3 id="SQL-server-Profiler"><a href="#SQL-server-Profiler" class="headerlink" title="SQL server Profiler"></a>SQL server Profiler</h3><p>执行计划监控</p><h3 id="常规的SQL优化建议"><a href="#常规的SQL优化建议" class="headerlink" title="常规的SQL优化建议"></a>常规的SQL优化建议</h3><blockquote><p>1：对列的计算要避免，任何形式<br>2：in查询，or查询，索引会失效，可能是拆分<br>3：in换exists –not in不要使用，不走索引<br>4：is null和is not null都不走索引<br>5：&lt;&gt;也不走索引，可以拆分成&gt;和&lt;<br>6：join时，链接越少性能越高<br>    –左连接，以左边的结果为准，查询时最好先筛选左边结果<br>    –右连接，已右边查询结果为准<br>    连接字段要求带索引</p></blockquote><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">不走索引</span><br><span class="line">select * from User where id&gt;10 or id &lt;10000</span><br><span class="line">走索引</span><br><span class="line">select * from User where id&gt;10</span><br><span class="line">union all</span><br><span class="line">select * from User where id&lt;1000</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> SQL Server </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> 索引 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EF(EntityFramework)性能优化</title>
      <link href="/2020/02/20/EntityFramework%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
      <url>/2020/02/20/EntityFramework%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>现在工作中很少使用原生的sql了，大多数的时候都在使用EF。刚开始的时候，只是在注重功能的实现，最近一段时间在做服务端接口开发。开发的时候也是像之前一样，键盘噼里啪啦的一顿敲，接口秒秒钟上线，但是到联调测试的时候就悲剧了。。。。那叫一个慢啊，客户端有种“千年等一回的赶脚” 。由于访问量和数量都提升了一个数量级，之前没有 考虑过的问题，都在此时暴露了，根据自己百度、google的经历实践，整理了这一些优化点。欢迎各位大神批评指正！</p><ul><li><p>使用AsNoTracking(),无跟踪查询，查询出的数据不可以修改，但是可以提高查询速度</p></li><li><p>合理使用延迟加载。</p></li></ul><p>如果用不到导航属性中的数据，那么使用懒加载就行了，不会加载不需要的数据到内存中。但是，如果会在 foreach 中使用导航属性中的数据，那么最好是禁用懒加载，通过Include()方法，一次加载全部数据，防止在 foreach 多次和数据库进行交互。当然，一般情况下是这样的，具体的还是要根据当时的业务情况而定。</p><ul><li><p>判断List中是否含有数据的时候，最好使用Any(),避免使用Count()&gt;0，这么Low的方式，真是慢的一逼啊。</p></li><li><p>在where子句中进行中文字符模糊匹配值的时候，记得加上使用DbFunctions.AsNonUnicode(“要匹配的字符”)。</p></li><li><p>错误的使用OrderBy() 导致的错误排序。</p></li></ul><p>要对多个字段进行先后组合排序的时候，正确的是Orderby().ThenBy()；切记不要这样啊：OrderBy().OrderBy()，这样达不到你想要的效果，只会按照最后的那个排序字段进行排序。</p><ul><li>真假分页的问题</li></ul><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">line1:query.ToList().Skip((PageIndex - 1) * PageSize).Take(PageSize);</span><br><span class="line"></span><br><span class="line">line2: query.Skip((PageIndex - 1) * PageSize).Take(PageSize).ToList();</span><br></pre></td></tr></table></figure></div><p>line1就是加分页，直接从DB中取出全部的数据，然后在内存中进行分页；line2才是真正分页。没有ToList()的时候，返回值类型还是IQueryable<t> ,执行了ToList(),之后直接查询数据库了，返回值类型直接是IEnumerable<t>。</t></t></p><ul><li>按需加载部分列。</li></ul><p>通过在Select子句中使用select(t=&gt;{t.id,t.name}),只加载需要的列来提升速度。</p><ul><li><p>使用扩展库Entity Framework Extendeds 进行批量Insert和delete操作，避免生成大量的sql语句和数据库进行多次交互。</p></li><li><p>这些做了，性能还是不行？那SqlQuery()，或者通过储存过程，将多条sql语句作为一个提交单元，也可以减少与数据库的交互次数，从而提高性能。</p></li></ul><p>对于EF首次启动慢的问题，可通过下面的措施进行优化：</p><p>1.EF的预热问题，在应用程序进行初始化的时候就事先进行预热。比如，mvc应用程序可在global文件中添加如下操作。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">protected void Application_Start()</span><br><span class="line">&#123;</span><br><span class="line">    using (var ctx &#x3D; new mcccEntities())</span><br><span class="line">    &#123;</span><br><span class="line">        var objectContext &#x3D; ((IObjectContextAdapter)ctx).ObjectContext;</span><br><span class="line">        var mappingCollection &#x3D; (StorageMappingItemCollection)objectContext.MetadataWorkspace.GetItemCollection(DataSpace.CSSpace);</span><br><span class="line">        mappingCollection.GenerateViews(new List&lt;EdmSchemaError&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;记得，连接了几个DB就要写几个using啦。</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> EF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> EF </tag>
            
            <tag> EntityFramework </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>abp vnext2.0核心组件之DDD组件之实体结构源码解析</title>
      <link href="/2020/02/19/abp%20vnext2%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E4%B9%8BDDD%E7%BB%84%E4%BB%B6%E4%B9%8B%E5%AE%9E%E4%BD%93%E7%BB%93%E6%9E%84%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
      <url>/2020/02/19/abp%20vnext2%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E4%B9%8BDDD%E7%BB%84%E4%BB%B6%E4%B9%8B%E5%AE%9E%E4%BD%93%E7%BB%93%E6%9E%84%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>接着<a href="/2020/02/19/abp%20vnext2核心组件之模块加载组件源码解析/">abp vnext2.0核心组件之模块加载组件源码解析</a>和<a href="/2020/02/19/abp%20vnext2核心组件之默认DI组件切换到AutoFac源码解析/">abp vnext2.0核心组件之.Net Core默认DI组件切换到AutoFac源码解析</a>集合.Net Core3.1,基本环境已经完备,接下去就是构建领域层,vnext整个领域层大致分为聚合根、实体、值对象、事件实体、仓储、服务等等,内容较多,所以我打算分随笔进行介绍.首先介绍领域实体。注:这边所说的实体,是abp团队提供的抽象.如果不了解领域相关的知识,建议阅读&lt;&lt;领域驱动设计：软件核心复杂性应对之道&gt;&gt;需要一定设计模式的功底.如果设计模式不了解,请移步本人的设计模式分类.我也是略懂,所以本文有不当之处,请指正!谢谢!另外提一点,贫血的领域模型和充血的领域模型有本质的区别.有兴趣的可以研究研究,后续有时间我也会补充随笔,大家一起来探讨.</p><p>领域实体分为审计实体和一般实体,如下图所示</p><p><a href="/images/772156-20200209155023713-1949399009.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/772156-20200209155023713-1949399009.png" class="lazyload"></a></p><p>图中红框为常用实体抽象,Events中的实体需要配和EventBus事件总线,这一块作为vnext的单独组件,后续我会写一篇文章解析源码.ok,下面开始讲解.</p><p>整个实体抽象结构和老版abp没有什么大的区别.单单从内容看.首先介绍普通实体.分为聚合根和一般实体</p><h2 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h2><p>为什么要先介绍实体,因为聚合根也是一个实体,实体代码如下：</p><p><a href="/images/772156-20200209161628482-687073679.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/772156-20200209161628482-687073679.png" class="lazyload"></a></p><p><a href="/images/772156-20200209161638105-657520749.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/772156-20200209161638105-657520749.png" class="lazyload"></a></p><p>这边就很有趣了,很明显支持复合主键的实体.貌似和老版Abp不一样,记不太清了,一般情况下,复合主键的设计也比较少见.单主键较多.</p><p>再看看泛型实体，主键可自行指定</p><p><a href="/images/772156-20200209171650707-1343957638.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/772156-20200209171650707-1343957638.png" class="lazyload"></a></p><p>很简单,这边说下Equals的逻辑,比较复杂,如下:</p><p><a href="/images/772156-20200209171845862-1140616665.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/772156-20200209171845862-1140616665.png" class="lazyload"></a></p><p>这两个逻辑很简单,看看就明白了.</p><p>接下去判断实体的主键</p><p><a href="/images/772156-20200210125842133-126701976.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/772156-20200210125842133-126701976.png" class="lazyload"></a></p><p>如果主键的值为其类型的默认值,且比较的两个类型都是如此,那么直接认为两个实体不相等.</p><p>到这里需要理解下这个逻辑,如果两个实体不为空,且类型一致,且引用不一样,但是两个实体的主键都为其类型的默认值.则认为两个实体不相等.</p><p>官方解释是:Transient objects are not considered as equal</p><p>接着</p><p><a href="/images/772156-20200210132103949-1963871671.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/772156-20200210132103949-1963871671.png" class="lazyload"></a></p><p>两个类型必须具有类型的IS-a关系或必须是同一类型</p><p>接着</p><p><a href="/images/772156-20200210132346113-215905839.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/772156-20200210132346113-215905839.png" class="lazyload"></a></p><p>如果两个实体都是租户实体,且上面的条件都不满足的情况下,两个实体的租户Id不相等,则认为两个实体不相等.</p><p>ok,实体结构到这里解析完毕,比较简单.</p><h2 id="聚合根"><a href="#聚合根" class="headerlink" title="聚合根"></a>聚合根</h2><p>聚合根本身也属于一个实体,其结构如下</p><p><a href="/images/772156-20200210132651383-1560131129.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/772156-20200210132651383-1560131129.png" class="lazyload"></a></p><p>挑几个核心接口解析下</p><p><a href="/images/772156-20200210132841023-1115484532.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/772156-20200210132841023-1115484532.png" class="lazyload"></a></p><p>每一个聚合根都具有一组方法来操作领域事件,因为领域事件作为vnext单独组件的存在,所以本文不做解析,后续会有随笔进行介绍.</p><p>接着</p><p><a href="/images/772156-20200210133042692-42328790.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/772156-20200210133042692-42328790.png" class="lazyload"></a></p><p>每一个聚合根都维护了一个额外属性的字段,方便进行灵活的扩展.比如和mogodb等库进行合作.</p><p>接着</p><p><a href="/images/772156-20200210133245981-636751478.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/772156-20200210133245981-636751478.png" class="lazyload"></a></p><p>每一个聚合根都维护着一个并发令牌,初始化聚合根时,直接给一个GUID值,貌似只在EF Core中有效.其他ORM可能需要自行实现(个人理解,如果Dapper支持这种机制,请在评论区告知,万分感谢)。</p><p>当然对应的有一个泛型版本，主键可自行指定</p><p><a href="/images/772156-20200210133431028-195311572.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/772156-20200210133431028-195311572.png" class="lazyload"></a></p><p>ok,整个聚合根的结构也介绍完毕,比较简单. </p><h2 id="审计实体-创建型实体"><a href="#审计实体-创建型实体" class="headerlink" title="审计实体 - 创建型实体"></a>审计实体 - 创建型实体</h2><ul><li>创建型实体</li></ul><p><a href="/images/772156-20200210150238498-280246797.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/772156-20200210150238498-280246797.png" class="lazyload"></a></p><p>只包含创建功能的常规实体抽象.泛型版本主键可自行指定 如下:</p><p><a href="/images/772156-20200210150438940-894429643.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/772156-20200210150438940-894429643.png" class="lazyload"></a></p><p>整个设计我个人有一个疑问,如下:</p><p><a href="/images/772156-20200210150518132-977539223.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/772156-20200210150518132-977539223.png" class="lazyload"></a></p><p>主键不应当统一吗？欢迎在评论区讨论.</p><ul><li>创建型实体带创建人抽象</li></ul><p><a href="/images/772156-20200210150739434-966314624.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/772156-20200210150739434-966314624.png" class="lazyload"></a></p><p>如果当前记录需要记录创建人,那么就可以使用这个实体.当然也提供了泛型版本,主键可自行指定</p><p><a href="/images/772156-20200210151003006-1784482354.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/772156-20200210151003006-1784482354.png" class="lazyload"></a></p><h2 id="审计实体-创建修改型实体"><a href="#审计实体-创建修改型实体" class="headerlink" title="审计实体 - 创建修改型实体"></a>审计实体 - 创建修改型实体</h2><ul><li>创建修改型实体</li></ul><p>如果当前实体同时具备创建和修改的功能,那么可以使用如下实体抽象</p><p><a href="/images/772156-20200210151513406-306768992.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/772156-20200210151513406-306768992.png" class="lazyload"></a></p><p>这里的Guid,依然如此,个人觉得主键需统一，泛型版本主键可自行指定 如下:</p><p><a href="/images/772156-20200210151835898-1131585401.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/772156-20200210151835898-1131585401.png" class="lazyload"></a></p><ul><li>创建修改型实体呆创建者和修改者</li></ul><p>如果当前实体同时具备创建和修改的功能,同时需要记录创建者和修改者,那么可以使用如下实体抽象</p><p><a href="/images/772156-20200210152004139-1032406767.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/772156-20200210152004139-1032406767.png" class="lazyload"></a></p><p>泛型版本,主键可自行指定 如下:</p><p><a href="/images/772156-20200210152044436-690608546.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/772156-20200210152044436-690608546.png" class="lazyload"></a></p><h2 id="审计实体-创建修改删除型实体"><a href="#审计实体-创建修改删除型实体" class="headerlink" title="审计实体 - 创建修改删除型实体"></a>审计实体 - 创建修改删除型实体</h2><ul><li>创建修改删除型实体</li></ul><p>如果当前记录具备创建、修改、删除三大功能,那么可以使用如下实体抽象</p><p><a href="/images/772156-20200210152235002-271672615.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/772156-20200210152235002-271672615.png" class="lazyload"></a></p><p>泛型版本 主键可自行指定 如下:</p><p><a href="/images/772156-20200210152302377-1979784491.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/772156-20200210152302377-1979784491.png" class="lazyload"></a></p><ul><li>创建修改删除型实体带创建者和修改者和删除者</li></ul><p>如果当前实体同时具备创建和修改和删除的功能,同时需要记录创建者和修改者和删除者,那么可以使用如下实体抽象</p><p><a href="/images/772156-20200210152415708-2128023039.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/772156-20200210152415708-2128023039.png" class="lazyload"></a></p><p>泛型版本 主键可自行指定 如下:</p><p><a href="/images/772156-20200210152435892-1567449035.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/772156-20200210152435892-1567449035.png" class="lazyload"></a></p><h2 id="审计聚合根-创建型聚合根"><a href="#审计聚合根-创建型聚合根" class="headerlink" title="审计聚合根 - 创建型聚合根"></a>审计聚合根 - 创建型聚合根</h2><p>如果当前聚合根具备创建的功能,那么可以使用如下实体抽象</p><p><a href="/images/772156-20200210152649069-1855270237.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/772156-20200210152649069-1855270237.png" class="lazyload"></a></p><p>泛型版本 主键自行指定如下</p><p><a href="/images/772156-20200210152715789-915928128.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/772156-20200210152715789-915928128.png" class="lazyload"></a></p><p>因为篇幅问题,聚合根其余的功能就不介绍了,和实体一致.其实本质聚合根就是一个实体.</p><p>ok,vnext关于DDD的实体结构架构大致就是如此,很简单,当然这边领域事件结构没有介绍,后续有随笔会介绍.可以看到,除了主键没有统一.这个设计非常的nice</p><h2 id="值对象"><a href="#值对象" class="headerlink" title="值对象"></a>值对象</h2><p>关于值对象有如下文章</p><p><a href="https://docs.microsoft.com/en-us/dotnet/standard/microservices-architecture/microservice-ddd-cqrs-patterns/implement-value-objects" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/dotnet/standard/microservices-architecture/microservice-ddd-cqrs-patterns/implement-value-objects</a></p><p>微软提供的关于值对象的实现思路,abp团队也是参照此文章实现,其代码如下:</p><p><a href="/images/772156-20200210154554848-2125052293.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/772156-20200210154554848-2125052293.png" class="lazyload"></a></p><p><a href="/images/772156-20200210154602154-136356771.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/772156-20200210154602154-136356771.png" class="lazyload"></a></p><p>abp团队也只是提供了简单的抽象,代码也比较简单,这里就不多说明了.</p>]]></content>
      
      
      <categories>
          
          <category> .Net Core </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DDD </tag>
            
            <tag> vnext2.0 </tag>
            
            <tag> abp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>abp vnext2.0核心组件之.Net Core默认DI组件切换到AutoFac源码解析</title>
      <link href="/2020/02/19/abp%20vnext2%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%BB%98%E8%AE%A4DI%E7%BB%84%E4%BB%B6%E5%88%87%E6%8D%A2%E5%88%B0AutoFac%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
      <url>/2020/02/19/abp%20vnext2%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%BB%98%E8%AE%A4DI%E7%BB%84%E4%BB%B6%E5%88%87%E6%8D%A2%E5%88%B0AutoFac%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>老版Abp对Castle的严重依赖在vnext中已经得到了解决,vnext中DI容器可以任意更换,为了实现这个功能,底层架构相较于老版abp,可以说是进行了高度重构.当然这得益于.Net Core的DI容器组件本身的优势.接着<a href="/2020/02/19/abp%20vnext2%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E4%B9%8B%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E7%BB%84%E4%BB%B6%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">abp vnext2.0核心组件之模块加载组件源码解析</a>上文,上文中我跳过了DI切换这个流程,因为我觉得这是整个框架的亮点之一,所以单独写了这篇随笔.</p><p>.Net Core2.2之后,切换DI的实现换了,改成实现如下接口</p><p><a href="/images/772156-20200208130423487-992679952.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/772156-20200208130423487-992679952.png" class="lazyload"></a></p><ol><li>核心ServiceProviderFactory接口实现</li></ol><p>核心原理非常的简单,看看vnext如何实现这个工厂约束接口,并返回指定provider.</p><p><a href="/images/772156-20200208130801744-1103994061.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/772156-20200208130801744-1103994061.png" class="lazyload"></a></p><p>大致的逻辑是传入ServiceCollection,遍历ServiceCollection使用autofac的containerbuilder进行注入.最后调用containerbuilder实例的builder的build方法,返回provider.一气呵成,很简单.</p><p>接着,重点来了,看看Populate方法,看看其如何将ServiceCollection中的类型注入autofac容器的.</p><p><a href="/images/772156-20200208131621616-1181578380.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/772156-20200208131621616-1181578380.png" class="lazyload"></a></p><p>先将原生DI的相关功能转换成Autofac的,接着进行类型注册.</p><p><a href="/images/772156-20200208131800050-1012425123.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/772156-20200208131800050-1012425123.png" class="lazyload"></a></p><p>第一步获取模块加载类型中所有的模块,模块信息如下:</p><p><a href="/images/772156-20200208132550787-601200257.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/772156-20200208132550787-601200257.png" class="lazyload"></a></p><p>第二步释出DI容器中的ServiceRegistrationActionList,这个list非常重要.在DI默认容器转中的类型注入Autofac容器时,会遍历所有类型,并将类型的类型和实现生成上下文,传递给指定的action,实现代码如下:</p><p><a href="/images/772156-20200208140201629-1803136506.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/772156-20200208140201629-1803136506.png" class="lazyload"></a></p><p> 看看vnext的示例代码如下:</p><p><a href="/images/772156-20200208140459371-288520931.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/772156-20200208140459371-288520931.png" class="lazyload"></a></p><p><a href="/images/772156-20200208140507853-326887959.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/772156-20200208140507853-326887959.png" class="lazyload"></a></p><p>简单的工作单元.</p><p>介绍了ServiceRegistrationActionList之后,接着看如下代码:</p><p><a href="/images/772156-20200208143047100-2023988337.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/772156-20200208143047100-2023988337.png" class="lazyload"></a><br><a href="/images/772156-20200208143111557-372005157.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/772156-20200208143111557-372005157.png" class="lazyload"></a></p><p>遍历所有的services集合,根据注入的方式和注入类型的差异进行区分,并注入到Autofac的ContainerBuilder中.代码很简单,挑个重点说下,如下:</p><p><a href="/images/772156-20200208145930306-512065551.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/772156-20200208145930306-512065551.png" class="lazyload"></a></p><p>红框中的第一行,代码如下:</p><p><a href="/images/772156-20200208145956739-22177564.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/772156-20200208145956739-22177564.png" class="lazyload"></a></p><p>如果当前类型所在的程序集属于应用程序集,不是与第三方程序集,则启动属性注入（反射的方式）.</p><p>红框中的第二行就是上面介绍的遍历所有类型,生成上下文,并执行DI中注入的ServiceRegistrationActionList中的action,这里注意拦截器的注入,如下:</p><p>在执行完所有的Action之后,其中有部分Action,如下:</p><p><a href="/images/772156-20200208164945513-697503128.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/772156-20200208164945513-697503128.png" class="lazyload"></a></p><p><a href="/images/772156-20200208164959949-847386437.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/772156-20200208164959949-847386437.png" class="lazyload"></a></p><p>是向上下文中的拦截器集合追加拦截器的,所以当所有的action执行完毕之后,所有的拦截器也被写入到了拦截器集合中.下一步初始化拦截器。如下:</p><p><a href="/images/772156-20200208165434374-298556136.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/772156-20200208165434374-298556136.png" class="lazyload"></a></p><p><a href="/images/772156-20200208165452803-510225999.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/772156-20200208165452803-510225999.png" class="lazyload"></a></p><p>这边后续会写一篇随笔,专门介绍vnext中的拦截器的机制.涉及到另一个组件.本文就不介绍了.不是本文的重点.</p><p>顺便提一句</p><p><a href="/images/772156-20200208164529138-1663615492.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/772156-20200208164529138-1663615492.png" class="lazyload"></a></p><p>有能力的可以做一下这个todo.</p><p>ok,到这里所有的默认DI中的类型集合全部注入到了autofac中,并且完成了拦截器的初始化和应用程序框架的自动属性注入功能.</p><p>整个Populate方法执行完毕.AbpAutofacServiceProviderFactory的CreateBuilder方法也就结束了.最终将默认DI中的类型集合(IServiceCollection)转换成Autofac中的ContainerBuilder</p><p>接着看看CreateServiceProvider方法如下:</p><p><a href="/images/772156-20200208170457752-1572519380.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/772156-20200208170457752-1572519380.png" class="lazyload"></a></p><p>看看AutofacServiceProvider的构造,如下:</p><p><a href="/images/772156-20200208170815594-1660362547.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/772156-20200208170815594-1660362547.png" class="lazyload"></a></p><p>具体参考源码,实现了默认DI的获取Services接口。所以你可以继续用默认DI提供的方法,但是此时DI已被切换成了Autofac.</p><ol start="2"><li>模块加载系统如何与之配合</li></ol><p>接下去看看vnext的模块加载系统如何配合AbpAutofacServiceProviderFactory完成DI切换</p><p>第一步需要注入Autofac服务.</p><p><a href="/images/772156-20200208184341267-244015684.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/772156-20200208184341267-244015684.png" class="lazyload"></a></p><p>在注入核心的工厂服务后,且整个vnext框架的类型全部注入到默认DI中,那么需要触发核心工厂服务的相关方法如下:</p><p><a href="/images/772156-20200208190056319-245511088.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/772156-20200208190056319-245511088.png" class="lazyload"></a></p><p>继续观察ServiceCollectionCommonExtensions类下面的BuildServiceProviderFromFactory,如下</p><p><a href="/images/772156-20200208191157549-1473342610.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/772156-20200208191157549-1473342610.png" class="lazyload"></a></p><p>直接调用核心的工厂服务的CreateBuilder方法,这样所有默认DI中的类型全部注入到了autofac的容器中.并且切换默认DI容器到了autofac.替换默认DI的核心接口实现如下:</p><p><a href="/images/772156-20200208191713155-790035453.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/772156-20200208191713155-790035453.png" class="lazyload"></a></p><p>最后需要将模块加载系统中预先注入的ServiceProvider替换成核心的工厂服务的CreateBuilder方法执行后生成的ServiceProvider.</p><p><a href="/images/772156-20200208192625705-603294052.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/772156-20200208192625705-603294052.png" class="lazyload"></a></p><p>ok,整个DI切换流程到这里结束.abp团队的实现很简洁.如果你需要扩展其他的DI容器,可以参照他们的实现.</p>]]></content>
      
      
      <categories>
          
          <category> .Net Core </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DDD </tag>
            
            <tag> vnext2.0 </tag>
            
            <tag> abp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>abp vnext2.0核心组件之模块加载组件源码解析</title>
      <link href="/2020/02/19/abp%20vnext2%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E4%B9%8B%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E7%BB%84%E4%BB%B6%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
      <url>/2020/02/19/abp%20vnext2%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E4%B9%8B%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E7%BB%84%E4%BB%B6%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>abp vnext是abp官方在abp的基础之上构建的微服务架构,说实话,看完核心组件源码的时候,很兴奋,整个框架将组件化的细想运用的很好,真的超级解耦.老版整个框架依赖Castle的问题,vnext对其进行了解耦,支持AutoFac或者使用.Net Core的默认容器.vnext依然沿用EF core为主,其余ORM为辅助的思想,当然EF core来实现DDD确实有优势,EventBus提供了分布式版本,并提供了RabbitMQ的实现版本,Aop拦截器依然采用Castle.Core.AsyncInterceptor.这一点Dora.Interception貌似可以解决,估计如果高度组件化,那么这也是一个扩展点.整个模块加载系统更加的完善,提供了跟多可选择的特性,工作单元也进行了小幅度的重构,代码更加的通俗易懂(在实现异步工作单元嵌套的设计就有体现)等等还有很多,当然不是本文的重点,vnext2.0是个值得使用的框架.下面开始回到正题.</p><h2 id="1、模块加载系统"><a href="#1、模块加载系统" class="headerlink" title="1、模块加载系统"></a>1、模块加载系统</h2><p>模块加载系统算是vnext的整个框架的入口,离了他,这个框架就废了.具体它有什么作用,看下面的代码分析,模块加载系统的入口如下:</p><p><a href="/images/640.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/640.png" class="lazyload"></a></p><p>每个应用框架必须要有一个启动模块类型,可以通过泛型或者Type实例传入,并且给定启动参数.</p><p>启动模块类型:虽然上面给定的约束是必须实现IAbpModule,但是大多数的实现情况是</p><p><a href="/images/640.webp" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/640.webp" class="lazyload"></a></p><p>暂时不讲 AbpModule的源码,后面分析到具体的流程再做介绍.</p><p>ok,看看AbpApplicationFactory工厂做了什么了,通过名字分析很明显.AbpApplication的工厂.</p><p><a href="/images/640(1).webp" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/640(1).webp" class="lazyload"></a></p><p>分析这个方法就能得出,只要传入启动模块的类型和DI的ServiceCollection和启动应用的参数,就能构建一个IAbpApplicationWithExternalServiceProvider,那么看看IAbpApplicationWithExternalServiceProvider都有什么</p><p><a href="/images/640(2).webp" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/640(2).webp" class="lazyload"></a></p><p>构建完成基本的实体后,调用Initialize方法初始化框架.再看看IAbpApplication接口</p><p><a href="/images/640(3).webp" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/640(3).webp" class="lazyload"></a></p><p>包含启动模块类型,DI注入集合、DI服务提供类,以及一个关闭应用程序必须执行的ShutDown方法.在看看IModuleContainer</p><p><a href="/images/640(1).png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/640(1).png" class="lazyload"></a></p><p>包含模块集合,在Abp中,模块代表一个程序集.这里就是启动abp vnext框架的启动模块类型所依赖的所有模块类型即所有的程序集集合你可以这样理解.因为一个Module类型(继承AbpModule类型或者实现IAbpModule接口的类型代表一个程序集.且一个程序集只有一个Module类型(继承AbpModule类型或者实现IAbpModule接口的类型).</p><p>ok,接着回到上面的代码</p><p><a href="/images/640(4).webp" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/640(4).webp" class="lazyload"></a></p><p>此处省略一些无关核心流程的代码,代码如下:</p><p><a href="/images/640(2).png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/640(2).png" class="lazyload"></a></p><p>简单的一些非空校验,这里有一个非常有趣的设计,如下:</p><p><a href="/images/640(5).webp" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/640(5).webp" class="lazyload"></a></p><p>继续查看,如下</p><p><a href="/images/640(3).png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/640(3).png" class="lazyload"></a></p><p>ObjectAccessor源码如下:</p><p><a href="/images/640(6).webp" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/640(6).webp" class="lazyload"></a></p><p>类似装饰者模式,内部容纳一个类型.最后</p><p><a href="/images/640(7).webp" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/640(7).webp" class="lazyload"></a></p><p>ok,到这里整个流程大致就是,给IServiceProvider创建一个ObjectAccessor,且ObjectAccessor没有Value值,同时将ObjectAccessor写入DI,并做了简单的搜索优化.关于IServiceProvider的ObjectAccessor的作用,暂时不介绍,后续会说.</p><p>接着看如下代码:</p><p><a href="/images/640(8).webp" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/640(8).webp" class="lazyload"></a></p><p>初始化外部设置参数,接招向DI中注入IAbpApplication和IModuleContainer的单例对象.</p><p>接着看下面的代码:</p><p><a href="/images/640(4).png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/640(4).png" class="lazyload"></a></p><p><a href="/images/640(5).png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/640(5).png" class="lazyload"></a></p><p>注入配置文件、日志、国际化等服务.接着看AddCoeAbpServices方法</p><p><a href="/images/640(6).png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/640(6).png" class="lazyload"></a></p><p><a href="/images/640(7).png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/640(7).png" class="lazyload"></a></p><p>注入ModuleLoader(处理程序集间依赖关系,处理模块加载生命周期、的核心类型)、程序集发现类(所有程序集都能通过该类型拿到,只要程序集加入到了框架)、类型发现类(程序集集合所包含的所有类型)</p><p><a href="/images/640(9).webp" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/640(9).webp" class="lazyload"></a></p><p>初始化配置文件系统、等等操作,接着看如下代码,将上述类型写入DI</p><p><a href="/images/640(8).png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/640(8).png" class="lazyload"></a></p><p>接下去这行代码就有趣了,如下:</p><p><a href="/images/640(10).webp" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/640(10).webp" class="lazyload"></a></p><p>看看它干了什么,如下:</p><p><a href="/images/640(11).webp" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/640(11).webp" class="lazyload"></a></p><p>看看 services.GetConventionalRegistrars干了什么,如下:</p><p><a href="/images/640(9).png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/640(9).png" class="lazyload"></a></p><p>很明显,从DI中读取程序集注册规则类列表,如果没有,则写入默认的程序集注册规则类.所以,这里如果你想自定义程序集注册规则,那么只需在有效的应用程序加载生命周期阶段注入自定义的程序集注册类即可,该类型必须实现下图所示接口</p><p><a href="/images/640(10).png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/640(10).png" class="lazyload"></a></p><p>ok,这个扩展点讲完之后,看看默认的程序集注册规则类DefaultConventionalRegistrar干了什么,如下：</p><p><a href="/images/640(12).webp" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/640(12).webp" class="lazyload"></a></p><p>很简单,自行阅读,再看看AddType的实现,如下：</p><p><a href="/images/640(13).webp" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/640(13).webp" class="lazyload"></a></p><p>支持类型跳过,如果类型打了DisableConventionalRegistrationAttribute特性,那么该类型将不会被写入DI.</p><p><a href="/images/640(14).webp" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/640(14).webp" class="lazyload"></a></p><p>如果当前类型没有打DependencyAttribute,或者打了DependencyAttribute特性,没有设置Lifetime,则当前类型也不会写入DI.</p><p>这里注意,根据代码可以发现,abp给类型生命周期的方式有两种,老版只有一种,如下:</p><ul><li>第一种:</li></ul><p><a href="/images/640(11).png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/640(11).png" class="lazyload"></a></p><p>通过实现ISingletonDependency(单例注入)，ITransientDependency(普通引用类型)，IScopedDependency(范围内唯一)三大接口来表示当前类型的生命周期,老版abp也是使用这种方式,但是没有IScopedDependency</p><ul><li>第二种:</li></ul><p><a href="/images/640(12).png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/640(12).png" class="lazyload"></a></p><p>通过DependencyAttribute特性,结构如下</p><p><a href="/images/640(13).png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/640(13).png" class="lazyload"></a></p><p>接着,如下代码</p><p><a href="/images/640(14).png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/640(14).png" class="lazyload"></a></p><p>如果当前类型打了ExposeServicesAttribute特性,那么则会调用该特性的如下方法</p><p><a href="/images/640(15).png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/640(15).png" class="lazyload"></a></p><p>这个方法的用途是找出如果我们需要从DI中释出个类型,可以使用哪几种方式(常用的是接口,自身等),示例代码如下:</p><p><a href="/images/640(15).webp" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/640(15).webp" class="lazyload"></a></p><p>那么如果需要在框架中使用TestClass的实现,可以用ITestClass接口进行依赖注入,因为</p><p><a href="/images/640(16).webp" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/640(16).webp" class="lazyload"></a></p><p>当然这里可以写多个,因为</p><p><a href="/images/640(17).webp" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/640(17).webp" class="lazyload"></a></p><p>ExposeServicesAttribute特性中的IncludeDefaults和IncludeSelf属性是默认的策略</p><p>IncludeDefaults设置为true是根据类型找出其实现的接口,且接口必须以I字母开头,且接口后面的名字必须和当前类型相等.如果匹配那么该接口有效,也可以进行依赖注入.</p><p>IncludeSelf设置为true,则可以通过当前类型进行依赖注入.</p><p>接着看如下代码</p><p><a href="/images/640(16).png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/640(16).png" class="lazyload"></a></p><p><a href="/images/640(17).png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/640(17).png" class="lazyload"></a></p><p>很简单,只需在有效的应用程序加载生命周期阶段注入指定的Action,注入方式如下:</p><p><a href="/images/640(18).webp" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/640(18).webp" class="lazyload"></a></p><p>使用例子,类型映射,如下:</p><p><a href="/images/640(19).webp" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/640(19).webp" class="lazyload"></a></p><p>最后看如下代码</p><p><a href="/images/640(18).png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/640(18).png" class="lazyload"></a></p><p>这段代码很简单,就不解释了.DependencyAttribute特性给上对应的值就能执行指定的操作,ok,到这里总结一下这种设计的用处,非常nice,原先老版abp注册系统核心单例类型是依赖castle的,如果换成这种设计方式,更加的灵活,如果我们需要给底层添加一个核心类,只需要创建一个类,然后配合Dependency特性和ExposeServices特性即可和DI完美集合,同时还提供了Action扩展,让你可以干很多的事情,就这一点,比老版abp好太多.到这里DefaultConventionalRegistrar介绍完毕</p><p>ok,在回到AddCoreAbpServices方法,如下:</p><p><a href="/images/640(19).png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/640(19).png" class="lazyload"></a></p><p>这里也很简单,向DI中预先写入AbpModuleLifecycleOptions，该参数用于控制模块加载的生命周期,这四个Contributor分别对应模块加载生命周期的接口,</p><p><a href="/images/640(20).png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/640(20).png" class="lazyload"></a></p><p><a href="/images/640(21).png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/640(21).png" class="lazyload"></a></p><p><a href="/images/640(20).webp" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/640(20).webp" class="lazyload"></a></p><p><a href="/images/640(22).png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/640(22).png" class="lazyload"></a></p><p>再看看核心Module的抽象</p><p><a href="/images/640(21).webp" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/640(21).webp" class="lazyload"></a></p><p>到这里肯定很多人很困惑,所以这里跳过一些流程,看下ModuleManager如何处理,如下</p><p><a href="/images/640(22).webp" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/640(22).webp" class="lazyload"></a></p><p>释出Contributor集合</p><p><a href="/images/640(23).png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/640(23).png" class="lazyload"></a></p><p><a href="/images/640(24).png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/640(24).png" class="lazyload"></a></p><p>Contributor的作用很明显,模块加载生命周期中你可以执行的一些方法.这些方法会拿到一个ServiceProvider,即你可以操作DI,完成一些关键服务的操作.</p><p>关于模块加载的生命周期方法有哪些,如下</p><p><a href="/images/640(23).webp" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/640(23).webp" class="lazyload"></a></p><p>每个接口对应一个生命周期,这和老版Abp的设计也完全不同.优缺点暂时没发现.</p><p>接着,如下:</p><p><a href="/images/640(25).png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/640(25).png" class="lazyload"></a></p><p>调用ModuleLoader单例实例,执行加载模块的方法.核心算法和老版Abp一样,这里稍微解释下,</p><p>核心点如下：</p><ol><li>加载启动模块所有依赖的模块,并设置依赖项,最后生成IAbpModuleDescriptor集合</li></ol><p><a href="/images/640(26).png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/640(26).png" class="lazyload"></a></p><ol start="2"><li>模块进行拓扑排序,进行循环依赖检测</li></ol><p><a href="/images/640(24).webp" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/640(24).webp" class="lazyload"></a></p><p>ok,下面开始解析核心点源码</p><p>通过DependsOnAttribute特性来处理模块间的依赖关系.核心代码如下:</p><p><a href="/images/640(27).png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/640(27).png" class="lazyload"></a></p><p>拿到当前类型的DependsOnAttribute特性,解析其内部的类型,加入到dependencies依赖类型集合.所以表示模块间的依赖关系根据如上代码可以得出两种模式,如下:</p><p><a href="/images/640(25).webp" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/640(25).webp" class="lazyload"></a></p><blockquote><p>常用的是第二种.</p></blockquote><p>通过上面的方法拿到所有的依赖类型集合之后,执行下面的递归方法</p><p><a href="/images/640(28).png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/640(28).png" class="lazyload"></a></p><p>这样就可以遍历出所有的启动模块以来的所有模块.同时去除了重复的模块.最后遍历所有的模块生成如下类型的实例</p><p><a href="/images/640(29).png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/640(29).png" class="lazyload"></a></p><p>模块实例的生命周期为单例,如下图:</p><p><a href="/images/640(30).png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/640(30).png" class="lazyload"></a></p><p>接着开始处理启动参数中配置的插件模块</p><p><a href="/images/640(31).png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/640(31).png" class="lazyload"></a></p><p>插件模块的三种添加方式如下</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public static class PlugInSourceListExtensions</span><br><span class="line">    &#123;</span><br><span class="line">        public static void AddFolder(</span><br><span class="line">            [NotNull] this PlugInSourceList list,</span><br><span class="line">            [NotNull] string folder,</span><br><span class="line">            SearchOption searchOption &#x3D; SearchOption.TopDirectoryOnly)</span><br><span class="line">        &#123;</span><br><span class="line">            Check.NotNull(list, nameof(list));</span><br><span class="line"></span><br><span class="line">            list.Add(new FolderPlugInSource(folder, searchOption));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public static void AddTypes(</span><br><span class="line">            [NotNull] this PlugInSourceList list,</span><br><span class="line">            params Type[] moduleTypes)</span><br><span class="line">        &#123;</span><br><span class="line">            Check.NotNull(list, nameof(list));</span><br><span class="line"></span><br><span class="line">            list.Add(new TypePlugInSource(moduleTypes));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public static void AddFiles(</span><br><span class="line">            [NotNull] this PlugInSourceList list,</span><br><span class="line">            params string[] filePaths)</span><br><span class="line">        &#123;</span><br><span class="line">            Check.NotNull(list, nameof(list));</span><br><span class="line"></span><br><span class="line">            list.Add(new FilePlugInSource(filePaths));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div><p>这边只介绍一种,其余核心流程都一样,如下:</p><p>FolderPlugInSource添加插件类型,其核心参数如下:</p><p><a href="/images/640(26).webp" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/640(26).webp" class="lazyload"></a></p><p>直接给文件夹路径+名称,扫描下面的插件程序集,并进行程序集过滤,核心的过滤方法如下:</p><p><a href="/images/640(33).png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/640(33).png" class="lazyload"></a></p><p>最后,返回实现了AbpModule的核心模块类型</p><p><a href="/images/640(27).webp" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/640(27).webp" class="lazyload"></a></p><p>ok,接着回到模块加载系统的加载插件方法,如下:</p><p><a href="/images/640(28).webp" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/640(28).webp" class="lazyload"></a></p><p><a href="/images/640(29).webp" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/640(29).webp" class="lazyload"></a></p><p>ok,这里可以发现亮点</p><ol><li><p>你可以同时添加多种形式的插件宿主,可以是文件夹下所有的插件程序集、可以是程序集解决方案、也可以是一个指定的程序集文件.Abp暂时提供了这三种,当然如果你有实力,也可以编写远程调用程序集插件.</p></li><li><p>和模块加载系统完成了集成,和上面的流程一样,加载出所有启动模块依赖的类型,并写入DI</p></li></ol><p><a href="/images/640(30).webp" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/640(30).webp" class="lazyload"></a></p><p>ok,到这里插件模块介绍完毕.最后和普通模块一样生成IAbpModuleDescriptor集合</p><p>接着,拿到所有的模块集合之后(包括插件),开始设置所有模块间的依赖关系,如下,细心的会发现上面的</p><p><a href="/images/640(34).png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/640(34).png" class="lazyload"></a></p><p>中有依赖集合.下面的代码就是整理这个关系的.</p><p><a href="/images/640(35).png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/640(35).png" class="lazyload"></a></p><p>这里,逻辑很简单,就不介绍了,直接跳过,主要是通过DependsOnAttribute特性来实现.</p><p>接下去介绍核心点二模块进行拓扑排序,进行循环依赖检测</p><p>此时,我们拿到了一个完整的模块集合,内部的依赖关系也已经初步执行好.</p><p><a href="/images/640(36).png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/640(36).png" class="lazyload"></a></p><p>核心代码如下,关于拓扑排序(算法的核心逻辑自行查阅代码,主要内容是按照依赖关系依次加入到集合,后期可一次执行,这样就可以集成生命周期),防止循环依赖就不说了,接着,将启动模块放到最后为了配合模块生命周期方法的执行.</p><p>ok,到这里两个核心点介绍完毕.</p><p>接下去.如下代码</p><p><a href="/images/640(31).webp" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/640(31).webp" class="lazyload"></a></p><p><a href="/images/640(32).webp" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/640(32).webp" class="lazyload"></a></p><p><a href="/images/640(33).webp" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/640(33).webp" class="lazyload"></a></p><p>生成如下上下文,并单例写入DI</p><p><a href="/images/640(34).webp" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/640(34).webp" class="lazyload"></a></p><p>这个Item属性醉了,个人感觉没什么用,因为下面这个for循环</p><p><a href="/images/640(35).webp" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/640(35).webp" class="lazyload"></a></p><p>接着执行如下代码</p><p><a href="/images/640(37).png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/640(37).png" class="lazyload"></a></p><p><a href="/images/640(38).png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/640(38).png" class="lazyload"></a></p><p>所以这两个生命周期接口执行的时间节点一定要记住.同时上下文会给你DI容器,方便你进行任何必须的类型操作.</p><p>接着</p><p><a href="/images/640(39).png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/640(39).png" class="lazyload"></a></p><p>将当前模块类型对应的程序集中所有的类型写入DI,默认的注入规则上面已经介绍,默认的注册器类型为DefaultConventionalRegistrar.同时执行生命周期接口IZcfModule.</p><p>到这里已经执行的三个模块生命周期接口如下:</p><p><a href="/images/640(40).png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/640(40).png" class="lazyload"></a></p><p>切记其执行的节点.</p><p>接着开始初始化模块系统,注意,这边我跳过了DI容器切换的的内容(关于DI容器切换的源码分析后续的博文会介绍)代码如下:</p><p><a href="/images/640(36).webp" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/640(36).webp" class="lazyload"></a></p><p>从DI中释出单例ModuleManager类,执行如下初始化方法</p><p><a href="/images/640(41).png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/640(41).png" class="lazyload"></a></p><p>这段代码进行简单的模块加载日志记录,后面的核心代码上面说过,执行预定义的模块生命周期方法,对应如下接口：</p><p><a href="/images/640(37).webp" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/640(37).webp" class="lazyload"></a></p><p>执行这四个接口必须实现的方法,当然在AbpModule中都以virtual标记,所以你可以按照顺序一次进行一些类型操作.但是这几个生命周期函数,上下文只提供ServiceProvider,</p><p>功能做了限制.其余三个生命周期接口提供的是IServiceCollection实例,所以他们之间还是有差别的,除了执行顺序之外.</p><p>ok,到这里abp vnext2.0的核心模块记载系统核心流程源码分析结束了,纯属个人理解,能力有限,有问题请指正!</p>]]></content>
      
      
      <categories>
          
          <category> .Net Core </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DDD </tag>
            
            <tag> vnext2.0 </tag>
            
            <tag> abp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>.NET中RabbitMQ的使用</title>
      <link href="/2020/02/03/NET%E4%B8%ADRabbitMQ%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2020/02/03/NET%E4%B8%ADRabbitMQ%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>MQ全称为Message Queue, 消息队列（MQ）是一种应用程序对应用程序的通信方法。RabbitMQ是一个在AMQP基础上完整的，可复用的企业消息系统。他遵循Mozilla Public License开源协议。AMQP(高级消息队列协议) 是一个异步消息传递所使用的应用层协议规范，作为线路层协议，而不是API（例如JMS），AMQP 客户端能够无视消息的来源任意发送和接受信息。AMQP的原始用途只是为金融界提供一个可以彼此协作的消息协议，而现在的目标则是为通用消息队列架构提供通用构建工具。因此，面向消息的中间件 （MOM）系统，例如发布/订阅队列，没有作为基本元素实现。AMQP当中有四个概念非常重要（一个虚拟主机持有一组交换机、队列和绑定）：</p><blockquote><p>virtual host，虚拟主机<br>exchange，交换机<br>queue，队列<br>binding，绑定</p></blockquote><p>Window下安装RabbbitMQ</p><h2 id="文件下载安装"><a href="#文件下载安装" class="headerlink" title="文件下载安装"></a>文件下载安装</h2><p>Rabbit MQ 是建立在强大的Erlang OTP平台上，因此安装Rabbit MQ的前提是安装Erlang。通过下面两个连接下载安装3.2.3 版本：</p><ol><li>下载并安装 <a href="http://www.erlang.org/download/otp_win32_R16B03.exe" target="_blank" rel="noopener">Erlang OTP For Windows</a> (vR16B03)</li><li>运行安装 <a href="http://www.rabbitmq.com/releases/rabbitmq-server/v3.2.3/rabbitmq-server-3.2.3.exe" target="_blank" rel="noopener">Rabbit MQ Server Windows Installer</a> (v3.2.3)</li></ol><p>默认安装的Rabbit MQ 监听端口是5672。先安装Erlang OTP后安装RabbitMQ，安装方式默认即可，RabbitMQ可以勾选安装后台服务、服务启动和停止等操作。</p><h2 id="激活Rabbit-MQ’s-Management-Plugin"><a href="#激活Rabbit-MQ’s-Management-Plugin" class="headerlink" title="激活Rabbit MQ’s Management Plugin"></a>激活Rabbit MQ’s Management Plugin</h2><p>使用Rabbit MQ 管理插件，可以更好的可视化方式查看Rabbit MQ 服务器实例的状态，打开CMD命令，cd到安装目录（..\rabbitmq_server-3.2.3\sbin）下，输入下面的命令激活：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmq-plugins enable rabbitmq_management</span><br></pre></td></tr></table></figure></div><p>要重启服务才能生效，可以执行</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net stop RabbitMQ &amp;&amp; net start RabbitMQ</span><br></pre></td></tr></table></figure></div><p>输入网址，打开监控页面：  <a href="http://localhost:15672" target="_blank" rel="noopener">http://localhost:15672</a> (<strong>默认账号和密码：guest 和guest</strong>)</p><p><a href="/images/433460-20161004205112910-935436305.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/433460-20161004205112910-935436305.png" class="lazyload"></a></p><h2 id="配置RabbitMQ用户权限"><a href="#配置RabbitMQ用户权限" class="headerlink" title="配置RabbitMQ用户权限"></a>配置RabbitMQ用户权限</h2><p>RabbitMQ是存在用户权限的，默认是guest 密码也是guest，隶属于Administrator管理员下。现需要配置新用户和权限，继续打开CMD命令，cd到安装目录sbin下：</p><p>用户操作指令：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">::查询服务状态</span><br><span class="line">rabbitmqctl status</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">::列举虚拟主机列表</span><br><span class="line">rabbitmqctl list_vhosts</span><br><span class="line">::列举用户列表</span><br><span class="line">rabbitmqctl list_users</span><br><span class="line"> </span><br><span class="line">:: 添加用户和密码</span><br><span class="line">rabbitmqctl  add_user  hao  abc123</span><br><span class="line"> </span><br><span class="line">:: 设置权限  </span><br><span class="line">rabbitmqctl  set_permissions  yy  &quot;.*&quot;  &quot;.*&quot;  &quot;.*&quot;</span><br><span class="line"> </span><br><span class="line">:: 分配用户组</span><br><span class="line">rabbitmqctl  set_user_tags yy administrator</span><br><span class="line"> </span><br><span class="line">:: 删除guest用户</span><br><span class="line">rabbitmqctl delete_user guest</span><br><span class="line">::修改用户密码</span><br><span class="line">rabbitmqctl change_password &#123;username&#125;  &#123;newpassowrd&#125;</span><br></pre></td></tr></table></figure></div><p>像ADO.Net的五大对象也是，操作数据库先进行连接connection,然后使用command过滤出要选择的数据，使用DataReader或DataSet、DataAdapter,在RabbitMQ的使用当中也有基本固定的步骤。</p><h3 id="一、生产者"><a href="#一、生产者" class="headerlink" title="一、生产者"></a>一、生产者</h3><ol><li><p>创建连接connection:不管是生产者还是消费者都需要先于RabbitMQ服务器连接，才能进行数据交换</p></li><li><p>创建通道 Channel:生产者、消费者的消息传递是在通道下传递的</p></li><li><p>声明交换器、队列</p></li><li><p>交换器与队列进行绑定</p></li><li><p>通过交换器BasicPublish数据到队列</p></li></ol><h3 id="二、消费者"><a href="#二、消费者" class="headerlink" title="二、消费者"></a>二、消费者</h3><ol><li><p>创建连接 :和生产者一样</p></li><li><p>创建通道:和生产者一样</p></li><li><p>声明交换器、队列</p></li><li><p>交换器与队列进行绑定</p></li><li><p>通过BasicGet方法获取队列中的数据</p></li></ol><p>上面一、二是大致的基本步骤，按照大致的步骤来基本不会出现大的问题，其实生产者和消费者的前4个步骤基本一样，主要是第5个步骤，一个是生产BasicPublish发布，一个是获取Get。</p><h3 id="三、出现的错误"><a href="#三、出现的错误" class="headerlink" title="三、出现的错误"></a>三、出现的错误</h3><p>在ConnectionFactory创建连接对象时出现上面提到的bug:None of the specified endpoints were reachable.</p><p><a href="/images/300118-20190410115125548-466532967.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/300118-20190410115125548-466532967.png" class="lazyload"></a></p><h3 id="四、demo"><a href="#四、demo" class="headerlink" title="四、demo"></a>四、demo</h3><ul><li>1.首先在生产者端和消费者端引入RabbitMQ</li></ul><p><a href="/images/300118-20190410142122887-113139489.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/300118-20190410142122887-113139489.png" class="lazyload"></a></p><ul><li>2.生产者端</li></ul><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">using RabbitMQ.Client;</span><br><span class="line">using System;</span><br><span class="line">using System.Text;</span><br><span class="line"></span><br><span class="line">namespace RabbitMQProduct</span><br><span class="line">&#123;</span><br><span class="line">    class Program</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;Welcome to RabbitMQ Product!&quot;);</span><br><span class="line">            DirectExchangeSendMsg();</span><br><span class="line">            &#x2F;&#x2F; TopicExchangeSendMsg();</span><br><span class="line">            Console.WriteLine(&quot;按任意值，退出程序&quot;);</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">        &#x2F;&#x2F;&#x2F; 连接配置</span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">        private static readonly ConnectionFactory rabbitMqFactory &#x3D; new ConnectionFactory()</span><br><span class="line">        &#123;</span><br><span class="line">            UserName &#x3D; &quot;howdyadmin&quot;,</span><br><span class="line">            Password &#x3D; &quot;123456&quot;,</span><br><span class="line">            Port &#x3D; 5672,</span><br><span class="line">            VirtualHost &#x3D; &quot;howdyVirtualHost&quot;</span><br><span class="line">        &#125;;</span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">        &#x2F;&#x2F;&#x2F; 路由名称</span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">        const string ExchangeName &#x3D; &quot;howdy.exchange&quot;;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;队列名称</span><br><span class="line">        const string QueueName &#x3D; &quot;howdy.queue&quot;;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">        &#x2F;&#x2F;&#x2F; 路由名称</span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">        const string TopExchangeName &#x3D; &quot;topic.howdy.exchange&quot;;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;队列名称</span><br><span class="line">        const string TopQueueName &#x3D; &quot;topic.howdy.queue&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">        &#x2F;&#x2F;&#x2F;  单点精确路由模式</span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">        public static void DirectExchangeSendMsg()</span><br><span class="line">        &#123;</span><br><span class="line">            using (IConnection conn &#x3D; rabbitMqFactory.CreateConnection())</span><br><span class="line">            &#123;</span><br><span class="line">                using (IModel channel &#x3D; conn.CreateModel())</span><br><span class="line">                &#123;</span><br><span class="line">                    channel.ExchangeDeclare(ExchangeName, ExchangeType.Direct, durable: true, autoDelete: false, arguments: null);</span><br><span class="line">                    channel.QueueDeclare(QueueName, durable: true, autoDelete: false, exclusive: false, arguments: null);</span><br><span class="line">                    channel.QueueBind(QueueName, ExchangeName, routingKey: QueueName);</span><br><span class="line"></span><br><span class="line">                    var props &#x3D; channel.CreateBasicProperties();</span><br><span class="line">                    props.Persistent &#x3D; true;</span><br><span class="line">                    string vadata &#x3D; Console.ReadLine();</span><br><span class="line">                    while (vadata !&#x3D; &quot;exit&quot;)</span><br><span class="line">                    &#123;</span><br><span class="line">                        var msgBody &#x3D; Encoding.UTF8.GetBytes(vadata);</span><br><span class="line">                        channel.BasicPublish(exchange: ExchangeName, routingKey: QueueName, basicProperties: props, body: msgBody);</span><br><span class="line">                        Console.WriteLine(string.Format(&quot;***发送时间:&#123;0&#125;，发送完成，输入exit退出消息发送&quot;,</span><br><span class="line">                            DateTime.Now.ToString(&quot;yyyy-MM-dd HH:mm:ss&quot;)));</span><br><span class="line">                        vadata &#x3D; Console.ReadLine();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">        &#x2F;&#x2F;&#x2F; topic 模糊匹配模式，符号“#”匹配一个或多个词，符号“*”匹配不多不少一个词。因此“log.#”能够匹配到“log.info.oa”，但是“log.*” 只会匹配到“log.error”</span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">        public static void TopicExchangeSendMsg()</span><br><span class="line">        &#123;</span><br><span class="line">            using (IConnection conn &#x3D; rabbitMqFactory.CreateConnection())</span><br><span class="line">            &#123;</span><br><span class="line">                using (IModel channel &#x3D; conn.CreateModel())</span><br><span class="line">                &#123;</span><br><span class="line">                    channel.ExchangeDeclare(TopExchangeName,ExchangeType.Topic, durable: false, autoDelete: false, arguments: null);</span><br><span class="line">                    channel.QueueDeclare(TopQueueName, durable: false, autoDelete: false, exclusive: false, arguments: null);</span><br><span class="line">                    channel.QueueBind(TopQueueName, TopExchangeName, routingKey: TopQueueName);</span><br><span class="line">                    &#x2F;&#x2F;var props &#x3D; channel.CreateBasicProperties();</span><br><span class="line">                    &#x2F;&#x2F;props.Persistent &#x3D; true;</span><br><span class="line">                    string vadata &#x3D; Console.ReadLine();</span><br><span class="line">                    while (vadata !&#x3D; &quot;exit&quot;)</span><br><span class="line">                    &#123;</span><br><span class="line">                        var msgBody &#x3D; Encoding.UTF8.GetBytes(vadata);</span><br><span class="line">                        channel.BasicPublish(exchange: TopExchangeName, routingKey: TopQueueName, basicProperties: null, body: msgBody);</span><br><span class="line">                        Console.WriteLine(string.Format(&quot;***发送时间:&#123;0&#125;，发送完成，输入exit退出消息发送&quot;, DateTime.Now.ToString(&quot;yyyy-MM-dd HH:mm:ss&quot;)));</span><br><span class="line">                        vadata &#x3D; Console.ReadLine();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>上面的代码分别创建了两个路由和两个队列，一种是DirectExchange，一种是TopicExchange，验证时需要生产者和消费者使用同一种的ExChange。</p><ul><li>3.消费者端</li></ul><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line">using RabbitMQ.Client;</span><br><span class="line">using RabbitMQ.Client.Events;</span><br><span class="line">using System;</span><br><span class="line">using System.Text;</span><br><span class="line"></span><br><span class="line">namespace RabbitMQConsumer</span><br><span class="line">&#123;</span><br><span class="line">    class Program</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;Welcome to RabbitMQ Consumer!&quot;);</span><br><span class="line">            &#x2F;&#x2F;DirectAcceptExchange();</span><br><span class="line">             &#x2F;&#x2F;DirectAcceptExchangeEvent();</span><br><span class="line">            DirectAcceptExchangeTask();</span><br><span class="line">            &#x2F;&#x2F;TopicAcceptExchange();</span><br><span class="line">            Console.WriteLine(&quot;按任意值，退出程序&quot;);</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">        &#x2F;&#x2F;&#x2F; 连接配置</span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">        private static readonly ConnectionFactory rabbitMqFactory &#x3D; new ConnectionFactory()</span><br><span class="line">        &#123;</span><br><span class="line">            HostName &#x3D; &quot;127.0.0.1&quot;,</span><br><span class="line">            UserName &#x3D; &quot;howdyadmin&quot;,</span><br><span class="line">            Password &#x3D; &quot;123456&quot;,</span><br><span class="line">            Port &#x3D; 5672,</span><br><span class="line">            VirtualHost &#x3D; &quot;howdyVirtualHost&quot;</span><br><span class="line">        &#125;;</span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">        &#x2F;&#x2F;&#x2F; 路由名称</span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">        const string ExchangeName &#x3D; &quot;howdy.exchange&quot;;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;队列名称</span><br><span class="line">        const string QueueName &#x3D; &quot;howdy.queue&quot;;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">        &#x2F;&#x2F;&#x2F; 路由名称</span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">        const string TopExchangeName &#x3D; &quot;topic.howdy.exchange&quot;;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;队列名称</span><br><span class="line">        const string TopQueueName &#x3D; &quot;topic.howdy.queue&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">        &#x2F;&#x2F;&#x2F; 基于时间轮询的，每隔一段时间获取一次</span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">        public static void DirectAcceptExchange()</span><br><span class="line">        &#123;</span><br><span class="line">            using (IConnection conn &#x3D; rabbitMqFactory.CreateConnection())</span><br><span class="line">            &#123;</span><br><span class="line">                using (IModel channel &#x3D; conn.CreateModel())</span><br><span class="line">                &#123;</span><br><span class="line">                    channel.ExchangeDeclare(ExchangeName, ExchangeType.Direct, durable: true, autoDelete: false, arguments: null);</span><br><span class="line">                    channel.QueueDeclare(QueueName, durable: true, autoDelete: false, exclusive: false, arguments: null);</span><br><span class="line">                    channel.QueueBind(QueueName, ExchangeName, routingKey: QueueName);</span><br><span class="line">                    while (true)</span><br><span class="line">                    &#123;</span><br><span class="line">                        BasicGetResult msgResponse &#x3D; channel.BasicGet(QueueName, true);</span><br><span class="line">                        if (msgResponse !&#x3D; null)</span><br><span class="line">                        &#123;</span><br><span class="line">                            var msgBody &#x3D; Encoding.UTF8.GetString(msgResponse.Body);</span><br><span class="line">                            Console.WriteLine(string.Format(&quot;***接收时间:&#123;0&#125;，消息内容：&#123;1&#125;&quot;, DateTime.Now.ToString(&quot;yyyy-MM-dd HH:mm:ss&quot;), msgBody));</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        System.Threading.Thread.Sleep(TimeSpan.FromSeconds(1));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">        &#x2F;&#x2F;&#x2F; 基于事件的，当消息到达时触发事件，获取数据</span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">        public static void DirectAcceptExchangeEvent()</span><br><span class="line">        &#123;</span><br><span class="line">            using (IConnection conn &#x3D; rabbitMqFactory.CreateConnection())</span><br><span class="line">            &#123;</span><br><span class="line">                using (IModel channel &#x3D; conn.CreateModel())</span><br><span class="line">                &#123;</span><br><span class="line">                    &#x2F;&#x2F;channel.ExchangeDeclare(ExchangeName, &quot;direct&quot;, durable: true, autoDelete: false, arguments: null);</span><br><span class="line">                    channel.QueueDeclare(QueueName, durable: true, autoDelete: false, exclusive: false, arguments: null);</span><br><span class="line">                    &#x2F;&#x2F;channel.QueueBind(QueueName, ExchangeName, routingKey: QueueName);</span><br><span class="line">                    var consumer &#x3D; new EventingBasicConsumer(channel);</span><br><span class="line">                    consumer.Received +&#x3D; (model, ea) &#x3D;&gt;</span><br><span class="line">                    &#123;</span><br><span class="line">                        var msgBody &#x3D; Encoding.UTF8.GetString(ea.Body);</span><br><span class="line">                        Console.WriteLine(string.Format(&quot;***接收时间:&#123;0&#125;，消息内容：&#123;1&#125;&quot;, DateTime.Now.ToString(&quot;yyyy-MM-dd HH:mm:ss&quot;), msgBody));</span><br><span class="line">                    &#125;;</span><br><span class="line">                    channel.BasicConsume(QueueName,  true, consumer: consumer);</span><br><span class="line">                    Console.WriteLine(&quot;按任意值，退出程序&quot;);</span><br><span class="line">                    Console.ReadKey();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">        &#x2F;&#x2F;&#x2F; 基于事件的，当消息到达时触发事件，获取数据</span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">        public static void DirectAcceptExchangeTask()</span><br><span class="line">        &#123;</span><br><span class="line">            using (IConnection conn &#x3D; rabbitMqFactory.CreateConnection())</span><br><span class="line">            &#123;</span><br><span class="line">                using (IModel channel &#x3D; conn.CreateModel())</span><br><span class="line">                &#123;</span><br><span class="line">                    &#x2F;&#x2F;channel.ExchangeDeclare(ExchangeName, &quot;direct&quot;, durable: true, autoDelete: false, arguments: null);</span><br><span class="line">                    channel.QueueDeclare(QueueName, durable: true, autoDelete: false, exclusive: false, arguments: null);</span><br><span class="line">                    channel.BasicQos(prefetchSize: 0, prefetchCount: 1, global: false);&#x2F;&#x2F;告诉broker同一时间只处理一个消息</span><br><span class="line">                    &#x2F;&#x2F;channel.QueueBind(QueueName, ExchangeName, routingKey: QueueName);</span><br><span class="line">                    var consumer &#x3D; new EventingBasicConsumer(channel);</span><br><span class="line">                    consumer.Received +&#x3D; (model, ea) &#x3D;&gt;</span><br><span class="line">                    &#123;</span><br><span class="line">                        var msgBody &#x3D; Encoding.UTF8.GetString(ea.Body);</span><br><span class="line">                        Console.WriteLine(string.Format(&quot;***接收时间:&#123;0&#125;，消息内容：&#123;1&#125;&quot;, DateTime.Now.ToString(&quot;yyyy-MM-dd HH:mm:ss&quot;), msgBody));</span><br><span class="line">                        int dots &#x3D; msgBody.Split(&#39;.&#39;).Length - 1;</span><br><span class="line">                        System.Threading.Thread.Sleep(dots * 1000);</span><br><span class="line">                        &#x2F;&#x2F;处理完成，告诉Broker可以服务端可以删除消息，分配新的消息过来</span><br><span class="line">                        channel.BasicAck(deliveryTag: ea.DeliveryTag, multiple: false);</span><br><span class="line">                    &#125;;</span><br><span class="line">                    &#x2F;&#x2F;noAck设置false,告诉broker，发送消息之后，消息暂时不要删除，等消费者处理完成再说</span><br><span class="line">                    channel.BasicConsume(QueueName, false, consumer: consumer);</span><br><span class="line"></span><br><span class="line">                    Console.WriteLine(&quot;按任意值，退出程序&quot;);</span><br><span class="line">                    Console.ReadKey();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">        &#x2F;&#x2F;&#x2F; topic 模糊匹配模式，符号“#”匹配一个或多个词，符号“*”匹配不多不少一个词。因此“log.#”能够匹配到“log.info.oa”，但是“log.*” 只会匹配到“log.error”</span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">        public static void TopicAcceptExchange()</span><br><span class="line">        &#123;</span><br><span class="line">            using (IConnection conn &#x3D; rabbitMqFactory.CreateConnection())</span><br><span class="line">            &#123;</span><br><span class="line">                using (IModel channel &#x3D; conn.CreateModel())</span><br><span class="line">                &#123;</span><br><span class="line">                    channel.ExchangeDeclare(TopExchangeName, ExchangeType.Topic, durable: false, autoDelete: false, arguments: null);</span><br><span class="line">                    channel.QueueDeclare(TopQueueName, durable: false, autoDelete: false, exclusive: false, arguments: null);</span><br><span class="line">                    channel.BasicQos(prefetchSize: 0, prefetchCount: 1, global: false);</span><br><span class="line">                    channel.QueueBind(TopQueueName, TopExchangeName, routingKey: TopQueueName);</span><br><span class="line">                    var consumer &#x3D; new EventingBasicConsumer(channel);</span><br><span class="line">                    consumer.Received +&#x3D; (model, ea) &#x3D;&gt;</span><br><span class="line">                    &#123;</span><br><span class="line">                        var msgBody &#x3D; Encoding.UTF8.GetString(ea.Body);</span><br><span class="line">                        Console.WriteLine(string.Format(&quot;***接收时间:&#123;0&#125;，消息内容：&#123;1&#125;&quot;, DateTime.Now.ToString(&quot;yyyy-MM-dd HH:mm:ss&quot;), msgBody));</span><br><span class="line">                        int dots &#x3D; msgBody.Split(&#39;.&#39;).Length - 1;</span><br><span class="line">                        System.Threading.Thread.Sleep(dots * 1000);</span><br><span class="line">                        Console.WriteLine(&quot; [x] Done&quot;);</span><br><span class="line">                        channel.BasicAck(deliveryTag: ea.DeliveryTag, multiple: false);</span><br><span class="line">                    &#125;;</span><br><span class="line">                    channel.BasicConsume(TopQueueName,  false, consumer: consumer);</span><br><span class="line"></span><br><span class="line">                    Console.WriteLine(&quot;按任意值，退出程序&quot;);</span><br><span class="line">                    Console.ReadKey();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>消费者端也是两个路由两个队列，在实现DirectExchange时使用了三种方式，DirectAcceptExchange是基于时间轮询的，每隔一段时间获取一次，DirectAcceptExchangeEvent、DirectAcceptExchangeTask是基于事件的，当消息到达时触发事件，获取数据。</p><ul><li>4.实验截图</li></ul><p><a href="/images/300118-20190410143036954-1707654243.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/300118-20190410143036954-1707654243.png" class="lazyload"></a></p><p>参考原文地址(感谢分享)：</p><p><a href="https://www.cnblogs.com/5ishare/p/6784149.html" target="_blank" rel="noopener">https://www.cnblogs.com/5ishare/p/6784149.html</a></p><p><a href="http://www.cnblogs.com/xibei666/p/5931267.html#3680686" target="_blank" rel="noopener">http://www.cnblogs.com/xibei666/p/5931267.html#3680686</a></p>]]></content>
      
      
      <categories>
          
          <category> RabbitMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> RabbitMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 的基本用法</title>
      <link href="/2020/01/19/Hexo%20%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/"/>
      <url>/2020/01/19/Hexo%20%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure></div><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure></div><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure></div><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure></div><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a><br>More info: <a href="https://jerryc.me/posts/21cfbf15/" target="_blank" rel="noopener">hexo-theme-butterfly安装文档</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MongoDB与Redis的区别</title>
      <link href="/2020/01/16/MongoDB%E4%B8%8ERedis%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2020/01/16/MongoDB%E4%B8%8ERedis%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>MongoDB 更类似 MySQL，支持字段索引、游标操作，其优势在于查询功能比较强大，擅长查询 JSON 数据，能存储海量数据，但是不支持事务。</p><p>Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，支持多种类型的数据结构，可用作数据库，高速缓存和消息队列代理。</p><h2 id="MongoDB和Redis的区别是什么"><a href="#MongoDB和Redis的区别是什么" class="headerlink" title="MongoDB和Redis的区别是什么"></a>MongoDB和Redis的区别是什么</h2><ol><li><p>内存管理机制</p><p>Redis 数据全部存在内存，定期写入磁盘，当内存不够时，可以选择指定的 LRU 算法删除数据。</p><p>MongoDB 数据存在内存，由 linux系统 mmap 实现，当内存不够时，只将热点数据放入内存，其他数据存在磁盘。</p></li><li><p>支持的数据结构</p><p>Redis 支持的数据结构丰富，包括hash、set、list等。</p><p>MongoDB 数据结构比较单一，但是支持丰富的数据表达，索引，最类似关系型数据库，支持的查询语言非常丰富。</p></li><li><p>数据量和性能：</p><p>当物理内存够用的时候，redis&gt;mongodb&gt;mysql</p><p>当物理内存不够用的时候，redis和mongodb都会使用虚拟内存。</p><p>实际上如果redis要开始虚拟内存，那很明显要么加内存条，要么你换个数据库了。</p><p>但是，mongodb不一样，只要，业务上能保证，冷热数据的读写比，使得热数据在物理内存中，mmap的交换较少。</p><p>mongodb还是能够保证性能。</p></li><li><p>性能</p><p>mongodb依赖内存，TPS较高；Redis依赖内存，TPS非常高。性能上Redis优于MongoDB。</p></li><li><p>可靠性</p><p>mongodb从1.8版本后，采用binlog方式（MySQL同样采用该方式）支持持久化，增加可靠性；</p><p>Redis依赖快照进行持久化；AOF增强可靠性；增强可靠性的同时，影响访问性能。</p><p>可靠性上MongoDB优于Redis。</p></li><li><p>数据分析</p><p>mongodb内置数据分析功能（mapreduce）；而Redis不支持。</p></li><li><p>事务支持情况</p><p>Redis 事务支持比较弱，只能保证事务中的每个操作连续执行；mongodb不支持事务。</p></li><li><p>集群</p><p>MongoDB 集群技术比较成熟，Redis从3.0开始支持集群。</p><p>相关视频教程推荐：《<a href="http://www.php.cn/course/list/53.html" target="_blank" rel="noopener">MongoDB教程</a>》、《<a href="http://www.php.cn/course/list/54.html" target="_blank" rel="noopener">Redis教程</a>》</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> MongoDB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MongoDB </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker基本命令</title>
      <link href="/2020/01/15/Docker%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
      <url>/2020/01/15/Docker%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="镜像相关命令"><a href="#镜像相关命令" class="headerlink" title="镜像相关命令"></a>镜像相关命令</h2><h3 id="搜索镜像"><a href="#搜索镜像" class="headerlink" title="搜索镜像"></a>搜索镜像</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">$ docker search whalesay</span><br><span class="line">INDEX       NAME                                      DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED</span><br><span class="line">docker.io   docker.io&#x2F;docker&#x2F;whalesay                 An image for use in the Docker demo tutorial    637</span><br><span class="line">docker.io   docker.io&#x2F;mendlik&#x2F;docker-whalesay         Docker whalesay image from training materi...   7                    [OK]</span><br><span class="line">docker.io   docker.io&#x2F;caibar&#x2F;whalesay                 Builds automatizados.                           1                    [OK]</span><br><span class="line">docker.io   docker.io&#x2F;milanfort&#x2F;whalesay              Modified docker&#x2F;whalesay image that output...   1</span><br><span class="line">docker.io   docker.io&#x2F;nikovirtala&#x2F;whalesay            Tiny Go web service to print Moby Dock ASC...   1                    [OK]</span><br><span class="line">docker.io   docker.io&#x2F;ojenge&#x2F;whalesay                 from docker&#x2F;whalesay                            1</span><br><span class="line">docker.io   docker.io&#x2F;sabs1117&#x2F;whalesay               Whalesay with fortune phrases.                  1</span><br><span class="line">docker.io   docker.io&#x2F;swinton&#x2F;whalesay                whalesay, innit                                 1</span><br><span class="line">docker.io   docker.io&#x2F;asakilan&#x2F;pg-whalesay            My whalesay                                     0</span><br><span class="line">docker.io   docker.io&#x2F;blaines&#x2F;whalesay                                                                0</span><br><span class="line">docker.io   docker.io&#x2F;claytonrogers&#x2F;docker-whalesay   Whalesay automated build                        0                    [OK]</span><br><span class="line">docker.io   docker.io&#x2F;dhalljohnston&#x2F;whalesay          whalesay                                        0</span><br><span class="line">docker.io   docker.io&#x2F;dockeramiller&#x2F;whalesay          Modified version of the official docker&#x2F;wh...   0                    [OK]</span><br><span class="line">docker.io   docker.io&#x2F;firecyberice&#x2F;whalesay           Docker **Cloud** automated build for **amd...   0</span><br><span class="line">docker.io   docker.io&#x2F;forsingh&#x2F;whalesay               whalesay                                        0                    [OK]</span><br><span class="line">docker.io   docker.io&#x2F;hongxi&#x2F;whalesay-fortunes        Demo, the whalesay-fortunes                     0</span><br><span class="line">docker.io   docker.io&#x2F;jracionero&#x2F;docker-whalesay      My smarter docker whalesay                      0</span><br><span class="line">docker.io   docker.io&#x2F;liuzhishan&#x2F;docker-whalesay      docker-whalesay                                 0</span><br><span class="line">docker.io   docker.io&#x2F;ox0spy&#x2F;whalesay-fortune         like docker&#x2F;whalesay, just using fortunes ...   0</span><br><span class="line">docker.io   docker.io&#x2F;phyominhtun&#x2F;whalesay            First WhaleSay Test                             0</span><br><span class="line">docker.io   docker.io&#x2F;puneethp&#x2F;whalesay               Docker-Whalesay                                 0</span><br><span class="line">docker.io   docker.io&#x2F;stealthizer&#x2F;rpi-whalesay        https:&#x2F;&#x2F;github.com&#x2F;stealthizer&#x2F;rpi-whalesay     0</span><br><span class="line">docker.io   docker.io&#x2F;tiagoferreira&#x2F;whalesay          Whalesay image                                  0</span><br><span class="line">docker.io   docker.io&#x2F;whalebrew&#x2F;whalesay                                                              0</span><br><span class="line">docker.io   docker.io&#x2F;yang225217&#x2F;whalesay                                                             0</span><br></pre></td></tr></table></figure></div><blockquote><p>使用docker search 命令可以搜索远端仓库中的共享镜像，默认搜索官方仓库DockerHub中的镜像。</p><p>用法为docker search TERM，支持的参数主要包括：</p><p>– automated = true|false：仅显示自动创建的镜像，默认为否；</p><p>– no-trunc = true|false：输出信息不截断显示，默认为否；</p><p>– s –stars=X：指定仅显示评价为指定星级以上的镜像，默认为0，即输出所有镜像。</p></blockquote><p>可以看到返回了很多包含关键字的镜像，其中包括像名字、描述、星级（表示该镜像受欢迎程度）、是否官方创建、是否自动创建等。</p><p>默认的输出将按照星级评价进行排序。</p><p>现在我们搜索的一个鲸鱼说话的镜像。</p><h3 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull docker&#x2F;whalesay</span><br><span class="line">Using default tag: latest</span><br></pre></td></tr></table></figure></div><p>docker pull NAME[:TAG]</p><p>docker pull 命令直接从DockerHub镜像源来下载镜像。其中NAME是镜像仓库的名称（用来区分镜像），TAG是镜像的标签（表示版本信息）。通常情况下，描述一个镜像需要包括“名称 + 标签”信息。</p><p>因为我们命令中并没有指定TAG标签，则默认会选择latest标签，这会下载仓库中最新的镜像。</p><h3 id="拉取镜像-1"><a href="#拉取镜像-1" class="headerlink" title="拉取镜像"></a>拉取镜像</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull docker&#x2F;whalesay</span><br><span class="line">Using default tag: latest</span><br></pre></td></tr></table></figure></div><p>docker pull NAME[:TAG]</p><p>docker pull 命令直接从DockerHub镜像源来下载镜像。其中NAME是镜像仓库的名称（用来区分镜像），TAG是镜像的标签（表示版本信息）。通常情况下，描述一个镜像需要包括“名称 + 标签”信息。</p><p>因为我们命令中并没有指定TAG标签，则默认会选择latest标签，这会下载仓库中最新的镜像。</p><h3 id="查看镜像"><a href="#查看镜像" class="headerlink" title="查看镜像"></a>查看镜像</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">docker&#x2F;whalesay     latest              6b362a9f73eb        3 years ago         247MB</span><br></pre></td></tr></table></figure></div><p>使用docker images命令可以列出本地主机上已有的镜像的基本信息。</p><p>在列出的信息种，可以看到以下几个字段信息</p><p>REPOSITORY：来自于哪个仓库。</p><p>TAG：镜像的标签信息。</p><p>IMAGE ID：镜像的ID（唯一标识镜像）</p><p>CREATED：创建时间。说明镜像的最后更新时间。</p><p>SIZE：镜像大小，优秀的镜像往往体积较小。</p><p>其中镜像的ID信息十分重要，它唯一标识了镜像。在使用镜像ID的时候，一般可以使用该ID的前若干字符组成的可区分串来代替完整的ID。镜像大小信息只是表示该镜像的逻辑体积大小，实际上由于相同的镜像层本地只会存储一份，物理上占用的存储空间会小于各镜像的逻辑体积之和。</p><p>如果需要查看docker images更多命令可以通过man docker-images来查看。</p><h3 id="运行镜像"><a href="#运行镜像" class="headerlink" title="运行镜像"></a>运行镜像</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ docker run docker&#x2F;whalesay cowsay hellow docker</span><br><span class="line"> _______________</span><br><span class="line">&lt; hellow docker &gt;</span><br><span class="line"> ---------------</span><br><span class="line">    \</span><br><span class="line">     \</span><br><span class="line">      \</span><br><span class="line">                    ##        .</span><br><span class="line">              ## ## ##       &#x3D;&#x3D;</span><br><span class="line">           ## ## ## ##      &#x3D;&#x3D;&#x3D;</span><br><span class="line">       &#x2F;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;___&#x2F; &#x3D;&#x3D;&#x3D;</span><br><span class="line">  ~~~ &#123;~~ ~~~~ ~~~ ~~~~ ~~ ~ &#x2F;  &#x3D;&#x3D;&#x3D;- ~~~</span><br><span class="line">       \______ o          __&#x2F;</span><br><span class="line">        \    \        __&#x2F;</span><br><span class="line">          \____\______&#x2F;</span><br></pre></td></tr></table></figure></div><p>docker run 就是运行命令。</p><p>docker/whalesay 是要运行的镜像名称</p><p>cowsay 是要输出的话，例如我们输出了hellow docker</p><h3 id="上传镜像"><a href="#上传镜像" class="headerlink" title="上传镜像"></a>上传镜像</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ docker tag docker&#x2F;whalesay gzq2333&#x2F;whalesay</span><br><span class="line"></span><br><span class="line">$ docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">gzq2333&#x2F;whalesay    latest              6b362a9f73eb        3 years ago         247MB</span><br><span class="line">docker&#x2F;whalesay     latest              6b362a9f73eb        3 years ago         247MB</span><br><span class="line"></span><br><span class="line">$ docker push gzq2333&#x2F;whalesay</span><br><span class="line">The push refers to repository [docker.io&#x2F;gzq2333&#x2F;whalesay]</span><br><span class="line">5f70bf18a086: Pushed</span><br><span class="line">d061ee1340ec: Pushed</span><br><span class="line">d511ed9e12e1: Pushed</span><br><span class="line">091abc5148e4: Pushed</span><br><span class="line">b26122d57afa: Pushed</span><br><span class="line">37ee47034d9b: Pushed</span><br><span class="line">528c8710fd95: Pushed</span><br><span class="line">1154ba695078: Pushed</span><br><span class="line">latest: digest: sha256:df326a383b4a036fd5a33402248027d1c972954622924158a28744ed5f9fca1e size: 2402</span><br></pre></td></tr></table></figure></div><p>使用docker push命令可以上传镜像到仓库，默认上传到DockerHub官方仓库（需要登录）</p><p>用户在DockerHub网站注册后可以上传自制镜像。例如用户gzq2333上传本地whalesay镜像，可以先添加新的标签：gzq2333/whalesay，然后用docker push 命令上镜像。</p><p>这里需要重点提示一下，在添加新标签 gzq2333/whalesay 的时候，gzq2333这个一定要是DockerHub存在的用户ID，否则会出现以下提示：denied: requested access to the resource is denied。</p><p>第一次上传时需要登录。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker login</span><br><span class="line">Username:</span><br><span class="line">Password:</span><br><span class="line">Login Succeeded</span><br></pre></td></tr></table></figure></div><blockquote><p>最好不要使用邮箱登录（因为邮箱和Docker ID是两个分离的东西，我们可以使用邮箱登录Docker Web，但是不能登录客户端，如果两者都使用Docker ID登录，那么就OK了）</p></blockquote><h3 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker rmi 6b362a9f73eb</span><br></pre></td></tr></table></figure></div><p>当使用docker rmi命令，并且后面跟上镜像的ID，也可以根据镜像名称删除。</p><blockquote><p>注意，当有该镜像创建容器存在时，镜像文件默认是无法被删除的。如果需要强行删除镜像，可以使用-f参数</p></blockquote><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker rmi -f 6b362a9f73eb</span><br><span class="line">Untagged: docker&#x2F;whalesay:latest</span><br><span class="line">Untagged: docker&#x2F;whalesay@sha256:178598e51a26abbc958b8a2e48825c90bc22e641de3d31e18aaf55f3258ba93b</span><br><span class="line">Deleted: sha256:6b362a9f73eb8c33b48c95f4fcce1b6637fc25646728cf7fb0679b2da273c3f4</span><br></pre></td></tr></table></figure></div><blockquote><p>注意，通常并不推荐使用-f参数来强制删除一个存在容器依赖的镜像。正确的做法是先删除依赖的镜像的所有容器，再来删除镜像。</p></blockquote><h2 id="容器相关命令"><a href="#容器相关命令" class="headerlink" title="容器相关命令"></a>容器相关命令</h2><p>这里我就重新在DockerHub官网下载一个tomcat的镜像来做演示。</p><h3 id="创建容器"><a href="#创建容器" class="headerlink" title="创建容器"></a>创建容器</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull tomcat</span><br><span class="line">Using default tag: latest</span><br><span class="line">latest: Pulling from library&#x2F;tomcat</span><br><span class="line">05d1a5232b46: Downloading [&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;                         ]     23MB&#x2F;45.31MB</span><br><span class="line">5cee356eda6b: Download complete</span><br><span class="line">05d1a5232b46: Pull complete</span><br><span class="line">5cee356eda6b: Pull complete</span><br><span class="line">89d3385f0fd3: Pull complete</span><br><span class="line">65dd87f6620b: Pull complete</span><br><span class="line">78a183a01190: Pull complete</span><br><span class="line">1a4499c85f97: Pull complete</span><br><span class="line">2c9d39b4bfc1: Pull complete</span><br><span class="line">1b1cec2222c9: Pull complete</span><br><span class="line">fc95b85a81f3: Pull complete</span><br><span class="line">0f3868647539: Pull complete</span><br><span class="line">9b6a6eddb2d9: Pull complete</span><br><span class="line">8787183cb077: Pull complete</span><br><span class="line">Digest: sha256:8d120de5102cc12310de741299e9bf6f39d2d674663f2ce4e6f0f181ccfeebe7</span><br><span class="line">Status: Downloaded newer image for tomcat:latest</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">tomcat              latest              41a54fe1f79d        11 days ago         463MB</span><br><span class="line"></span><br><span class="line">$ docker run -d -p 8081:8080 tomcat</span><br><span class="line">eb0fdb6960ce362f4ec20de40f73d6c64c0c6dd0c5dc1c1818444f7239f54a02</span><br></pre></td></tr></table></figure></div><p>首先我用docker pull 从DockerHub官网下载了一个Tomcat镜像。然后docker images查看镜像信息。在通过这个docker run运行镜像命令生成了一个容器。</p><p>docker run：运行镜像命令</p><p>-d：后台运行</p><p>-p 8081:8080：端口映射，把宿主机上的8081端口映射到了容器内Tomcat的8080端口上面了。</p><p>tomcat：镜像名称</p><p>然后输入这个网址：<a href="http://127.0.0.1:8081/" target="_blank" rel="noopener">http://127.0.0.1:8081/</a> </p><p><a href="/images/92de853bb858c83b03d7348f70c6dbda974.jpg" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/92de853bb858c83b03d7348f70c6dbda974.jpg" class="lazyload"></a></p><p>那么意味着这个tomcat的容器启动成功。</p><h3 id="查看容器"><a href="#查看容器" class="headerlink" title="查看容器"></a>查看容器</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS                    NAMES</span><br><span class="line">eb0fdb6960ce        tomcat              &quot;catalina.sh run&quot;   5 seconds ago       Up 4 seconds        0.0.0.0:8081-&gt;8080&#x2F;tcp   focused_newton</span><br></pre></td></tr></table></figure></div><p>这里就是容器的基本信息。</p><p>CONTAINER ID：容器ID，唯一标识。</p><p>IMAGE：生成容器的镜像名称。</p><p>COMMAND：命令。</p><p>CREATED：创建时间，最后更新时间。</p><p>STATUS：状态。</p><p>PORTS：请求端口信息。</p><p>NAMES：容器名称。</p><h3 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h3><p>在使用-d参数时，容器启动后会在后台运行，用户无法看到容器中的信息，也无法进行操作。这个时候如果需要进入容器操作，有很多种方法，包括使用官方的attach或者exec命令。以及第三方nsenter工具等。</p><h4 id="attach命令"><a href="#attach命令" class="headerlink" title="attach命令"></a>attach命令</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker attach focused_newton</span><br></pre></td></tr></table></figure></div><p>当docker容器在 “-d”守护态运行的时候，比如通过supervisord控制两个程序非守护态运行：ssh -d tomcat<br>那么这个时候，用户就无法直接进入到容器中去，docker attach容器ID就会一直卡着。<br>因为此时容器运行的进程是ssh，而不是/bin/bash 也没有虚拟终端（-it）参数，所以是进入不到的。</p><h4 id="exec命令"><a href="#exec命令" class="headerlink" title="exec命令"></a>exec命令</h4><p>Docker从1.3版本提供了一个exec命令，可以在容器内直接执行任意命令。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker exec -it eb0fdb6960ce &#x2F;bin&#x2F;bash</span><br><span class="line">root@eb0fdb6960ce:&#x2F;usr&#x2F;local&#x2F;tomcat#</span><br></pre></td></tr></table></figure></div><p>-i， –interactive = true|false：打开标准输入接受用户输入命令，默认false;</p><p>–privileged = true|false： 是否给执行命令以最高权限，默认为false;</p><p>-t –tty = true|false： 分配伪终端，默认false；</p><p>-u –user=””： 执行命令的用户或ID</p><p>可以看到，一个bash终端打开了，在不影响容器内其他应用的前提下，用户可以很容易与容器进行交互。</p><h3 id="容器终止，启动，重启命令"><a href="#容器终止，启动，重启命令" class="headerlink" title="容器终止，启动，重启命令"></a>容器终止，启动，重启命令</h3><ol><li>docker stop命令用于终止一个运行中的容器，容器终止，里面的应用也就结束了：</li></ol><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker stop eb0fdb6960ce</span><br><span class="line">eb0fdb6960ce</span><br></pre></td></tr></table></figure></div><ol start="2"><li>我们可以通过docker ps -qa 来查看终止的容器：</li></ol><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps -qa</span><br><span class="line">eb0fdb6960ce</span><br></pre></td></tr></table></figure></div><ol start="3"><li>处于终止的容器，可以通过docker start 命令来重新启动：</li></ol><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker start eb0fdb6960ce</span><br><span class="line">eb0fdb6960ce</span><br></pre></td></tr></table></figure></div><ol start="4"><li>docker restart 命令会将一个运行状态的容器先终止，然后再重新启动它：</li></ol><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker restart eb0fdb6960ce</span><br><span class="line">eb0fdb6960ce</span><br></pre></td></tr></table></figure></div><h3 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker rm eb0fdb6960ce</span><br></pre></td></tr></table></figure></div><p>docker rm命令来删除处于终止或退出状态的容器，并不能删除正在运行状态的容器。</p><p>如果直接删除一个运行中的容器，可以添加-f参数。docker会先发送sigkill信号给容器，终止其中的应用，之后强行删除。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker rm -f eb0fdb6960ce</span><br><span class="line">eb0fdb6960ce</span><br></pre></td></tr></table></figure></div><blockquote><p>注意，删除容器的话，容器里面应用的产生的数据和日志信息等全都会被删除销毁，所以建议把应用里面的日子和产生的数据挂载到宿主机上。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安装Ranchar服务</title>
      <link href="/2020/01/15/%E5%AE%89%E8%A3%85Ranchar%E6%9C%8D%E5%8A%A1/"/>
      <url>/2020/01/15/%E5%AE%89%E8%A3%85Ranchar%E6%9C%8D%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="确认Docker的版本，下面是Centos的输出"><a href="#确认Docker的版本，下面是Centos的输出" class="headerlink" title="确认Docker的版本，下面是Centos的输出"></a>确认Docker的版本，下面是Centos的输出</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker version</span><br><span class="line">Client:</span><br><span class="line"> Version:         1.13.1</span><br><span class="line"> API version:     1.26</span><br><span class="line"> Package version: docker-1.13.1-74.git6e3bb8e.el7.centos.x86_64</span><br><span class="line"> Go version:      go1.9.4</span><br><span class="line"> Git commit:      6e3bb8e&#x2F;1.13.1</span><br><span class="line"> Built:           Tue Aug 21 15:23:37 2018</span><br><span class="line"> OS&#x2F;Arch:         linux&#x2F;amd64</span><br><span class="line"></span><br><span class="line">Server:</span><br><span class="line"> Version:         1.13.1</span><br><span class="line"> API version:     1.26 (minimum version 1.12)</span><br><span class="line"> Package version: docker-1.13.1-74.git6e3bb8e.el7.centos.x86_64</span><br><span class="line"> Go version:      go1.9.4</span><br><span class="line"> Git commit:      6e3bb8e&#x2F;1.13.1</span><br><span class="line"> Built:           Tue Aug 21 15:23:37 2018</span><br><span class="line"> OS&#x2F;Arch:         linux&#x2F;amd64</span><br><span class="line"> Experimental:    false</span><br></pre></td></tr></table></figure></div><h2 id="确认Docker服务已经启动"><a href="#确认Docker服务已经启动" class="headerlink" title="确认Docker服务已经启动"></a>确认Docker服务已经启动</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ sudo service docker status</span><br><span class="line">Redirecting to &#x2F;bin&#x2F;systemctl status docker.service</span><br><span class="line">● docker.service - Docker Application Container Engine</span><br><span class="line">   Loaded: loaded (&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;docker.service; enabled; vendor preset: disabled)</span><br><span class="line">   Active: active (running) since 三 2018-09-12 14:52:09 CST; 2 weeks 0 days ago</span><br><span class="line">     Docs: http:&#x2F;&#x2F;docs.docker.com</span><br><span class="line"> Main PID: 3981 (dockerd-current)</span><br><span class="line">    Tasks: 37</span><br><span class="line">   Memory: 136.1M</span><br><span class="line">   CGroup: &#x2F;system.slice&#x2F;docker.service</span><br><span class="line">           ├─3981 &#x2F;usr&#x2F;bin&#x2F;dockerd-current --add-runtime docker-runc&#x3D;&#x2F;usr&#x2F;libexec&#x2F;docker&#x2F;docker-runc-current --default-runtime&#x3D;docker-runc --exec-opt native.cgroupdriver...</span><br><span class="line">           └─3986 &#x2F;usr&#x2F;bin&#x2F;docker-containerd-current -l unix:&#x2F;&#x2F;&#x2F;var&#x2F;run&#x2F;docker&#x2F;libcontainerd&#x2F;docker-containerd.sock --metrics-interval&#x3D;0 --start-timeout 2m --state-dir &#x2F;...</span><br></pre></td></tr></table></figure></div><p>使用 sudo docker status 观察Docker服务是否有启动，如果没有启动请输入 service docker start 启动。然后再次查看，看到状态是 running 了就是正常启动了。</p><h2 id="启动Rancher服务器"><a href="#启动Rancher服务器" class="headerlink" title="启动Rancher服务器"></a>启动Rancher服务器</h2><p>Rancher服务器是一个docker image，所以其软件本身不需要安装，只需要执行Docker命令下载并且成功运行Docker服务器镜像即可。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d --restart&#x3D;always -p 8080:8080 rancher&#x2F;server</span><br><span class="line">Unable to find image &#39;rancher&#x2F;server:latest&#39; locally</span><br><span class="line">Trying to pull repository docker.io&#x2F;rancher&#x2F;server ...</span><br><span class="line">latest: Pulling from docker.io&#x2F;rancher&#x2F;server</span><br><span class="line">bae382666908: Pull complete</span><br><span class="line">29ede3c02ff2: Pull complete</span><br><span class="line">da4e69f33106: Pull complete</span><br><span class="line">8d43e5f5d27f: Pull complete</span><br><span class="line">b0de1abb17d6: Pull complete</span><br><span class="line">422f47db4517: Pull complete</span><br><span class="line">79d37de643ce: Pull complete</span><br><span class="line">69d13e08a4fe: Pull complete</span><br><span class="line">2ddfd3c6a2b7: Pull complete</span><br><span class="line">bc433fed3823: Pull complete</span><br><span class="line">b82e188df556: Pull complete</span><br><span class="line">dae2802428a4: Pull complete</span><br><span class="line">c9b17cca6fc4: Pull complete</span><br><span class="line">41cc2c1ffe8c: Pull complete</span><br><span class="line">ae49123ce3ae: Pull complete</span><br><span class="line">2fe8cae58437: Pull complete</span><br><span class="line">ab963aad4fc2: Pull complete</span><br><span class="line">2dd932ceaa80: Pull complete</span><br><span class="line">71ff5e84e401: Pull complete</span><br><span class="line">0be35ae80349: Pull complete</span><br><span class="line">ae4f98e342e9: Pull complete</span><br><span class="line">Digest: sha256:cbe7d290460dfa83981d02506ff2588fdb3d5d988641c630c6f10bb7211fbfc6</span><br><span class="line">Status: Downloaded newer image for docker.io&#x2F;rancher&#x2F;server:latest</span><br><span class="line">7bd557d38e6db8168ad78efdd953862ac7a5b2cad225cc6611eade05fc77cb17</span><br></pre></td></tr></table></figure></div><p><strong>命令行参数解释：</strong></p><blockquote><p>docker run  -d： 参数标示在后台运行。 </p><p>–restart=always： 容器如果异常停止自动重启。</p><p>-p 8080：8080 把Rancher服务器的UI对外服务（容器内）的端口8080 ，绑定到到宿主机的8080 端口。后面跟的镜像名rancher/server，Docker会首先检查本地有没有这个镜像，如果没有Docker会去 DockerHub将这个镜像下载下来并且启动。</p></blockquote><h2 id="检查是否成功正确下载了Rancher-Server镜像"><a href="#检查是否成功正确下载了Rancher-Server镜像" class="headerlink" title="检查是否成功正确下载了Rancher Server镜像"></a>检查是否成功正确下载了Rancher Server镜像</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker images</span><br><span class="line">REPOSITORY                 TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">docker.io&#x2F;rancher&#x2F;server   latest              a0b9e05b2a03        5 days ago          1.08 GB</span><br></pre></td></tr></table></figure></div><h2 id="检查Rancher服务器容器是否已经正常运行"><a href="#检查Rancher服务器容器是否已经正常运行" class="headerlink" title="检查Rancher服务器容器是否已经正常运行"></a>检查Rancher服务器容器是否已经正常运行</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps -a</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                              NAMES</span><br><span class="line">7bd557d38e6d        rancher&#x2F;server      &quot;&#x2F;usr&#x2F;bin&#x2F;entry &#x2F;u...&quot;   3 minutes ago       Up 3 minutes        3306&#x2F;tcp, 0.0.0.0:8080-&gt;8080&#x2F;tcp   pedantic_thompson</span><br></pre></td></tr></table></figure></div><p><a href="/images/2b6c9613c67a75351355b53839c2cd75236.jpg" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/2b6c9613c67a75351355b53839c2cd75236.jpg" class="lazyload"></a></p><p>现在容器已经正常启动了，可以访问容器里面的Rancher服务应用了。因为我使用的云服务器，云服务器外网IP119.29.28.186，所以我的访问Rancher访问地址：<a href="http://119.29.28.186:8080/" target="_blank" rel="noopener">http://119.29.28.186:8080/</a> </p><p>如果你是本机的话，那么你访问地址就是：<a href="http://127.0.0.1:8080/" target="_blank" rel="noopener">http://127.0.0.1:8080/</a></p><p>看到上面欢迎界面就代表我们的Rancher正常启动了。访问成功。</p><h2 id="Rancher服务配置"><a href="#Rancher服务配置" class="headerlink" title="Rancher服务配置"></a>Rancher服务配置</h2><p><a href="/images/8b6b818b3a71ad4d4f255dcb396dc3fc07d.jpg" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/8b6b818b3a71ad4d4f255dcb396dc3fc07d.jpg" class="lazyload"></a></p><p><a href="/images/13b6f4d42d6e58280c975b3d64dc4913904.jpg" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/13b6f4d42d6e58280c975b3d64dc4913904.jpg" class="lazyload"></a></p><p><a href="/images/41ded8101e9bd8879e641faa99694ae5394.jpg" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/41ded8101e9bd8879e641faa99694ae5394.jpg" class="lazyload"></a></p><p>现在已经把脚本拷贝到宿主机上执行了。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run --rm --privileged -v &#x2F;var&#x2F;run&#x2F;docker.sock:&#x2F;var&#x2F;run&#x2F;docker.sock -v &#x2F;var&#x2F;lib&#x2F;rancher:&#x2F;var&#x2F;lib&#x2F;rancher rancher&#x2F;agent:v1.2.11 http:&#x2F;&#x2F;119.29.28.186:8080&#x2F;v1&#x2F;scripts&#x2F;269D3023659EEBA600F1:1514678400000:D53MbhPItURIXwYMrpRIIpZP4</span><br><span class="line">Unable to find image &#39;rancher&#x2F;agent:v1.2.11&#39; locally</span><br><span class="line">Trying to pull repository docker.io&#x2F;rancher&#x2F;agent ...</span><br><span class="line">v1.2.11: Pulling from docker.io&#x2F;rancher&#x2F;agent</span><br><span class="line">b3e1c725a85f: Pull complete</span><br><span class="line">6a710864a9fc: Pull complete</span><br><span class="line">d0ac3b234321: Pull complete</span><br><span class="line">87f567b5cf58: Pull complete</span><br><span class="line">063e24b217c4: Pull complete</span><br><span class="line">d0a3f58caef0: Pull complete</span><br><span class="line">16914729cfd3: Pull complete</span><br><span class="line">bbad862633b9: Pull complete</span><br><span class="line">3cf9849d7f3c: Pull complete</span><br><span class="line">Digest: sha256:0fba3fb10108f7821596dc5ad4bfa30e93426d034cd3471f6ccd3afb5f87a963</span><br><span class="line">Status: Downloaded newer image for docker.io&#x2F;rancher&#x2F;agent:v1.2.11</span><br></pre></td></tr></table></figure></div><p>会自动下载Rancher Agent镜像并运行。等待下载完毕。</p><p>查看一下进程，多出一个 rancher/agent 的进程，并且已经运行。</p><p><a href="/images/362f68f48bd8c017c1a4298b03e1bd915b0.jpg" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/362f68f48bd8c017c1a4298b03e1bd915b0.jpg" class="lazyload"></a></p><p>可以看到已经多了一台活动主机（宿主机），上面运行一个 Rancher Server 容器，就是 Rancher 服务器自己。如果你有其他主机，也可以添加其他主机进来。</p><h2 id="账号密码配置"><a href="#账号密码配置" class="headerlink" title="账号密码配置"></a>账号密码配置</h2><p>我们现在看到系统管理旁边还是有一个红色感叹号，这时我们就要设置账号密码了。</p><p><a href="/images/b4d1ca3eb63270db04caad8ee839197cb11.jpg" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/b4d1ca3eb63270db04caad8ee839197cb11.jpg" class="lazyload"></a></p><p>然后在网页的最下面会有一个启用本地验证，然后我们点击启用就可以了。</p><p><a href="/images/f852af0d3d6ce108ac475f301f9c946e4dd.jpg" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/f852af0d3d6ce108ac475f301f9c946e4dd.jpg" class="lazyload"></a></p><p>这时候我们看到红色感叹号没有了，这里我可以退出网页，使用刚刚设置的账号密码重新登录</p><p>出处：<a href="https://my.oschina.net/piaoxianren/blog/2209271" target="_blank" rel="noopener">此处</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Ranchar </tag>
            
            <tag> Kubernetes </tag>
            
            <tag> K8s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pm2命令大全</title>
      <link href="/2020/01/15/pm2%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/"/>
      <url>/2020/01/15/pm2%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>以下是pm2常用的命令行</p><p>$ pm2 start app.js              # 启动app.js应用程序</p><p>$ pm2 start app.js -i 4         # cluster mode 模式启动4个app.js的应用实例     # 4个应用程序会自动进行负载均衡</p><p>$ pm2 start app.js –name=”api” # 启动应用程序并命名为 “api”</p><p>$ pm2 start app.js –watch      # 当文件变化时自动重启应用</p><p>$ pm2 start script.sh           # 启动 bash 脚本</p><p>$ pm2 list                      # 列表 PM2 启动的所有的应用程序</p><p>$ pm2 monit                     # 显示每个应用程序的CPU和内存占用情况</p><p>$ pm2 show [app-name]           # 显示应用程序的所有信息</p><p>$ pm2 logs                      # 显示所有应用程序的日志</p><p>$ pm2 logs [app-name]           # 显示指定应用程序的日志</p><p>$ pm2 flush</p><p>$ pm2 stop all                  # 停止所有的应用程序</p><p>$ pm2 stop 0                    # 停止 id为 0的指定应用程序</p><p>$ pm2 restart all               # 重启所有应用</p><p>$ pm2 reload all                # 重启 cluster mode下的所有应用</p><p>$ pm2 gracefulReload all        # Graceful reload all apps in cluster mode</p><p>$ pm2 delete all                # 关闭并删除所有应用</p><p>$ pm2 delete 0                  # 删除指定应用 id 0</p><p>$ pm2 scale api 10              # 把名字叫api的应用扩展到10个实例</p><p>$ pm2 reset [app-name]          # 重置重启数量</p><p>$ pm2 startup                   # 创建开机自启动命令</p><p>$ pm2 save                      # 保存当前应用列表</p><p>$ pm2 resurrect                 # 重新加载保存的应用列表</p><p>$ pm2 update                    # Save processes, kill PM2 and restore processes</p><p>$ pm2 generate                  # Generate a sample json configuration file</p><p>$ pm2 deploy app.json prod setup    # Setup “prod” remote server</p><p>$ pm2 deploy app.json prod          # Update “prod” remote server</p><p>$ pm2 deploy app.json prod revert 2 # Revert “prod” remote server by 2</p><p>$ pm2 module:generate [name]    # Generate sample module with name [name]</p><p>$ pm2 install pm2-logrotate     # Install module (here a log rotation system)</p><p>$ pm2 uninstall pm2-logrotate   # Uninstall module</p><p>$ pm2 publish                   # Increment version, git push and npm publish</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> pm2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker命令大全</title>
      <link href="/2020/01/15/Docker%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/"/>
      <url>/2020/01/15/Docker%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="/images/4933701-c9c04d73e0eae5fd.webp" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/4933701-c9c04d73e0eae5fd.webp" class="lazyload"></a></p><h2 id="参考治疗"><a href="#参考治疗" class="headerlink" title="参考治疗"></a>参考治疗</h2><ul><li>Docker文档 <a href="https://docs.docker.com" target="_blank" rel="noopener">https://docs.docker.com</a></li></ul><p>命令格式</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker &lt;选项&gt;&lt;命令&gt;&lt;参数&gt;</span><br></pre></td></tr></table></figure></div><p><a href="/images/4933701-d05019eb7130f65c.webp" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/4933701-d05019eb7130f65c.webp" class="lazyload"></a></p><p>选项说明</p><ul><li><font color="red">[]</font> 表示设置选项时可以设置不同的值，并且可以多次使用。</li><li><font color="red">=false</font>表示默认值为<font color="red">false</font></li><li><font color="red">=””</font>表示默认是为空</li></ul><p>帮助文档</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">$ docker --help</span><br><span class="line">                                                                                                                                   </span><br><span class="line">用法:  docker COMMAND                                                                                                             </span><br><span class="line">                                                                                                                                   </span><br><span class="line">A self-sufficient runtime for containers                                                                                           </span><br><span class="line">                                                                                                                                   </span><br><span class="line">选项:                                                                                                                           </span><br><span class="line">      --config string      Location of client config files (default                                                                </span><br><span class="line">                           &quot;C:\\Users\\junchow\\.docker&quot;)                                                                          </span><br><span class="line">  -D, --debug              开启debug模式</span><br><span class="line">  -H, --host list          Daemon socket(s) to connect to                                                                          </span><br><span class="line">  -l, --log-level string   设置日志级别，级别分为debug|info|warn|error|fatal，默认为info。                                                                             </span><br><span class="line">      --tls                Use TLS; implied by --tlsverify                                                                         </span><br><span class="line">      --tlscacert string   Trust certs signed only by this CA (default                                                             </span><br><span class="line">                           &quot;C:\\Users\\junchow\\.docker\\machine\\machines\\default\\ca.pem&quot;)                                      </span><br><span class="line">      --tlscert string     Path to TLS certificate file (default                                                                   </span><br><span class="line">                           &quot;C:\\Users\\junchow\\.docker\\machine\\machines\\default\\cert.pem&quot;)                                    </span><br><span class="line">      --tlskey string      Path to TLS key file (default                                                                           </span><br><span class="line">                           &quot;C:\\Users\\junchow\\.docker\\machine\\machines\\default\\key.pem&quot;)                                     </span><br><span class="line">      --tlsverify          Use TLS and verify the remote (default true)                                                            </span><br><span class="line">  -v, --version            终端打印显示版本信息并退出                                                                                                                                   </span><br><span class="line">管理命令:                                                                                                               </span><br><span class="line">  config      管理Docker配置</span><br><span class="line">  container   管理容器                                                                                                    </span><br><span class="line">  image       管理镜像</span><br><span class="line">  network     管理网络</span><br><span class="line">  node        管理Swarm节点</span><br><span class="line">  plugin      管理插件</span><br><span class="line">  secret      管理Docker安全</span><br><span class="line">  service     管理服务</span><br><span class="line">  swarm       管理Swarm集群</span><br><span class="line">  system      管理Docker系统</span><br><span class="line">  trust       Manage trust on Docker images                                                                                        </span><br><span class="line">  volume      管理卷</span><br><span class="line">                                                                                                                                   </span><br><span class="line">命令:                                                                                                                          </span><br><span class="line">  attach      将标准输入和标准输出连接到正在运行的容器                                        </span><br><span class="line">  build       使用dockerfile文件创建镜像                                                                                     </span><br><span class="line">  commit      从容器的修改项中创建新的镜像</span><br><span class="line">  cp          将容器的目录或文件复制到本地文件系统中</span><br><span class="line">  create      创建一个新的镜像</span><br><span class="line">  diff        检查容器文件系统的修改</span><br><span class="line">  events      实时输出docker服务器中发生的事件</span><br><span class="line">  exec        从外部运行容器内部的命令</span><br><span class="line">  export      将容器的文件系统到处为tat文件包</span><br><span class="line">  history     显示镜像的历史</span><br><span class="line">  images      输出镜像列表</span><br><span class="line">  import      从压缩为tar文件的文件系统中创建镜像</span><br><span class="line">  info        显示当前系统信息、docker容器与镜像个数、设置信息等</span><br><span class="line">  inspect     使用JSON格式显示容器与镜像的详细信息</span><br><span class="line">  kill        向容器发送kill信号关闭容器</span><br><span class="line">  load        从tar文件或标准输入中加载镜像</span><br><span class="line">  login       登录docker注册服务器</span><br><span class="line">  logout      退出docker注册服务器</span><br><span class="line">  logs        输出容器日志信息</span><br><span class="line">  pause       暂停容器中正在运行的所有进程</span><br><span class="line">  port        查看容器的端口是否处于开放状态</span><br><span class="line">  ps          输出容器列表</span><br><span class="line">  pull        从注册服务器中拉取一个镜像或仓库</span><br><span class="line">  push        将镜像推送到docker注册服务器</span><br><span class="line">  rename      重命名一个容器</span><br><span class="line">  restart     重启一个或多个容器</span><br><span class="line">  rm          删除一个或多个容器，若没有指定标签则删除lastest标签。</span><br><span class="line">  rmi         删除一个或多个镜像，若没有指定标签则删除lastest标签。                                                </span><br><span class="line">  run         在一个新容器中中运行命令，用于指定镜像创建容器。</span><br><span class="line">  save        将一个或多个镜像保存为tar包             </span><br><span class="line">  search      从Docker Hub中搜索镜像</span><br><span class="line">  start       启动一个或多个已经停止的容器</span><br><span class="line">  stats       Display a live stream of container(s) resource usage statistics                                                      </span><br><span class="line">  stop        停止一个或多个正在运行的容器</span><br><span class="line">  tag         设置镜像标签</span><br><span class="line">  top         显示容器中正在运行的进程信息</span><br><span class="line">  unpause     重启pause命令暂停的容器</span><br><span class="line">  update      更新一个或多个容器的配置</span><br><span class="line">  version     显示docker版本信息</span><br><span class="line">  wait        等待容器终止然后输出退出码                                                                                                                                   </span><br><span class="line">Run &#39;docker COMMAND --help&#39; for more information on a command.</span><br></pre></td></tr></table></figure></div><p><a href="/images/4933701-5e70d455c15d5aa1.webp" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/4933701-5e70d455c15d5aa1.webp" class="lazyload"></a></p><h2 id="容器生命周期"><a href="#容器生命周期" class="headerlink" title="容器生命周期"></a>容器生命周期</h2><h3 id="docker-run"><a href="#docker-run" class="headerlink" title="docker run"></a>docker run</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"># run用于指定镜像创建容器</span><br><span class="line">$ docker run [选项] &lt;镜像名称, id&gt; [命令] [参数]</span><br><span class="line"></span><br><span class="line"># 选项</span><br><span class="line">-d, --detach&#x3D;false 指定容器运行于前台还是后台，默认为false。</span><br><span class="line">-i, --interactive&#x3D;false 打开标准输入用于控制台交互</span><br><span class="line">-t, --tty&#x3D;false 分配tty设备用来支持终端登录，默认为false。</span><br><span class="line">-u, --user&#x3D;&quot;&quot; 指定容器的用户</span><br><span class="line">-a, --attach&#x3D;[] 登录容器，必须是以docker run -d启动的容器。</span><br><span class="line">-w, --workdir&#x3D;&quot;&quot; 设置容器的工作目录</span><br><span class="line">-c, --cpu-shares&#x3D;0 设置容器CPU权重，在CPU共享场景下使用。</span><br><span class="line">-e, --env&#x3D;[] 设置环境变量，容器中可使用该环境变量。</span><br><span class="line">-m, --memory&#x3D;&quot;&quot; 设置容器的内存上限</span><br><span class="line">-p, --public&#x3D;[] 设置容器暴露的端口</span><br><span class="line">-h, --hostname&#x3D;&quot;&quot; 设置容器的主机名</span><br><span class="line">-v, --volume&#x3D;[] 设置容器挂载的存储卷，也就是挂载到容器的某个目录。</span><br><span class="line">--volumn-from&#x3D;[] 给容器挂载其他容器上的卷，也就是挂载到容器的某个目录。</span><br><span class="line">--cap-add&#x3D;[] 添加权限</span><br><span class="line">--cap-drop&#x3D;[] 删除权限</span><br><span class="line">--cidfile&#x3D;&quot;&quot; 运行容器后在指定文件中写入容器PID值，这是典型的监控系统的用法。</span><br><span class="line">--cpuset&#x3D;&quot;&quot; 设置容器可以使用那些CPU，此参数用来设置容器独占CPU。</span><br><span class="line">--device&#x3D;[] 添加主机设备给容器，相当于设备直通。</span><br><span class="line">--dns&#x3D;[] 设置容器的DNS服务器</span><br><span class="line">--dns-search&#x3D;[] 设置容器的DNS搜索域名，写入到容器的&#x2F;etc&#x2F;resolv.conf文件。</span><br><span class="line">--env-file&#x3D;[] 设置环境变量文件，文件格式为每行一个环境变量。</span><br><span class="line">--expose&#x3D;[] 设置容器暴露的端口，即修改镜像的暴露端口。</span><br><span class="line">--link&#x3D;[] 设置容器之间的关联关系，使用其他容器的IP、env等信息。</span><br><span class="line">--lxc-conf&#x3D;[] 设置容器的配置文件，只有在指定--exe-driver&#x3D;lxc时使用。</span><br><span class="line">--name&#x3D;&quot;&quot; 设置容器的名称，可通过名字进行容器管理，links特性需要使用名字。</span><br><span class="line">--net&#x3D;&quot;bridge&quot; 容器网络设置</span><br><span class="line">--privileged&#x3D;false 设置容器是否为特权容器，特权容器拥有所有的capabilities。</span><br><span class="line">--restart&#x3D;&quot;no&quot; 设置让其停止后的重启策略</span><br><span class="line">--rm&#x3D;false 设置容器停止后自动删除容器，不支持以docker run -d启动的容器。</span><br><span class="line">--sig-proxy&#x3D;true 设置由代理接收并处理信号，但SIGCHLD、SIGSTOP、SIGKILL不能被代理。</span><br><span class="line"></span><br><span class="line"># 命令</span><br><span class="line">-d, --detach Detach模式，默认为守护进程模式，即容器以后台方式运行。</span><br><span class="line">--rm&#x3D;false 若容器内的进程终止则自动删除容器，禁止和-d选项一起使用。</span><br><span class="line">--sig-proxy&#x3D;true 将所有信号传递给进程，非TTY模式也一样，但不能传递SIGCHLD、SIGKILL、SIGSTOP信号。</span><br><span class="line"></span><br><span class="line"># 运行一个在后台执行的容器，同时使用控制台管理。</span><br><span class="line">$ docker run -i -t -d ubuntu:latest</span><br><span class="line"></span><br><span class="line"># 运行一个带命令且在后台不断执行的容器，不直接展示容器内部信息。</span><br><span class="line">$ docker run -d ubuntu:latest ping www.docker.com</span><br><span class="line"></span><br><span class="line"># 运行一个在后台不断执行的容器，同时带有命令，程序被终止后还能重启继续跑，可用控制台管理。</span><br><span class="line">$ docker run -d --restart&#x3D;always ubuntu:latest ping www.docker.com</span><br><span class="line"></span><br><span class="line"># 为容器指定一个名字</span><br><span class="line">$ docker run -d --name&#x3D;ubuntu_server ubuntu:latest</span><br><span class="line"></span><br><span class="line"># 容器暴露80端口并指定宿主机81端口与其通信（宿主机端口:容器端口）</span><br><span class="line">$ docker run -d --name&#x3D;ubuntu -p 81:80 ubuntu:latest</span><br><span class="line"></span><br><span class="line"># 指定容器内目录与宿主机目录共享（宿主机目录:容器目录）</span><br><span class="line">$ docker run -d --name&#x3D;ubuntu_server -v &#x2F;home&#x2F;www:&#x2F;var&#x2F;www ubuntu:latest</span><br><span class="line"></span><br><span class="line"># 设置宿主机与docker的共享目录</span><br><span class="line">$  docker run -d -i -t  -p 80:80 -v &#x2F;share&#x2F;swoft:&#x2F;var&#x2F;www&#x2F;swoft --name swoft swoft&#x2F;swoft &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure></div><p>使用<font color="red">docker run</font>启动容器，docker在后台的标准操作流程：</p><ol><li>检查本地是否存在指定的镜像，若不存在则从公有仓库下载。</li><li>使用镜像创建并启动容器</li><li>分配一个文件系统，并在只读的镜像层外面挂载一层可读可写层。</li><li>从宿主机配置的网桥接口中桥接一个虚拟机接口到容器中去</li><li>从地址池分配一个IP地址给容器</li><li>执行用户指定的应用程序</li><li>执行完毕后容器被终止</li></ol><p><a href="/images/4933701-b6b324803e563109.webp" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/4933701-b6b324803e563109.webp" class="lazyload"></a></p><h3 id="docker-create"><a href="#docker-create" class="headerlink" title="docker create"></a>docker create</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"># create 使用指定的镜像创建容器，与run命令不同的是，使用create命令只能创建容器而并不启动。</span><br><span class="line">$ docker create [选项] &lt;镜像名称,id&gt; &lt;命令&gt; [参数]</span><br><span class="line"></span><br><span class="line"># 选项</span><br><span class="line">-a, --attach&#x3D;[] 将标准输入、标准输出、标准错误链接到容器</span><br><span class="line">-C, --cpu-shares&#x3D;0 设置CPU资源分配，默认为1024。</span><br><span class="line">-e, --env&#x3D;[] 向容器设备环境变量，用于传递设置或密码。</span><br><span class="line">-h, --hostname&#x3D;&quot;&quot; 设置容器主机名</span><br><span class="line">-i, --interactive&#x3D;false 激活标准输入，即使未与容器连接，也维持标准输入。</span><br><span class="line">-m, --memory&#x3D;&quot;&quot; 设置内存限制，格式&lt;数字&gt;&lt;单位&gt;，单位可用b、k、m、g。</span><br><span class="line">-P, --publish-all&#x3D;false 将连接到主机的容器的所有端口暴露在外</span><br><span class="line">-p, --publish&#x3D;[] 将连接到主机的容器的特定端口暴露在外，主要用于暴露web服务器的端口。</span><br><span class="line">-t, --tty&#x3D;false 使用TTY模式，若要使用Bash则必须设置该选项。</span><br><span class="line">-u, --user&#x3D;&quot;&quot; 设置容器运行时要使用的Linux用户账户和UID</span><br><span class="line">-v, --volume&#x3D;[] 设置数据卷，设置要与主机共享的目录，不将文件保存到容器而是直接保存到主机，在主机目录后添加:ro与:rw进行读写设置，默认未:rw。</span><br><span class="line">-w, --workdir&#x3D;&quot;&quot; 设置容器内部要运行进程的目录</span><br><span class="line">-add-host&#x3D;[] 向容器的&#x2F;etc&#x2F;hosts添加主机名与IP地址</span><br><span class="line">--cap-add&#x3D;[] 设置容器中使用的cgroups的特定capablity，若设置为all则使用所有的capablity。</span><br><span class="line">--cap-drop&#x3D;[] 从容器中删除cgroup的特定capablity。</span><br><span class="line">--cidfile&#x3D;&quot;&quot; 设置cid文件路径，cid中存储着所创建容器的id。</span><br><span class="line">--cpuset&#x3D;&quot;&quot; 在多核CPU中设置要运行容器的核心数</span><br><span class="line">--device&#x3D;[] 添加主机设备到容器，格式为&lt;主机设备&gt;:&lt;容器设备&gt;</span><br><span class="line">--dns&#x3D;[] 设置容器中使用的DNS服务器</span><br><span class="line">--dns-search&#x3D;[] 设置docker中要使用的DNS搜索域</span><br><span class="line">--entrypoint&#x3D;&quot;&quot; 忽略Dockerfile的ENTRYPOINT设置，强制设置为其他值。</span><br><span class="line">--env-file&#x3D;[] 向容器应用设置环境变量文件</span><br><span class="line">--expose&#x3D;[] 仅连接容器的端口和主机，并不暴露在外。</span><br><span class="line">--link&#x3D;[] 进行容器连接，格式 &lt;容器名称&gt;:&lt;别名&gt;</span><br><span class="line">--lxc-conf&#x3D;[] 若使用LXC驱动则可设置LXC选项</span><br><span class="line">--name 设置容器名称</span><br><span class="line">--net&#x3D;&quot;bridge&quot; 设置容器的网络模式</span><br><span class="line">--privileged&#x3D;false 在容器内部使用主机的所有linux内核功能</span><br><span class="line">--restart&#x3D;&quot;&quot; 设置容器内部进程终止时重启策略</span><br><span class="line">--security-opt&#x3D;[] 设置SELinux、AppArmor选项</span><br><span class="line">--volumn-from&#x3D;[] 连接数据卷容器，设置格式未&lt;容器名称,id&gt;:&lt;:ro, :rw&gt;，默认读写设置遵从-v选项的设置。</span><br><span class="line"></span><br><span class="line"># 使用docker镜像nginx:latest创建一个容器名为ubuntu_serve</span><br><span class="line">$ docker create --name ubuntu_serve ubuntu:latest</span><br><span class="line">$ docker create -it --name ubuntu_server ubutnu:latest &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure></div><h3 id="docker-start"><a href="#docker-start" class="headerlink" title="docker start"></a>docker start</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># start用于启动容器</span><br><span class="line">$ docker start &lt;选项&gt;&lt;容器名称, id&gt;</span><br><span class="line"></span><br><span class="line"># 选项</span><br><span class="line">-a, --attach&#x3D;false 将标准输入、标准输出、标准错误连接到容器，传递所有信号。</span><br><span class="line">-i, --interactive&#x3D;false 激活标准输入</span><br></pre></td></tr></table></figure></div><h3 id="docker-stop"><a href="#docker-stop" class="headerlink" title="docker stop"></a>docker stop</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># stop用于终止容器</span><br><span class="line">$ docker stop &lt;选项&gt;&lt;容器名称, id&gt;</span><br><span class="line"></span><br><span class="line"># 选项</span><br><span class="line">-t, --timeout&#x3D;10 设置终止容器前的等待时间，单位为秒。</span><br></pre></td></tr></table></figure></div><h3 id="docker-restart"><a href="#docker-restart" class="headerlink" title="docker restart"></a>docker restart</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># restart 用于重启容器</span><br><span class="line">$ docker restart [选项] &lt;容器名称, id&gt;</span><br></pre></td></tr></table></figure></div><h3 id="docker-pause"><a href="#docker-pause" class="headerlink" title="docker pause"></a>docker pause</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># pause 用于暂停容器中所有的进程</span><br><span class="line">$ docker pause [选项] &lt;容器名称, id&gt;</span><br></pre></td></tr></table></figure></div><h3 id="docker-unpause"><a href="#docker-unpause" class="headerlink" title="docker unpause"></a>docker unpause</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># unpause用于重启使用pause命令暂停的容器</span><br><span class="line">$ docker unpause &lt;容器名称, id&gt;</span><br></pre></td></tr></table></figure></div><h3 id="docker-kill"><a href="#docker-kill" class="headerlink" title="docker kill"></a>docker kill</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># kill用于杀掉一个运行中的容器，发送SIGKILL信号来停止的主进程。</span><br><span class="line">$ docker kill [选项] &lt;容器名称, id&gt;</span><br><span class="line"></span><br><span class="line"># 选项</span><br><span class="line">-s 向容器发送一个信号</span><br><span class="line"></span><br><span class="line"># 杀死运行中的容器nginx</span><br><span class="line">$ docker kill -s KILL nginx</span><br></pre></td></tr></table></figure></div><h3 id="docker-rm"><a href="#docker-rm" class="headerlink" title="docker rm"></a>docker rm</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># rm用于删除一个或多个容器</span><br><span class="line">$ docker rm [选项] &lt;容器名称,id&gt;</span><br><span class="line"></span><br><span class="line"># 选项</span><br><span class="line">-f 通过SIGKILL信号强制删除一个运行中的容器</span><br><span class="line">-l 移除容器间的网路连接而非容器本身</span><br><span class="line">-v 删除与容器关联的卷</span><br><span class="line"></span><br><span class="line"># 强制删除容器test</span><br><span class="line">$ docker rm -f test</span><br><span class="line"></span><br><span class="line"># 删除容器test并删除挂载的数据卷</span><br><span class="line">$ docke rm -v test</span><br></pre></td></tr></table></figure></div><h3 id="docker-exec"><a href="#docker-exec" class="headerlink" title="docker exec"></a>docker exec</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># exec 用于在运行中的容器中执行命令</span><br><span class="line">$ docker exec [选项] &lt;容器名称, id&gt; &lt;命令&gt; [参数]</span><br><span class="line"></span><br><span class="line"># 选项</span><br><span class="line">-d 分离模式即在后台运行</span><br><span class="line">-i 即使没有附加也保持STDIN标准输入打开</span><br><span class="line">-t 分配一个伪终端</span><br><span class="line"></span><br><span class="line"># 在容器test中以交互模式执行容器内&#x2F;root&#x2F;test.sh脚本</span><br><span class="line">$ docker exec -it test &#x2F;bin&#x2F;sh &#x2F;root&#x2F;test.sh</span><br></pre></td></tr></table></figure></div><h2 id="容器操作"><a href="#容器操作" class="headerlink" title="容器操作"></a>容器操作</h2><h3 id="docker-ps"><a href="#docker-ps" class="headerlink" title="docker ps"></a>docker ps</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># ps用于输出容器列表</span><br><span class="line">$ docker ps &lt;选项&gt;</span><br><span class="line"></span><br><span class="line"># 选项</span><br><span class="line">-a, --all&#x3D;false 列出所有容器，不带-a则输出当前正在运行的容器。</span><br><span class="line">--before&#x3D;&quot;&quot; 列出特定容器创建前的容器，包含停止的容器。</span><br><span class="line">-f, --filter&#x3D;[] 设置输出过滤</span><br><span class="line">-l, --latest&#x3D;false 列出最后创建的容器包含停止的容器</span><br><span class="line">-q, --quiet&#x3D;false 只输出容器的ID</span><br><span class="line"></span><br><span class="line">$ docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS</span><br></pre></td></tr></table></figure></div><h3 id="docker-top"><a href="#docker-top" class="headerlink" title="docker top"></a>docker top</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># top用户显示容器中正在 运行的进程信息</span><br><span class="line">$ docker top &lt;容器名称, id&gt;&lt;ps选项&gt;</span><br><span class="line"></span><br><span class="line">$ docker top</span><br></pre></td></tr></table></figure></div><h3 id="docker-attach"><a href="#docker-attach" class="headerlink" title="docker attach"></a>docker attach</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># attach 用于将标准输入与标准输出连接到正在运行的容器</span><br><span class="line">$ docker attach &lt;选项&gt;&lt;容器名称, id&gt;</span><br></pre></td></tr></table></figure></div><h3 id="docker-logs"><a href="#docker-logs" class="headerlink" title="docker logs"></a>docker logs</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># logs用于获取容器的日志</span><br><span class="line">$ docker logs [选项] &lt;容器名称,id&gt;</span><br><span class="line"></span><br><span class="line"># 选项</span><br><span class="line">-f 跟踪日志输出</span><br><span class="line">--since 显示某个开始时间的所有日志</span><br><span class="line">-t 显示时间戳</span><br><span class="line">--tail 仅仅列出最新n条容器日志</span><br><span class="line"></span><br><span class="line"># 跟踪查看test容器的日志</span><br><span class="line">$ docker logs -f test</span><br><span class="line"></span><br><span class="line"># 查看test容器从2019年4月1日以后的最新10条日志</span><br><span class="line">$ docker logs --since&#x3D;&quot;2019-04-01&quot; --tail&#x3D;10 test</span><br></pre></td></tr></table></figure></div><p>如何动态跟踪并查看myswoft容器的日志详情呢？</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker@ ~$: docker logs -tf --details myswoft</span><br></pre></td></tr></table></figure></div><p>如何清理日志文件呢？</p><p>Docker日志默认存储位于：<font color="red">/var/lib/docker/containers/<container_id>/*.log</container_id></font></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># 在docker中切换为root用户</span><br><span class="line">docker@default: ~$ su -i</span><br><span class="line"></span><br><span class="line"># 查看docker容器的id</span><br><span class="line">root@default: ~$ docker ps -a | grep myswoft</span><br><span class="line">d26ff0ff1bc0        swoft&#x2F;swoft         &quot;php &#x2F;var&#x2F;www&#x2F;swoft&#x2F;…&quot;   2 weeks ago         Up 22 minutes       0.0.0.0:80-&gt;80&#x2F;tcp                  myswoft</span><br><span class="line"></span><br><span class="line"># 查看容器日志文件大小</span><br><span class="line">root@default: ~$ ls -lh  $(find &#x2F;var&#x2F;lib&#x2F;docker&#x2F;containers&#x2F; -name *-json.log)</span><br><span class="line">-rw-r-----    1 root     root           0 May 14 13:32 &#x2F;var&#x2F;lib&#x2F;docker&#x2F;containers&#x2F;d26ff0ff1bc0dc0221ce5be7f78da96123a0ddbb379ab8befd2d1403f44e820b&#x2F;d26ff0ff1bc0dc0221ce5be7f78da96123a0ddbb379ab8befd2d1403f44e820b-json.log</span><br><span class="line"></span><br><span class="line"># 进入日志目录</span><br><span class="line">root@default: ~$ cd &#x2F;var&#x2F;lib&#x2F;docker&#x2F;containers&#x2F;d26ff0ff1bc0dc0221ce5be7f78da96123a0ddbb379ab8befd2d1403f44e820b</span><br><span class="line"></span><br><span class="line"># 临时清理日志文件</span><br><span class="line">root@default: &#x2F;var...&#x2F;$ truncate -s 0 &#x2F;var&#x2F;lib&#x2F;docker&#x2F;containers&#x2F;&lt;container_id&gt;&#x2F;*-json.log</span><br><span class="line"></span><br><span class="line"># 临时清理日志文件</span><br><span class="line">root@default: &#x2F;var..&#x2F;$ cat &#x2F;dev&#x2F;null &gt; *-json.log</span><br><span class="line"></span><br><span class="line"># 使用rm删除日志文件后是需要重启容器的，如果容器运行状态下Linux进程会引用着不会释放磁盘空间。</span><br><span class="line">root@default &#x2F;var&#x2F;...&#x2F;$ rm -rf *-json.log</span><br></pre></td></tr></table></figure></div><h3 id="docker-port"><a href="#docker-port" class="headerlink" title="docker port"></a>docker port</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># port用于列出指定容器的端口映射，或者用于查找将PRIVATE_PORT NAT到面向公众的端口。</span><br><span class="line">$ docker port [选项] &lt;容器名称,id&gt; [PRIVATE_PORT[&#x2F;PROTO]]</span><br><span class="line"></span><br><span class="line"># 查看test容器的端口映射情况</span><br><span class="line">$ docker port test</span><br></pre></td></tr></table></figure></div><h2 id="镜像仓库"><a href="#镜像仓库" class="headerlink" title="镜像仓库"></a>镜像仓库</h2><h3 id="docker-search"><a href="#docker-search" class="headerlink" title="docker search"></a>docker search</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># search用于在docker hub中搜索镜像</span><br><span class="line">$ docker search &lt;选项&gt;&lt;搜索关键词&gt;</span><br><span class="line"></span><br><span class="line"># 选项</span><br><span class="line">--automated&#x3D;false 只显示由docker hub的automated build创建的镜像</span><br><span class="line">--no-trunc&#x3D;false 显示所有因内容过长而省略的部分</span><br><span class="line">-s, --stars&#x3D;0 显示有特定星级以上的镜像</span><br></pre></td></tr></table></figure></div><h2 id="本地镜像"><a href="#本地镜像" class="headerlink" title="本地镜像"></a>本地镜像</h2><h3 id="docker-images"><a href="#docker-images" class="headerlink" title="docker images"></a>docker images</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># images用于输出镜像列表</span><br><span class="line">$ docker images &lt;选项&gt;&lt;镜像名称, id&gt;</span><br><span class="line"></span><br><span class="line"># 选项</span><br><span class="line">-a, --all&#x3D;false 列出所有镜像包含父镜像。</span><br><span class="line">-f, --filter&#x3D;[] 设置输出结果过滤，若设置为dangling&#x3D;true则仅输出无名镜像。</span><br><span class="line">--no-trunc&#x3D;false 显示所有因内容过长而省略的部分</span><br><span class="line"></span><br><span class="line">$ docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br></pre></td></tr></table></figure></div><h3 id="docker-rmi"><a href="#docker-rmi" class="headerlink" title="docker rmi"></a>docker rmi</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># rmi 用于删除镜像，若没有指定标签则会删除latest标签。</span><br><span class="line">$ docker rmi &lt;注册名称&gt;&#x2F;&lt;镜像名称, id&gt;:&lt;标签&gt;</span><br><span class="line"></span><br><span class="line"># 选项</span><br><span class="line">-f, --force&#x3D;false 强制删除镜像</span><br><span class="line">--no-prune&#x3D;false 不删除不带标签的父级镜像</span><br><span class="line"></span><br><span class="line"># 删除所有镜像</span><br><span class="line">$ docker rmi &#96;docker images -aq&#96;</span><br></pre></td></tr></table></figure></div><h3 id="docker-tag"><a href="#docker-tag" class="headerlink" title="docker tag"></a>docker tag</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># tag用于设置镜像标签</span><br><span class="line">$ docker tag &lt;选项&gt;&lt;镜像名称&gt;:&lt;标签&gt;&lt;注册地址, 用户名&gt;&#x2F;&lt;镜像名称&gt;:&lt;标签&gt;</span><br><span class="line"></span><br><span class="line"># 选项</span><br><span class="line">- f, --force&#x3D;false 强制设置，即使已拥有标签，如远程仓库设置标签。</span><br></pre></td></tr></table></figure></div><h3 id="docker-save"><a href="#docker-save" class="headerlink" title="docker save"></a>docker save</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># save用于将镜像保存为tag包文件</span><br><span class="line">$ docker save &lt;选项&gt;&lt;镜像名称&gt;:&lt;标签&gt;</span><br><span class="line"></span><br><span class="line"># 选项</span><br><span class="line">-o, --output&#x3D;&quot;&quot; 设置保存时的文件名称</span><br></pre></td></tr></table></figure></div><p>若不设置<font color="red">-o</font>选项，<font color="red">tar</font>包文件会输出到标准输出，所以必须设置重定向。如果仅指定镜像名称但没有指指定标签，则会将所有标签都保存到一个<font color="red">tar</font>包文件中。</p><h2 id="信息查看"><a href="#信息查看" class="headerlink" title="信息查看"></a>信息查看</h2><h3 id="docker-info"><a href="#docker-info" class="headerlink" title="docker info"></a>docker info</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"># info用于显示当前系统信息、docker容器和镜像数量、设置等信息。</span><br><span class="line">$ docker info</span><br><span class="line">Containers: 0</span><br><span class="line"> Running: 0</span><br><span class="line"> Paused: 0</span><br><span class="line"> Stopped: 0</span><br><span class="line">Images: 0</span><br><span class="line">Server Version: 18.09.5</span><br><span class="line">Storage Driver: overlay2</span><br><span class="line"> Backing Filesystem: extfs</span><br><span class="line"> Supports d_type: true</span><br><span class="line"> Native Overlay Diff: true</span><br><span class="line">Logging Driver: json-file</span><br><span class="line">Cgroup Driver: cgroupfs</span><br><span class="line">Plugins:</span><br><span class="line"> Volume: local</span><br><span class="line"> Network: bridge host macvlan null overlay</span><br><span class="line"> Log: awslogs fluentd gcplogs gelf journald json-file local logentries splunk syslog</span><br><span class="line">Swarm: inactive</span><br><span class="line">Runtimes: runc</span><br><span class="line">Default Runtime: runc</span><br><span class="line">Init Binary: docker-init</span><br><span class="line">containerd version: bb71b10fd8f58240ca47fbb579b9d1028eea7c84</span><br><span class="line">runc version: 2b18fe1d885ee5083ef9f0838fee39b62d653e30</span><br><span class="line">init version: fec3683</span><br><span class="line">Security Options:</span><br><span class="line"> seccomp</span><br><span class="line">  Profile: default</span><br><span class="line">Kernel Version: 4.14.111-boot2docker</span><br><span class="line">Operating System: Boot2Docker 18.09.5 (TCL 8.2.1)</span><br><span class="line">OSType: linux</span><br><span class="line">Architecture: x86_64</span><br><span class="line">CPUs: 1</span><br><span class="line">Total Memory: 989.4MiB</span><br><span class="line">Name: default</span><br><span class="line">ID: 7ST2:CIQM:GLVF:AUF2:QFKR:N2LB:FSO7:V6UJ:5IFN:MQVZ:WK7L:TGSS</span><br><span class="line">Docker Root Dir: &#x2F;mnt&#x2F;sda1&#x2F;var&#x2F;lib&#x2F;docker</span><br><span class="line">Debug Mode (client): false</span><br><span class="line">Debug Mode (server): false</span><br><span class="line">Registry: https:&#x2F;&#x2F;index.docker.io&#x2F;v1&#x2F;</span><br><span class="line">Labels:</span><br><span class="line"> provider&#x3D;virtualbox</span><br><span class="line">Experimental: false</span><br><span class="line">Insecure Registries:</span><br><span class="line"> 127.0.0.0&#x2F;8</span><br><span class="line">Live Restore Enabled: false</span><br></pre></td></tr></table></figure></div><h3 id="docker-version"><a href="#docker-version" class="headerlink" title="docker version"></a>docker version</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># version用户输出docker的版本信息</span><br><span class="line">$ docker version</span><br><span class="line">Client:</span><br><span class="line"> Version:       18.03.0-ce</span><br><span class="line"> API version:   1.37</span><br><span class="line"> Go version:    go1.9.4</span><br><span class="line"> Git commit:    0520e24302</span><br><span class="line"> Built: Fri Mar 23 08:31:36 2018</span><br><span class="line"> OS&#x2F;Arch:       windows&#x2F;amd64</span><br><span class="line"> Experimental:  false</span><br><span class="line"> Orchestrator:  swarm</span><br><span class="line"></span><br><span class="line">Server: Docker Engine - Community</span><br><span class="line"> Engine:</span><br><span class="line">  Version:      18.09.5</span><br><span class="line">  API version:  1.39 (minimum version 1.12)</span><br><span class="line">  Go version:   go1.10.8</span><br><span class="line">  Git commit:   e8ff056dbc</span><br><span class="line">  Built:        Thu Apr 11 04:50:00 2019</span><br><span class="line">  OS&#x2F;Arch:      linux&#x2F;amd64</span><br><span class="line">  Experimental: false</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker部署NetCore项目基本步骤</title>
      <link href="/2020/01/14/Docker%E9%83%A8%E7%BD%B2NetCore%E9%A1%B9%E7%9B%AE%E5%9F%BA%E6%9C%AC%E6%AD%A5%E9%AA%A4/"/>
      <url>/2020/01/14/Docker%E9%83%A8%E7%BD%B2NetCore%E9%A1%B9%E7%9B%AE%E5%9F%BA%E6%9C%AC%E6%AD%A5%E9%AA%A4/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><p>创建core的项目，确保能在本地运行。测试项目绑定本地的8080端口</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static IWebHost BuildWebHost(string[] args) &#x3D;&gt;</span><br><span class="line">            WebHost.CreateDefaultBuilder(args)</span><br><span class="line">            .UseUrls(&quot;http:&#x2F;&#x2F;*:8080&quot;)</span><br><span class="line">                .UseStartup&lt;Startup&gt;()</span><br><span class="line">                .Build();</span><br></pre></td></tr></table></figure></div><h2 id="生成项目"><a href="#生成项目" class="headerlink" title="生成项目"></a>生成项目</h2><p><a href="/images/624419-20190213133748266-1241774899.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/624419-20190213133748266-1241774899.png" class="lazyload"></a></p><h2 id="添加Dockerfile"><a href="#添加Dockerfile" class="headerlink" title="添加Dockerfile"></a>添加Dockerfile</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 基于microsoft&#x2F;dotnet:latest构建Docker Image</span><br><span class="line">FROM microsoft&#x2F;dotnet:latest</span><br><span class="line"> </span><br><span class="line"># 进入docker中的&#x2F;usr&#x2F;local&#x2F;src目录</span><br><span class="line">RUN cd &#x2F;usr&#x2F;local&#x2F;src</span><br><span class="line"> </span><br><span class="line"># 创建DockerWebAPI目录</span><br><span class="line">RUN mkdir DockerTest</span><br><span class="line"> </span><br><span class="line"># 设置工作路径</span><br><span class="line">WORKDIR &#x2F;usr&#x2F;local&#x2F;src&#x2F;DockerTest</span><br><span class="line"> </span><br><span class="line"># 将当前文件夹下的所有文件全部复制到工作目录</span><br><span class="line">COPY *.* .&#x2F;</span><br><span class="line"> </span><br><span class="line"># 向外界暴露5000端口</span><br><span class="line">EXPOSE 5000</span><br><span class="line"> </span><br><span class="line"># 执行dotnet DockerWebAPI.dll命令</span><br><span class="line">CMD [&quot;dotnet&quot;, &quot;DockerTest.dll&quot;]</span><br></pre></td></tr></table></figure></div><blockquote><p>microsoft/dotnet:latest 是最新的包，打包后的镜像文件可能有1G以上</p></blockquote><blockquote><p>microsoft/dotnet:2.1-aspnetcore-runtime 2.1的运行时包，比较小<br>其他.net core 镜像环境可以自己去找</p></blockquote><h2 id="发布到docker"><a href="#发布到docker" class="headerlink" title="发布到docker"></a>发布到docker</h2><p>红字部分为docker镜像名称</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t &lt;font color&#x3D;&quot;red&quot;&gt;dotnet&#x2F;dockertest&lt;&#x2F;font&gt; .</span><br></pre></td></tr></table></figure></div><h2 id="启动镜像"><a href="#启动镜像" class="headerlink" title="启动镜像"></a>启动镜像</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -p 8080:5000 dotnet&#x2F;dockertest</span><br></pre></td></tr></table></figure></div><p><a href="/images/624419-20190213135008859-294324419.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/624419-20190213135008859-294324419.png" class="lazyload"></a></p><h2 id="Docker常用命令"><a href="#Docker常用命令" class="headerlink" title="Docker常用命令"></a>Docker常用命令</h2><h3 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h3><ol><li>docker images 查看镜像信息列表 镜像是静态的1.</li><li>docker ps -a 查看运行中的所有容器1.</li><li>docker pull  [images]:[version]从dockerhub拉取指定镜像1.</li><li>docker run -p 8000:80 -tdi –privileged [imageID] [command]  后台启动docker,并指定宿主机端口和docker映射端口。</li></ol><blockquote><p>-i:以交互模式运行容器，通常与 -t 同时使用；<br>-d:后台运行容器，并返回容器ID；<br>t:为容器重新分配一个伪输入终端，通常与 -i 同时使用；</p><p>–privileged 容器将拥有访问主机所有设备的权限</p><p>通常情况下 [command] 填下 /bin/bash 即可。</p><p>特殊情况下，如需要在centos镜像中使用systemctl . 则应添加–privileged 并设置[command ]为 init。</p></blockquote><ol start="5"><li>当镜像通过run 启动后，便会载入到一个动态的container(容器)中运行，此时若需要进入终端交互模式：</li></ol><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker exec -it [containerID] &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure></div><blockquote><p>交互模式中，使用  ctrl+p+q退出交互 保持运行,使用 exit命令退出并停止容器。</p></blockquote><ol start="6"><li><p>在容器非交互模式下，通过docker  start/stop 命令来启动/停止已部署的容器服务。</p></li><li><p>docker rm [containerID] 删除容器</p></li><li><p>docker rmi [imageID] 删除镜像</p></li><li><p>docker cp [YourHostFilePath] [containerID]:[DockerPath]  将宿主机内的指定文件传输至容器内部的指定地址。</p></li></ol><h3 id="镜像制作"><a href="#镜像制作" class="headerlink" title="镜像制作"></a>镜像制作</h3><ol><li><p>docker commit [containerID] [ImageName]:[Version] 将修改后的容器重新打包成镜像</p></li><li><p>docker commit -a “runoob.com” -m “my apache” a404c6c174a2 mymysql:v1 将容器a404c6c174a2 保存为新的镜像,并添加提交人信息和说明信息。</p></li></ol><blockquote><p>a :提交的镜像作者；</p><p>-c :使用Dockerfile指令来创建镜像；</p><p>-m :提交时的说明文字；</p><p>-p :在commit时，将容器暂停。</p></blockquote><ol start="3"><li>docker push [ImageID] [repertory_address]提交镜像到云仓库</li></ol><h2 id="开机启动Docker"><a href="#开机启动Docker" class="headerlink" title="开机启动Docker"></a>开机启动Docker</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable docker</span><br><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure></div><h2 id="防火墙管理"><a href="#防火墙管理" class="headerlink" title="防火墙管理"></a>防火墙管理</h2><h3 id="firewalld"><a href="#firewalld" class="headerlink" title="firewalld"></a>firewalld</h3><h4 id="启动和关闭firewalld"><a href="#启动和关闭firewalld" class="headerlink" title="启动和关闭firewalld"></a>启动和关闭firewalld</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl start firewalld.service #启动</span><br><span class="line">systemctl stop firewalld.service #关闭</span><br><span class="line">systemctl disable firewalld.service #禁止firewall开机启动</span><br></pre></td></tr></table></figure></div><h4 id="开启端口"><a href="#开启端口" class="headerlink" title="开启端口"></a>开启端口</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --zone&#x3D;public --add-port&#x3D;80&#x2F;tcp --permanent</span><br></pre></td></tr></table></figure></div><h5 id="查询端口号80-是否开启："><a href="#查询端口号80-是否开启：" class="headerlink" title="查询端口号80 是否开启："></a>查询端口号80 是否开启：</h5><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --query-port&#x3D;80&#x2F;tcp</span><br></pre></td></tr></table></figure></div><h4 id="重启防火墙"><a href="#重启防火墙" class="headerlink" title="重启防火墙"></a>重启防火墙</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure></div><h4 id="查询有哪些端口是开启的"><a href="#查询有哪些端口是开启的" class="headerlink" title="查询有哪些端口是开启的"></a>查询有哪些端口是开启的</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --list-port</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> Linux </tag>
            
            <tag> .Net Core </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 部署 .Net Core项目部署（一）</title>
      <link href="/2020/01/11/Linux%20%E9%83%A8%E7%BD%B2%20.NetCore%E9%A1%B9%E7%9B%AE%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2020/01/11/Linux%20%E9%83%A8%E7%BD%B2%20.NetCore%E9%A1%B9%E7%9B%AE%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="更新yum管理器"><a href="#更新yum管理器" class="headerlink" title="更新yum管理器"></a>更新yum管理器</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum update</span><br></pre></td></tr></table></figure></div><h2 id="通过yum安装-aspnetcore-runtime-2-2"><a href="#通过yum安装-aspnetcore-runtime-2-2" class="headerlink" title="通过yum安装 aspnetcore-runtime-2.2"></a>通过yum安装 aspnetcore-runtime-2.2</h2><p><strong>在安装.NET之前，您需要注册Microsoft密钥，注册产品存储库并安装所需的依赖项。这只需要每台机器完成一次。</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo rpm -Uvh https:&#x2F;&#x2F;packages.microsoft.com&#x2F;config&#x2F;rhel&#x2F;7&#x2F;packages-microsoft-prod.rpm</span><br></pre></td></tr></table></figure></div><p>再执行</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install aspnetcore-runtime-2.2</span><br></pre></td></tr></table></figure></div><h2 id="检查安装是否成功"><a href="#检查安装是否成功" class="headerlink" title="检查安装是否成功"></a>检查安装是否成功</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dotnet</span><br></pre></td></tr></table></figure></div><p><em>如果命令运行，打印出有关如何使用dotnet的信息，那么你很高兴。如果没有，查看官方或百度。</em></p><h2 id="上传发布后的项目"><a href="#上传发布后的项目" class="headerlink" title="上传发布后的项目"></a>上传发布后的项目</h2><p>可使用xshell 6或者 bitvise SSH工具上传项目到虚机</p><blockquote><p>Xshell下载地址：<a href="https://www.baidu.com/link?url=iRX54VZWTYwoEXZx8m6NtwWo6LR6R-M8OGrkJszUWJ78sYpbtSbArDEpQAmpqfzlXvcM1xTqgrwip8QErIsthOKFAMpWmqIS3j5XPvM6g5a&amp;amp;wd=&amp;amp;eqid=8cfd7e3d00027952000000065c9db5f9" target="_blank" rel="noopener">https://www.baidu.com/link?url=iRX54VZWTYwoEXZx8m6NtwWo6LR6R-M8OGrkJszUWJ78sYpbtSbArDEpQAmpqfzlXvcM1xTqgrwip8QErIsthOKFAMpWmqIS3j5XPvM6g5a&amp;amp;wd=&amp;amp;eqid=8cfd7e3d00027952000000065c9db5f9</a><br>bitvise SSH 在网盘里</p></blockquote><h2 id="运行项目"><a href="#运行项目" class="headerlink" title="运行项目"></a>运行项目</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dotnet WebApplication22Test.dll --urls&#x3D;&quot;http:&#x2F;&#x2F;*:20192&quot; --ip&#x3D;&quot;192.168.1.106&quot; --port&#x3D;20192</span><br></pre></td></tr></table></figure></div><blockquote><p>为了能让外网访问虚拟机站点需要关闭防火墙： 命令：  <font color="red">systemctl stop firewalld</font><br>通过命令启动core程序：dotnet WebApplication22Test.dll –urls=”http://*:20192” –ip=”192.168.1.106” –port=20192<br>访问地址： 192.168.1.106:20192<br>修改centOS root用户密码： sudo passwd root</p></blockquote><p><strong>输入网址验证项目是否运行成功</strong></p><h2 id="pm2守护进程的安装以及使用"><a href="#pm2守护进程的安装以及使用" class="headerlink" title="pm2守护进程的安装以及使用"></a>pm2守护进程的安装以及使用</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><h3 id="安装-nodejs"><a href="#安装-nodejs" class="headerlink" title="安装 nodejs"></a>安装 nodejs</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;nodejs.org&#x2F;dist&#x2F;v8.11.4&#x2F;node-v8.11.4-linux-x64.tar.xz  #在根目录下 下载nodejs安装包</span><br><span class="line"></span><br><span class="line">tar xvf node-v8.11.4-linux-x64.tar.xz #解压</span><br><span class="line"></span><br><span class="line">mv node-v8.11.4-linux-x64 node-v8.11.4 #改短名</span><br><span class="line"></span><br><span class="line">cd &#x2F;node-v8.11.4&#x2F;bin &amp;&amp; ls #进入目录并列出</span><br><span class="line"></span><br><span class="line">.&#x2F;node -v #查看node版本</span><br><span class="line"></span><br><span class="line">node -v #无法获取，未配置</span><br></pre></td></tr></table></figure></div><p><strong>配置全局变量</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">echo PATH #查看环境变量路径</span><br><span class="line">&#x2F;sbin:&#x2F;bin:&#x2F;usr&#x2F;sbin:&#x2F;usr&#x2F;bin  # 表示各个地址 以 ：隔开  。其中并没有 &#x2F;usr&#x2F;local&#x2F;bin</span><br><span class="line"></span><br><span class="line">ln -s &#x2F;usr&#x2F;local&#x2F;node-v8.9.3-linux-x64&#x2F;bin&#x2F;node &#x2F;usr&#x2F;local&#x2F;bin&#x2F;node  #添加到全局变量</span><br><span class="line">ln -s &#x2F;usr&#x2F;local&#x2F;node-v8.9.3-linux-x64&#x2F;bin&#x2F;npm &#x2F;usr&#x2F;local&#x2F;bin&#x2F;npm  #添加到全局变量</span><br></pre></td></tr></table></figure></div><h3 id="安装pm2"><a href="#安装pm2" class="headerlink" title="安装pm2"></a>安装pm2</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install pm2 -g</span><br></pre></td></tr></table></figure></div><p><strong>配置全局变量</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s &#x2F;usr&#x2F;local&#x2F;node-v8.9.3-linux-x64&#x2F;bin&#x2F;pm2 &#x2F;usr&#x2F;local&#x2F;bin&#x2F;pm2  #添加到全局变量</span><br></pre></td></tr></table></figure></div><h4 id="pm2-常用命令"><a href="#pm2-常用命令" class="headerlink" title="pm2 常用命令"></a>pm2 常用命令</h4><table><thead><tr><th><strong>命令</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>pm2 startup</td><td>设置pm2开机自启动</td></tr><tr><td>pm2 unstartup</td><td>移除pm2开机自启动</td></tr><tr><td>pm2 save</td><td>保存当前进程开机自启动</td></tr><tr><td>pm2 start &lt;进程启动命令&gt; [–name &lt;进程名&gt;]</td><td>启动应用程序</td></tr><tr><td>pm2 list</td><td>显示所有进程状态</td></tr><tr><td>pm2 monit</td><td>监控进程</td></tr><tr><td>pm2 logs [进程id或名字]</td><td>显示进程日志</td></tr><tr><td>pm2 stop [all]</td><td>停止[所有]进程</td></tr><tr><td>pm2 restart [all]</td><td>重启[所有]进程</td></tr><tr><td>pm2 delete [&lt;进程名或者id&gt;,all]</td><td>删除指定[所有]进程</td></tr><tr><td>pm2 info [进程id或名字]</td><td>查看应用程序信息</td></tr></tbody></table><blockquote><p>官方文档：<a href="http://pm2.keymetrics.io/docs/usage/quick-start/#usage" target="_blank" rel="noopener">http://pm2.keymetrics.io/docs/usage/quick-start/#usage</a></p></blockquote><h3 id="运行项目-1"><a href="#运行项目-1" class="headerlink" title="运行项目"></a>运行项目</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pm2 start &quot;dotnet Core.dll&quot; --name CoreTest</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> .Net Core </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 虚拟机 </tag>
            
            <tag> Linux </tag>
            
            <tag> ContOS </tag>
            
            <tag> 部署 </tag>
            
            <tag> XShell </tag>
            
            <tag> Bitvise SSH </tag>
            
            <tag> PM2 </tag>
            
            <tag> Node.js </tag>
            
            <tag> .Net Core </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚拟机安装CentOS7（二）</title>
      <link href="/2020/01/11/Linux%20%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS7%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2020/01/11/Linux%20%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS7%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="下载软件"><a href="#下载软件" class="headerlink" title="下载软件"></a>下载软件</h2><blockquote><p>CentOS7：下载地址<br><a href="http://isoredirect.centos.org/centos/7/isos/x86_64/CentOS-7-x86_64-Minimal-1810.iso" target="_blank" rel="noopener">http://isoredirect.centos.org/centos/7/isos/x86_64/CentOS-7-x86_64-Minimal-1810.iso</a></p></blockquote><p><strong>虚拟机：VMware, 客户机：CentOS7（linux）</strong></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><strong>1. 打开虚拟机新建虚拟机，选择自定义</strong> </p><p><a href="/images/1651513131.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/1651513131.png" class="lazyload"></a></p><p><strong>2. 默认下一步</strong></p><p><a href="/images/51133151.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/51133151.png" class="lazyload"></a></p><p><strong>3. 稍后安装操作系统</strong></p><p><a href="/images/4813131.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/4813131.png" class="lazyload"></a></p><p><strong>4. 如图</strong></p><p><a href="/images/4431121.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/4431121.png" class="lazyload"></a></p><p><strong>5. 根据自己习惯选择安装位置</strong></p><p><a href="/images/6845311531321.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/6845311531321.png" class="lazyload"></a></p><p><strong>6. 下一步</strong></p><p><a href="/images/461341531.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/461341531.png" class="lazyload"></a></p><p><strong>7. 2048M，根据自己电脑配置填写</strong></p><p><a href="/images/841531313511.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/841531313511.png" class="lazyload"></a></p><p><strong>8. 如图</strong></p><p><a href="/images/865132653121.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/865132653121.png" class="lazyload"></a></p><p><strong>9. 后面默认</strong></p><p><a href="/images/%E5%9B%BE%E7%89%871.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/%E5%9B%BE%E7%89%871.png" class="lazyload"></a></p><p><a href="/images/%E5%9B%BE%E7%89%872.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/%E5%9B%BE%E7%89%872.png" class="lazyload"></a></p><p><a href="/images/%E5%9B%BE%E7%89%873.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/%E5%9B%BE%E7%89%873.png" class="lazyload"></a></p><p><a href="/images/%E5%9B%BE%E7%89%874.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/%E5%9B%BE%E7%89%874.png" class="lazyload"></a></p><p><a href="/images/%E5%9B%BE%E7%89%875.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/%E5%9B%BE%E7%89%875.png" class="lazyload"></a></p><p><a href="/images/%E5%9B%BE%E7%89%876.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/%E5%9B%BE%E7%89%876.png" class="lazyload"></a></p><p><strong>10. 完成后如图，选择CD/DVD(IDE)</strong></p><p><a href="/images/%E5%9B%BE%E7%89%877.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/%E5%9B%BE%E7%89%877.png" class="lazyload"></a></p><p><strong>11. 使用ISO映像文件，路径为下载的CentOS7文件路径，然后确定</strong></p><p><a href="/images/%E5%9B%BE%E7%89%878.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/%E5%9B%BE%E7%89%878.png" class="lazyload"></a></p><p><strong>12. 开启此虚拟机</strong></p><p><a href="/images/%E5%9B%BE%E7%89%879.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/%E5%9B%BE%E7%89%879.png" class="lazyload"></a></p><p><strong>13. 根据上下键选择Install CentOS 7，回车</strong></p><p><a href="/images/%E5%9B%BE%E7%89%8710.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/%E5%9B%BE%E7%89%8710.png" class="lazyload"></a></p><p><strong>14. 选择中文，简体中文</strong></p><p><a href="/images/%E5%9B%BE%E7%89%8711.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/%E5%9B%BE%E7%89%8711.png" class="lazyload"></a></p><p><strong>15. 然后点击软件选择，如下图勾选GUI</strong></p><p><a href="/images/%E5%9B%BE%E7%89%8712.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/%E5%9B%BE%E7%89%8712.png" class="lazyload"></a></p><p><a href="/images/%E5%9B%BE%E7%89%8713.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/%E5%9B%BE%E7%89%8713.png" class="lazyload"></a></p><p><strong>16. 点击安装位置，我要配置分区，然后完成</strong></p><p><a href="/images/%E5%9B%BE%E7%89%8714.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/%E5%9B%BE%E7%89%8714.png" class="lazyload"></a></p><p><a href="/images/%E5%9B%BE%E7%89%8715.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/%E5%9B%BE%E7%89%8715.png" class="lazyload"></a></p><p><strong>17. 选择标准分区，然后点击加号</strong></p><p><a href="/images/%E5%9B%BE%E7%89%8716.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/%E5%9B%BE%E7%89%8716.png" class="lazyload"></a></p><p><strong>18. 新建分区 /boot  500m，这里网上都是200m，有点小</strong></p><p><a href="/images/%E5%9B%BE%E7%89%8717.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/%E5%9B%BE%E7%89%8717.png" class="lazyload"></a></p><p><a href="/images/%E5%9B%BE%E7%89%8718.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/%E5%9B%BE%E7%89%8718.png" class="lazyload"></a></p><p><strong>19. 新建分区swap，容量设置为2G，同时把文件系统改为ext4</strong></p><p><a href="/images/%E5%9B%BE%E7%89%8719.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/%E5%9B%BE%E7%89%8719.png" class="lazyload"></a></p><p><strong>20. 继续添加 /home的挂载点，容量同样设置为2G，同时把文件系统改为ext4</strong></p><p><a href="/images/%E5%9B%BE%E7%89%8720.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/%E5%9B%BE%E7%89%8720.png" class="lazyload"></a></p><p><strong>21. 最后把剩下的所有空间都添加到根目录下，为空则是把剩余空间全部分配</strong></p><p><a href="/images/%E5%9B%BE%E7%89%8721.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/%E5%9B%BE%E7%89%8721.png" class="lazyload"></a></p><p><strong>22. 接受改变</strong></p><p><a href="/images/%E5%9B%BE%E7%89%8722.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/%E5%9B%BE%E7%89%8722.png" class="lazyload"></a></p><p><strong>23. 点击网络和主机名，打开网络</strong></p><p><a href="/images/%E5%9B%BE%E7%89%8723.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/%E5%9B%BE%E7%89%8723.png" class="lazyload"></a></p><p><strong>24. 开始安装</strong></p><p><a href="/images/%E5%9B%BE%E7%89%8724.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/%E5%9B%BE%E7%89%8724.png" class="lazyload"></a></p><p><strong>25. 点击ROOT密码，设置密码，完成，等待安装完成。</strong></p><p><a href="/images/%E5%9B%BE%E7%89%8725.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/%E5%9B%BE%E7%89%8725.png" class="lazyload"></a></p><p><a href="/images/%E5%9B%BE%E7%89%8726.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/%E5%9B%BE%E7%89%8726.png" class="lazyload"></a></p><p><strong>26. 完成后点击重启</strong></p><p><a href="/images/%E5%9B%BE%E7%89%8727.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/%E5%9B%BE%E7%89%8727.png" class="lazyload"></a></p><p><strong>27. 如下图，点击后同意许可即可，然后点击完成配置</strong></p><p><a href="/images/%E5%9B%BE%E7%89%8728.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/%E5%9B%BE%E7%89%8728.png" class="lazyload"></a></p><p><strong>28. 一直前进</strong></p><p><a href="/images/%E5%9B%BE%E7%89%8729.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/%E5%9B%BE%E7%89%8729.png" class="lazyload"></a></p><p><a href="/images/%E5%9B%BE%E7%89%8730.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/%E5%9B%BE%E7%89%8730.png" class="lazyload"></a></p><p><a href="/images/%E5%9B%BE%E7%89%8731.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/%E5%9B%BE%E7%89%8731.png" class="lazyload"></a></p><p><a href="/images/%E5%9B%BE%E7%89%8732.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/%E5%9B%BE%E7%89%8732.png" class="lazyload"></a></p><p><a href="/images/%E5%9B%BE%E7%89%8733.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/%E5%9B%BE%E7%89%8733.png" class="lazyload"></a></p><p><a href="/images/%E5%9B%BE%E7%89%8734.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/%E5%9B%BE%E7%89%8734.png" class="lazyload"></a></p><p><a href="/images/%E5%9B%BE%E7%89%8735.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/%E5%9B%BE%E7%89%8735.png" class="lazyload"></a></p><p><a href="/images/%E5%9B%BE%E7%89%8736.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/%E5%9B%BE%E7%89%8736.png" class="lazyload"></a></p><p><strong>28. 安装完成</strong></p><p><a href="/images/%E5%9B%BE%E7%89%8737.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/%E5%9B%BE%E7%89%8737.png" class="lazyload"></a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 虚拟机 </tag>
            
            <tag> Linux </tag>
            
            <tag> ContOS </tag>
            
            <tag> Win10 </tag>
            
            <tag> 部署 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 虚拟机安装（一）</title>
      <link href="/2020/01/11/Linux%20%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85VMware%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2020/01/11/Linux%20%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85VMware%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="主机的三个概念"><a href="#主机的三个概念" class="headerlink" title="主机的三个概念"></a>主机的三个概念</h2><ol><li>主机：这个概念是相对于子机而言的，比如安装有虚拟机的话，那么相对于虚拟机而言，正在使用的计算机就是宿主机，虚拟机是安装在主机上的，必须在主机上才能运行，主机就是一个“宿主”。</li><li>虚拟机（Virtual Machine）：指通过软件模拟的具有完整硬件系统功能的、运行在一个完全隔离环境中的完整计算机系统。</li><li>客户机：通过虚拟机安装的一个完整的计算机系统。</li></ol><h2 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h2><blockquote><p>官网下载：<a href="https://download3.vmware.com/software/wkst/file/VMware-workstation-full-15.1.0-13591040.exe" target="_blank" rel="noopener">https://download3.vmware.com/software/wkst/file/VMware-workstation-full-15.1.0-13591040.exe</a><br>个人网盘下载：11.5</p></blockquote><h2 id="秘钥"><a href="#秘钥" class="headerlink" title="秘钥"></a>秘钥</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">YG5H2-ANZ0H-M8ERY-TXZZZ-YKRV8（亲测可用，2019年5月18日）</span><br><span class="line"></span><br><span class="line">UG5J2-0ME12-M89WY-NPWXX-WQH88</span><br><span class="line"></span><br><span class="line">UA5DR-2ZD4H-089FY-6YQ5T-YPRX6</span><br><span class="line"></span><br><span class="line">GA590-86Y05-4806Y-X4PEE-ZV8E0</span><br><span class="line"></span><br><span class="line">ZF582-0NW5N-H8D2P-0XZEE-Z22VA</span><br><span class="line"></span><br><span class="line">YA18K-0WY8P-H85DY-L4NZG-X7RAD</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 虚拟机 </tag>
            
            <tag> Linux </tag>
            
            <tag> ContOS </tag>
            
            <tag> Win10 </tag>
            
            <tag> 部署 </tag>
            
            <tag> WMware </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo-theme-butterfly安装文档</title>
      <link href="/2020/01/09/Hexo%E4%B9%8BButterfly-themes%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/"/>
      <url>/2020/01/09/Hexo%E4%B9%8BButterfly-themes%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Butterfly已经升级到V2.1.0</p><p>如果升级到hexo 4.2.0 ，会出现报错</p><blockquote><p>Error: Cannot find module ‘cheerio’</p></blockquote><p>请在博客根目录安装cheerio</p><blockquote><p>npm install <a href="mailto:cheerio@0.22.0">cheerio@0.22.0</a> –save</p></blockquote><p>关于主题自定义的问题，建议仔细观察主题代码的写法，自己动手操作，不懂的可以<a href="https://www.google.com/" target="_blank" rel="noopener">Google</a>，我不一定会回答你的问题，请见谅。</p><p>如果你对主题安装有疑问或者发现bugs，请点击<a href="https://github.com/jerryc127/hexo-theme-butterfly/issues" target="_blank" rel="noopener">这里</a>反馈/询问</p><p>很多人希望能有交流平臺可以进行讨论。因此，我开通了一个Telegram群，有兴趣的可以加入。<br><a href="https://t.me/hexo_butterfly" target="_blank" rel="noopener">https://t.me/hexo_butterfly</a></p><p>本教程更新于2019年01月04日</p><h1 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a><a href="#快速開始" title="快速开始"></a>快速开始</h1><p><code>hexo-theme-butterfly</code>是基于<a href="https://github.com/Molunerfinn" target="_blank" rel="noopener">Molunerfinn</a>的<a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener">hexo-theme-melody</a>的基础上进行开发的。<br>文档也是在<a href="https://molunerfinn.com/hexo-theme-melody-doc/" target="_blank" rel="noopener">hexo-theme-melody</a>的文档基础上修改。因为一些配置变更导致与原主题配置上有部分区别。故如果安装<code>hexo-theme-butterfly</code>主题，请参考这篇文档。</p><h2 id="主题安装和升级"><a href="#主题安装和升级" class="headerlink" title="主题安装和升级"></a><a href="#主題安裝和升級" title="主题安装和升级"></a>主题安装和升级</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a><a href="#安裝" title="安装"></a>安装</h3><p>在你的博客根目录里</p><p>Code</p><p>1  </p><p>git clone -b master <a href="https://github.com/jerryc127/hexo-theme-butterfly.git" target="_blank" rel="noopener">https://github.com/jerryc127/hexo-theme-butterfly.git</a> themes/Butterfly  </p><p>如果想要安装比较新的dev分支，可以</p><p>Code</p><p>1  </p><p>git clone -b dev <a href="https://github.com/jerryc127/hexo-theme-butterfly.git" target="_blank" rel="noopener">https://github.com/jerryc127/hexo-theme-butterfly.git</a> themes/Butterfly  </p><h3 id="应用主题"><a href="#应用主题" class="headerlink" title="应用主题"></a><a href="#應用主題" title="应用主题"></a>应用主题</h3><p>修改站点配置文件<code>_config.yml</code>，把主题改为<code>Butterfly</code></p><p>yaml</p><p>1  </p><p>theme: Butterfly  </p><blockquote><p>如果你没有 pug 以及 stylus 的渲染器，请下载安装： <code>npm install hexo-renderer-pug hexo-renderer-stylus --save</code> or <code>yarn add hexo-renderer-pug hexo-renderer-stylus</code></p></blockquote><h3 id="平滑升级"><a href="#平滑升级" class="headerlink" title="平滑升级"></a><a href="#平滑升級" title="平滑升级"></a>平滑升级</h3><p>为了主题的平滑升级, <code>Butterfly</code> 使用了 <a href="https://hexo.io/docs/data-files.html" target="_blank" rel="noopener">data files</a>特性。</p><p>推荐把主题默认的配置文件<code>_config.yml</code>复製到 Hexo 工作目录下的<code>source/_data/butterfly.yml</code>，如果<code>source/_data</code>的目录不存在那就创建一个。</p><blockquote><p>注意，如果你创建了<code>butterfly.yml</code>, 它将会替换主题默认配置文件<code>_config.yml</code>里的配置项 (<strong>不是合併而是替换</strong>), 之后你就只需要通过<code>git pull</code>的方式就可以平滑地升级 <code>theme-butterfly</code>了。</p></blockquote><h1 id="主题页面"><a href="#主题页面" class="headerlink" title="主题页面"></a><a href="#主題頁面" title="主题页面"></a>主题页面</h1><h2 id="Page-Front-matter"><a href="#Page-Front-matter" class="headerlink" title="Page Front-matter"></a><a href="#Page-Front-matter" title="Page Front-matter"></a>Page Front-matter</h2><p>Markdown</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10  </p><p>-–<br>title:<br>date:<br>type: （tags,link,categories这三个页面需要配置）<br>comments: (是否需要显示评论，默认true)<br>description:<br>top_img: (设置顶部图)<br>mathjax:<br>katex:<br>-–  </p><h2 id="Post-Front-matter"><a href="#Post-Front-matter" class="headerlink" title="Post Front-matter"></a><a href="#Post-Front-matter" title="Post Front-matter"></a>Post Front-matter</h2><p>Markdown</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17  </p><p>-–<br>title:<br>date:<br>tags:<br>categories:<br>keywords:<br>description:<br>top_img: （除非特定需要，可以不写）<br>comments  是否显示评论（除非设置false,可以不写）<br>cover:  缩略图<br>toc:  是否显示toc （除非特定文章设置，可以不写）<br>toc_number: 是否显示toc数字 （除非特定文章设置，可以不写）<br>copyright: 是否显示版权 （除非特定文章设置，可以不写）<br>mathjax:<br>katex:<br>hide:<br>-–  </p><h2 id="标籤页"><a href="#标籤页" class="headerlink" title="标籤页"></a><a href="#標籤頁" title="标籤页"></a>标籤页</h2><ol><li><p>前往你的 Hexo 博客的根目录</p></li><li><p>输入<code>hexo new page tags</code></p></li><li><p>你会找到<code>source/tags/index.md</code>这个文件</p></li><li><p>修改这个文件：</p></li></ol><p>Markdown</p><p>1<br>2<br>3<br>4<br>5  </p><p>-–<br>title: 标籤<br>date: 2018-01-05 00:00:00<br>type: “tags”<br>-–  </p><h2 id="分类页"><a href="#分类页" class="headerlink" title="分类页"></a><a href="#分類頁" title="分类页"></a>分类页</h2><ol><li><p>前往你的 Hexo 博客的根目录</p></li><li><p>输入<code>hexo new page categories</code></p></li><li><p>你会找到<code>source/categories/index.md</code>这个文件</p></li><li><p>修改这个文件：</p></li></ol><p>Markdown</p><p>1<br>2<br>3<br>4<br>5  </p><p>-–<br>title: 分类<br>date: 2018-01-05 00:00:00<br>type: “categories”<br>-–  </p><h2 id="友情链接"><a href="#友情链接" class="headerlink" title="友情链接"></a><a href="#友情鏈接" title="友情链接"></a>友情链接</h2><p>为你的博客创建一个友情链接！</p><h3 id="创建友情链接页面"><a href="#创建友情链接页面" class="headerlink" title="创建友情链接页面"></a><a href="#創建友情鏈接頁面" title="创建友情链接页面"></a>创建友情链接页面</h3><ol><li>前往你的 Hexo 博客的根目录</li><li>输入 <code>hexo new page link</code></li><li>你会找到<code>source/link/index.md</code>这个文件</li><li>修改这个文件：</li></ol><p>Markdown</p><p>1<br>2<br>3<br>4<br>5  </p><p>-–<br>title: 友情链接<br>date: 2018-06-07 22:17:49<br>type: “link”<br>-–  </p><h3 id="友情链接添加"><a href="#友情链接添加" class="headerlink" title="友情链接添加"></a><a href="#友情鏈接添加" title="友情链接添加"></a>友情链接添加</h3><p>在Hexo博客目录中的<code>source/_data</code>，创建一个文件<code>link.yml</code></p><p>yml</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27  </p><p>class:<br> class_name: 友情链接<br> link_list:<br> 1:<br> name: xxx<br> link: <a href="https://blog.xxx.com" target="_blank" rel="noopener">https://blog.xxx.com</a><br> avatar: <a href="https://cdn.xxxxx.top/avatar.png" target="_blank" rel="noopener">https://cdn.xxxxx.top/avatar.png</a><br> descr: xxxxxxx<br> 2:<br> name: xxxxxx<br> link: <a href="https://www.xxxxxxcn/" target="_blank" rel="noopener">https://www.xxxxxxcn/</a><br> avatar: <a href="https://xxxxx/avatar.png" target="_blank" rel="noopener">https://xxxxx/avatar.png</a><br> descr: xxxxxxx   </p><p> class2:<br> class_name: 链接无效<br> link_list:<br> 1:<br> name: 梦xxx<br> link: <a href="https://blog.xxx.com" target="_blank" rel="noopener">https://blog.xxx.com</a><br> avatar: <a href="https://xxxx/avatar.png" target="_blank" rel="noopener">https://xxxx/avatar.png</a><br> descr: xxxx<br> 2:<br> name: xx<br> link: <a href="https://www.axxxx.cn/" target="_blank" rel="noopener">https://www.axxxx.cn/</a><br> avatar: <a href="https://x" target="_blank" rel="noopener">https://x</a><br> descr: xx  </p><h3 id="友情链接界面设置"><a href="#友情链接界面设置" class="headerlink" title="友情链接界面设置"></a><a href="#友情鏈接界面設置" title="友情链接界面设置"></a>友情链接界面设置</h3><p>需要添加友情链接，可以在<code>Butterfly.yml</code>配置<br>可在友情链接上写上自己的个人资料，方便其他人添加。</p><p>yaml</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8  </p><p>Flink:<br> headline: 友情链接<br> info_headline: 我的Blog资料<br> name: Blog 名字： JerryC<br> address: Blog 地址： <a href="https://jerryc.me/" target="_blank" rel="noopener">https://jerryc.me/</a><br> avatar: Blog 头像： <a href="https://jerryc.me/img/avatar.png" target="_blank" rel="noopener">https://jerryc.me/img/avatar.png</a><br> info: Blog 简介： 今日事,今日毕<br> comment: 如果需要交换友链,请留言  </p><p><a href="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-flink-headline.png" target="_blank" rel="noopener"><img alt data-src="/img/loading.gif" class="lazyload"></a><br><a href="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-flink.png" target="_blank" rel="noopener"><img alt data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-flink.png" class="lazyload"></a></p><h2 id="音乐"><a href="#音乐" class="headerlink" title="音乐"></a><a href="#音樂" title="音乐"></a>音乐</h2><p>音乐界面使用了插件<a href="https://github.com/MoePlayer/hexo-tag-aplayer" target="_blank" rel="noopener">hexo-tag-aplayer</a>。<br>使用方法请参考插件的文档</p><p>音乐页面只是普通的page页，按普通页面操作生成就行。</p><h2 id="电影"><a href="#电影" class="headerlink" title="电影"></a><a href="#電影" title="电影"></a>电影</h2><p>电影界面使用了插件<a href="https://github.com/mythsman/hexo-douban" target="_blank" rel="noopener">hexo-douban</a>。<br>使用方法请参考插件的文档。</p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a><a href="#配置" title="配置"></a>配置</h1><h2 id="配置文件説明"><a href="#配置文件説明" class="headerlink" title="配置文件説明"></a><a href="#配置文件説明" title="配置文件説明"></a>配置文件説明</h2><ul><li>站点配置文件<code>_config.yml</code>是 hexo 工作目录下的主配置文件(还不知道是哪里的，自己google)</li><li><code>butterfly.yml</code> 是 <code>Butterfly</code> 的配置文件。它需要你手动将主题目录下的<code>_config.yml</code>文件复製到 hexo 工作目录的<code>source/_data/butterfly.yml</code>中。如果文件或者文件夹不存在，需要手动创建。</li></ul><h2 id="语言"><a href="#语言" class="headerlink" title="语言"></a><a href="#語言" title="语言"></a>语言</h2><p>修改站点配置文件 <code>_config.yml</code></p><p>默认语言是 en</p><p>主题支持三种语言</p><ul><li>default(en)</li><li>zh-CN (简体中文)</li><li>zh-TW (繁体中文)</li></ul><h2 id="网站资料"><a href="#网站资料" class="headerlink" title="网站资料"></a><a href="#網站資料" title="网站资料"></a>网站资料</h2><p>修改网站各种资料，例如标题、副标题和邮箱等个人资料，请修改博客根目录的<code>_config.yml</code></p><p><a href="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/20191120000444.png" target="_blank" rel="noopener"><img alt data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/20191120000444.png" class="lazyload"></a></p><h2 id="导航菜单"><a href="#导航菜单" class="headerlink" title="导航菜单"></a><a href="#導航菜單" title="导航菜单"></a>导航菜单</h2><p>配置<code>butterfly.yml</code></p><p>yaml</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10  </p><p>menu:<br> Home: / || fa fa-home<br> Archives: /archives/ || fa fa-archive<br> Tags: /tags/ || fa fa-tags<br> Categories: /categories/ || fa fa-folder-open<br> Link: /link/ || fa fa-link<br> About: /about/ || fa fa-heart<br> List||fa fa-list:<br> - Music || /music/ || fa fa-music<br> - Movie || /movies/ || fa fa-film  </p><blockquote><p>必须是 <code>/xxx/</code>，后面<code>||</code>分开，然后写图标名。菜单名称可自己修改</p><p>格式：</p><p>显示名称:</p><p>路径||icon</p><p>sub-menu格式</p><p>名称||icon:</p><ul><li>名称 || 路径 || icon</li></ul></blockquote><p><strong>注意：</strong> 导航的文字可自行更改</p><p>例如：</p><p>markdown</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11  </p><p>menu:<br> 首页: / || fa fa-home<br> 时间轴: /archives/ || fa fa-archive<br> 标籤: /tags/ || fa fa-tags<br> 分类: /categories/ || fa fa-folder-open<br> 清单||fa fa-heartbeat:  </p><ul><li>音乐 || /music/ || fa fa-music  </li><li>照片 || /Gallery/ || fa fa-picture-o  </li><li>电影 || /movies/ || fa fa-film<br>友链: /link/ || fa fa-link<br>关于: /about/ || fa fa-heart  </li></ul><p><a href="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-menu.png" target="_blank" rel="noopener"><img alt data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-menu.png" class="lazyload"></a></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><a href="#代碼" title="代码"></a>代码</h2><h3 id="代码高亮主题"><a href="#代码高亮主题" class="headerlink" title="代码高亮主题"></a><a href="#代碼高亮主題" title="代码高亮主题"></a>代码高亮主题</h3><p><code>Butterfly</code> 支持了 <a href="https://github.com/equinusocio/material-theme" target="_blank" rel="noopener">Material Theme</a>全部 5 种代码高亮样式：</p><ul><li>default</li><li>darker</li><li>pale night</li><li>light</li><li>ocean</li></ul><p>配置<code>butterfly.yml</code></p><p>yaml</p><p>1  </p><p>highlight_theme: light  </p><blockquote><p>default</p></blockquote><p><a href="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-code-default.png" target="_blank" rel="noopener"><img alt data-src="/img/loading.gif" class="lazyload"></a></p><blockquote><p>darker</p></blockquote><p><a href="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-code-darker.png" target="_blank" rel="noopener"><img alt data-src="/img/loading.gif" class="lazyload"></a></p><blockquote><p>pale night</p></blockquote><p><a href="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-code-pale-night.png" target="_blank" rel="noopener"><img alt data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-code-pale-night.png" class="lazyload"></a></p><blockquote><p>light</p></blockquote><p><a href="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-code-light.png" target="_blank" rel="noopener"><img alt data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-code-light.png" class="lazyload"></a></p><blockquote><p>ocean</p></blockquote><p><a href="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-highlight-ocean.png" target="_blank" rel="noopener"><img alt data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-highlight-ocean.png" class="lazyload"></a></p><h3 id="代码复製"><a href="#代码复製" class="headerlink" title="代码复製"></a><a href="#代碼複製" title="代码复製"></a>代码复製</h3><p>主题支持代码复製功能</p><p>配置<code>butterfly.yml</code></p><p>yaml</p><p>1  </p><p>highlight_copy: true  </p><p><a href="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-code-copy.png" target="_blank" rel="noopener"><img alt data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-code-copy.png" class="lazyload"></a></p><h3 id="代码框展开-关闭"><a href="#代码框展开-关闭" class="headerlink" title="代码框展开/关闭"></a><a href="#代碼框展開-關閉" title="代码框展开/关闭"></a>代码框展开/关闭</h3><p>在默认情况下，代码框自动展开，可设置是否所有代码框都关闭状态，点击<code>&gt;</code>可展开代码</p><p>配置<code>butterfly.yml</code></p><p>yaml</p><p>1  </p><p>highlight_shrink: true #代码框不展开，需点击 ‘&gt;’ 打开  </p><p><code>highlight_shrink: true</code></p><p><a href="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-highlight-shrink-true.png" target="_blank" rel="noopener"><img alt data-src="/img/loading.gif" class="lazyload"></a></p><p><code>highlight_shrink: false</code></p><p><a href="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-highlight-shrink-false.png" target="_blank" rel="noopener"><img alt data-src="/img/loading.gif" class="lazyload"></a></p><p><code>highlight_shrink: none</code></p><p><a href="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-docs-highlight-shirk-none.png" target="_blank" rel="noopener"><img alt data-src="/img/loading.gif" class="lazyload"></a></p><h3 id="代码换行"><a href="#代码换行" class="headerlink" title="代码换行"></a><a href="#代碼換行" title="代码换行"></a>代码换行</h3><p>在默认情况下，<code>hexo-highlight</code>在编译的时候不会实现代码自动换行。如果你不希望在代码块的区域里有横向滚动条的话，那么你可以考虑开启这个功能。</p><p>配置<code>butterfly.yml</code></p><p>yaml</p><p>1  </p><p>code_word_wrap: true  </p><p>然后找到你站点的 Hexo 配置文件<code>_config.yml</code>，将<code>line_number</code>改成<code>false</code>:</p><p>yaml</p><p>1<br>2<br>3<br>4<br>5  </p><p>highlight:<br> enable: true<br> line_number: false<br> auto_detect: false<br> tab_replace:  </p><blockquote><p>设置<code>code_word_wrap</code>之前:</p></blockquote><p><a href="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-code-word-wrap-before.png" target="_blank" rel="noopener"><img alt data-src="/img/loading.gif" class="lazyload"></a></p><blockquote><p>设置<code>code_word_wrap</code>之后:</p></blockquote><p><a href="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-code-word-wrap-after.png" target="_blank" rel="noopener"><img alt data-src="/img/loading.gif" class="lazyload"></a></p><h2 id="社交图标"><a href="#社交图标" class="headerlink" title="社交图标"></a><a href="#社交圖標" title="社交图标"></a>社交图标</h2><p>Butterfly支持 <a href="https://fontawesome.com/v4.7.0/" target="_blank" rel="noopener">font-awesome v4</a>和 <a href="https://fontawesome.com/icons?from=io" target="_blank" rel="noopener">font-awesome v5</a>. 如需开启<a href="https://fontawesome.com/icons?from=io" target="_blank" rel="noopener">font-awesome v5</a>,需要在<code>Butterfly.yml</code>上开启</p><p>yaml</p><p>1<br>2<br>3<br>4  </p><p>CDN_USE:<br> css:<br> - <a href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css" target="_blank" rel="noopener">https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css</a><br> - <a href="https://use.fontawesome.com/releases/v5.8.1/css/all.css" target="_blank" rel="noopener">https://use.fontawesome.com/releases/v5.8.1/css/all.css</a>  </p><p>无论V4还是V5,书写格式都是一样的<code>图标名：url</code></p><p>yaml</p><p>1<br>2<br>3  </p><p>social:<br> fa fa-github: <a href="https://github.com/jerryc127" target="_blank" rel="noopener">https://github.com/jerryc127</a><br> fa fa-rss: /atom.xml  </p><p>图标名可在这寻找</p><p><a href="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-fontawesome.png" target="_blank" rel="noopener"><img alt data-src="/img/loading.gif" class="lazyload"></a></p><p>PC:</p><p><a href="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-social-icon-pc.png" target="_blank" rel="noopener"><img alt data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-social-icon-pc.png" class="lazyload"></a></p><p>Mobile:</p><p><a href="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-socila-icon-mobile.png" target="_blank" rel="noopener"><img alt="1560603353743" title="1560603353743" data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-socila-icon-mobile.png" class="lazyload"></a></p><h2 id="主页文章节选-自动节选和文章页description"><a href="#主页文章节选-自动节选和文章页description" class="headerlink" title="主页文章节选(自动节选和文章页description)"></a><a href="#主頁文章節選-自動節選和文章頁description" title="主页文章节选(自动节选和文章页description)"></a>主页文章节选(自动节选和文章页description)</h2><p>因为主题UI的关係，<code>主页文章节选</code>只支持<code>自动节选</code>和<code>文章页description</code>。优先选择<code>自动节选</code>。</p><p>在<code>butterfly.yml</code>里可以开启<code>auto_excerpt</code>的选项，你的文章将会在自动截取部分显示在主页。（默认显示150个字）。</p><p>yaml</p><p>1<br>2<br>3  </p><p>auto_excerpt:<br> enable: true<br> length: 150  </p><p>如果没有开启<code>自动节选</code>，则会显示文章页front-matter里面设置的<code>description</code>。</p><p><a href="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-post-description.png" target="_blank" rel="noopener"><img alt data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-post-description.png" class="lazyload"></a></p><blockquote><p>注意：如果开启了自动节选功能，代码块的显示将有可能不正常。</p></blockquote><h2 id="顶部图"><a href="#顶部图" class="headerlink" title="顶部图"></a><a href="#頂部圖" title="顶部图"></a>顶部图</h2><p><code>顶部图</code>有2种配置：具体url 和（留空，true和false，三个效果一样）</p><h3 id="page页"><a href="#page页" class="headerlink" title="page页"></a><a href="#page頁" title="page页"></a>page页</h3><h4 id="当具体url时"><a href="#当具体url时" class="headerlink" title="当具体url时"></a><a href="#當具體url時" title="当具体url时"></a>当具体url时</h4><p>主页的顶部图可以在<code>Butterfly.yml</code>设置<code>index_img</code></p><p>archives页的顶部图可以在<code>Butterfly.yml</code>设置<code>archive_img</code></p><p>其他<code>page</code>页的顶部图可以在各自的md页面设置<code>front-matter</code>中的<code>top_img</code></p><blockquote><p>页面如果没有设置各自的<code>top_img</code>，则会显示<code>default_top_img</code>图片</p></blockquote><h4 id="当顶部图留空，true和false"><a href="#当顶部图留空，true和false" class="headerlink" title="当顶部图留空，true和false"></a><a href="#當頂部圖留空，true和false" title="当顶部图留空，true和false"></a>当顶部图留空，true和false</h4><p>主页会显示纯颜色的顶部图</p><p>其他page的顶部图没有设置时，也会显示纯颜色的顶部图</p><h3 id="post页"><a href="#post页" class="headerlink" title="post页"></a><a href="#post頁" title="post页"></a>post页</h3><p><code>post</code>页的顶部图会优先显示各自<code>front-matter</code>中的<code>top_img</code>,如果没有设置，则会缩略图（即各自<code>front-matter</code>中的<code>cover</code>)，如果没有则会显示显示<code>default_top_img</code>图片</p><h2 id="文章相关项"><a href="#文章相关项" class="headerlink" title="文章相关项"></a><a href="#文章相關項" title="文章相关项"></a>文章相关项</h2><p>这个选项是用来显示文章的相关信息的。</p><p>配置<code>butterfly.yml</code></p><p>yaml</p><p>1<br>2<br>3<br>4  </p><p>post_meta:<br> date_type: both #or created or updated 文章日期是创建日或者更新日或都显示<br> categories: true # or false 是否显示分类<br> tags: true # or false 是否显示标籤  </p><p>在文章顶部的资料，</p><p><code>date_type</code>: 可设置文章日期显示创建日期(<code>created</code>)或者更新日期(<code>updated</code>)或者两种都显示(<code>both</code>)</p><p><code>categories</code> 是否显示分类</p><p><a href="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-post-info.png" target="_blank" rel="noopener"><img alt data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-post-info.png" class="lazyload"></a></p><p><code>tags</code>是否显示标籤</p><p><a href="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-post-tag.png" target="_blank" rel="noopener"><img alt data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-post-tag.png" class="lazyload"></a></p><h2 id="文章版权"><a href="#文章版权" class="headerlink" title="文章版权"></a><a href="#文章版權" title="文章版权"></a>文章版权</h2><p>为你的博客文章展示文章版权和许可协议。</p><p>配置<code>butterfly.yml</code></p><p>yaml</p><p>1<br>2<br>3<br>4  </p><p>post_copyright:<br> enable: true<br> license: CC BY-NC-SA 4.0<br> license_url: <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">https://creativecommons.org/licenses/by-nc-sa/4.0/</a>  </p><p>如果有文章（例如：转载文章）不需要显示版权，可以在文章Front-matter单独设置</p><p>yaml</p><p>1  </p><p>copyright: false  </p><p><strong>版权显示截图</strong></p><p><a href="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-post-copyright.png" target="_blank" rel="noopener"><img alt data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-post-copyright.png" class="lazyload"></a></p><h2 id="文章打赏"><a href="#文章打赏" class="headerlink" title="文章打赏"></a><a href="#文章打賞" title="文章打赏"></a>文章打赏</h2><p>在你每篇文章的结尾，可以添加打赏按钮。相关二维码可以自行配置</p><p>配置<code>butterfly.yml</code></p><p>yaml</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9  </p><p>reward:<br> enable: true<br> QR_code:<br> - itemlist:<br> img: /img/wechat.jpg<br> text: 微信<br> - itemlist:<br> img: /img/alipay.jpg<br> text: 支付宝  </p><p><a href="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-post-donate.png" target="_blank" rel="noopener"><img alt data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-post-donate.png" class="lazyload"></a></p><h2 id="文章封面"><a href="#文章封面" class="headerlink" title="文章封面"></a><a href="#文章封面" title="文章封面"></a>文章封面</h2><p>文章的markdown文档上,在<code>Front-matter</code>添加<code>cover</code>,并填上要显示的图片地址。<br>如果不配置<code>cover</code>,可以设置显示默认的cover.</p><p>配置<code>butterfly.yml</code></p><p>yaml</p><p>1  </p><p>default_cover: <a href="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default\_bg.png" target="_blank" rel="noopener">https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default\_bg.png</a>  </p><p>当配置多张图片时,会随机选择一张作爲cover.此时写法应爲</p><p>yaml</p><p>1<br>2<br>3<br>4  </p><p>default_cover:<br> - <a href="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default\_bg.png" target="_blank" rel="noopener">https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default\_bg.png</a><br> - <a href="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default\_bg2.png" target="_blank" rel="noopener">https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default\_bg2.png</a><br> - <a href="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default\_bg3.png" target="_blank" rel="noopener">https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default\_bg3.png</a>  </p><p><a href="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-post-cover.png" target="_blank" rel="noopener"><img alt data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-post-cover.png" class="lazyload"></a><br><a href="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-post-cover-show.png" target="_blank" rel="noopener"><img alt data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-post-cover-show.png" class="lazyload"></a></p><h2 id="文章隐藏"><a href="#文章隐藏" class="headerlink" title="文章隐藏"></a><a href="#文章隱藏" title="文章隐藏"></a>文章隐藏</h2><blockquote><p>2.1.0版本以上支持</p></blockquote><p>参考_printempw/hexo-hide-posts_，如果想要隐藏文章，可以在文章的Front-matter添加</p><p>Code</p><p>1  </p><p>hide: true  </p><h2 id="头像"><a href="#头像" class="headerlink" title="头像"></a><a href="#頭像" title="头像"></a>头像</h2><p>配置<code>butterfly.yml</code></p><p>yaml</p><p>1  </p><p>avatar: <a href="https://xxxx/avatar.png" target="_blank" rel="noopener">https://xxxx/avatar.png</a>  </p><p><a href="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-avatar.png" target="_blank" rel="noopener"><img alt data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-avatar.png" class="lazyload"></a></p><h2 id="TOC"><a href="#TOC" class="headerlink" title="TOC"></a><a href="#TOC" title="TOC"></a>TOC</h2><p>在文章页，会有一个目录，用于显示TOC。 手机端默认显示按钮。</p><p>配置<code>butterfly.yml</code></p><p>yaml</p><p>1<br>2<br>3  </p><p>toc:<br> enable: true<br> number: true   #显示章节数字  </p><p><strong>PC</strong><br><a href="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-toc-pc.png" target="_blank" rel="noopener"><img alt data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-toc-pc.png" class="lazyload"></a></p><p><strong>Mobile</strong><br><a href="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-docs-mobile-toc-new.png" target="_blank" rel="noopener"><img alt data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-docs-mobile-toc-new.png" class="lazyload"></a></p><h3 id="为特定的文章配置是否显示TOC和特定的目录章节数字"><a href="#为特定的文章配置是否显示TOC和特定的目录章节数字" class="headerlink" title="为特定的文章配置是否显示TOC和特定的目录章节数字"></a><a href="#為特定的文章配置是否顯示TOC和特定的目錄章節數字" title="为特定的文章配置是否显示TOC和特定的目录章节数字"></a>为特定的文章配置是否显示TOC和特定的目录章节数字</h3><p>在你的文章<code>md</code>文件的头部，加入<code>toc_number</code>和<code>toc</code>项，并配置<code>true</code>或者<code>false</code>即可。</p><p><code>toc</code>是否显示文章TOC</p><p><code>toc_number</code> 是否显示章节数</p><p>配置之后你的特定的文章将会拥有它自己的目录数字的显示与否，而不会受全局的配置影响。</p><blockquote><p><code>enable: true</code></p></blockquote><p><a href="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-toc-true.png" target="_blank" rel="noopener"><img alt data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-toc-true.png" class="lazyload"></a></p><blockquote><p><code>number: false</code></p></blockquote><p><a href="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-toc-number-false.png" target="_blank" rel="noopener"><img alt data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-toc-number-false.png" class="lazyload"></a></p><h3 id="设置是否自动打开TOC"><a href="#设置是否自动打开TOC" class="headerlink" title="设置是否自动打开TOC"></a><a href="#設置是否自動打開TOC" title="设置是否自动打开TOC"></a>设置是否自动打开TOC</h3><p>可选择进入文章页面时，是否自动打开sidebar显示TOC</p><p>yaml</p><p>1<br>2  </p><p>auto_open_sidebar:<br> enable: true  </p><h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a><a href="#相關文章" title="相关文章"></a>相关文章</h2><p>相关文章推荐的原理是根据文章tags的比重来推荐</p><p>配置<code>butterfly.yml</code></p><p>yaml</p><p>1<br>2<br>3<br>4  </p><p>related_post:<br> enable: true<br> limit: 6 # 显示推荐文章数目<br> date_type: created # or created or updated 文章日期显示创建日或者更新日  </p><p><a href="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-docs-releatedpost.png" target="_blank" rel="noopener"><img alt data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-docs-releatedpost.png" class="lazyload"></a></p><h2 id="Footer-设置"><a href="#Footer-设置" class="headerlink" title="Footer 设置"></a><a href="#Footer-設置" title="Footer 设置"></a>Footer 设置</h2><h3 id="博客年份"><a href="#博客年份" class="headerlink" title="博客年份"></a><a href="#博客年份" title="博客年份"></a>博客年份</h3><p><code>since</code>是一个来展示你站点起始时间的选项。它位于页面的最底部。</p><p>配置<code>butterfly.yml</code></p><p>yaml</p><p>1  </p><p>since: 2018  </p><p><a href="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-since.png" target="_blank" rel="noopener"><img alt data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-since.png" class="lazyload"></a></p><h3 id="页脚自定义文本"><a href="#页脚自定义文本" class="headerlink" title="页脚自定义文本"></a><a href="#頁腳自定義文本" title="页脚自定义文本"></a>页脚自定义文本</h3><p><code>footer_custom_text</code>是一个给你用来在页脚自定义文本的选项。通常你可以在这里写声明文本等。支持 HTML。</p><p>配置<code>butterfly.yml</code></p><p>yaml</p><p>1  </p><p>footer_custom_text: Hi, welcome to my <a href="https://jerryc.me/" target="_blank" rel="noopener">blog</a>!  </p><p><a href="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-footer-text.png" target="_blank" rel="noopener"><img alt data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-footer-text.png" class="lazyload"></a></p><h3 id="ICP"><a href="#ICP" class="headerlink" title="ICP"></a><a href="#ICP" title="ICP"></a>ICP</h3><p>对于部分有备案的域名，可以在ICP配置显示。</p><p>配置<code>butterfly.yml</code></p><p>yaml</p><p>1<br>2<br>3<br>4<br>5  </p><p>ICP:<br> enable: true<br> url: <a href="http://www.beian.miit.gov.cn/state/outPortal/loginPortal.action" target="_blank" rel="noopener">http://www.beian.miit.gov.cn/state/outPortal/loginPortal.action</a><br> text: 粤ICP备xxxx<br> icon: /img/icp.png  </p><h2 id="右下角按钮"><a href="#右下角按钮" class="headerlink" title="右下角按钮"></a><a href="#右下角按鈕" title="右下角按钮"></a>右下角按钮</h2><h3 id="简繁转换"><a href="#简繁转换" class="headerlink" title="简繁转换"></a><a href="#簡繁轉換" title="简繁转换"></a>简繁转换</h3><p>简体繁体互换</p><p>右下角会有简繁转换按钮。</p><p>配置<code>butterfly.yml</code></p><p>yaml</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14  </p><p>translate:<br> enable: true<br> # 默认按钮显示文字(网站是简体，应设置为’default: 繁’)<br> default: 简<br> #网站默认语言，1: 繁体中文, 2: 简体中文<br> defaultEncoding: 1<br> #延迟时间,若不在前, 要设定延迟翻译时间, 如100表示100ms,默认为0<br> translateDelay: 0<br> #博客网址<br> cookieDomain: “<a href="https://jerryc.me/&quot;" target="_blank" rel="noopener">https://jerryc.me/&quot;</a><br> #当文字是简体时，按钮显示的文字<br> msgToTraditionalChinese: “繁”<br> #当文字是繁体时，按钮显示的文字<br> msgToSimplifiedChinese: “简”  </p><blockquote><p>简体</p></blockquote><p><a href="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-simp.png" target="_blank" rel="noopener"><img alt data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-simp.png" class="lazyload"></a></p><blockquote><p>繁体</p></blockquote><p><a href="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-tranditional.png" target="_blank" rel="noopener"><img alt data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-tranditional.png" class="lazyload"></a></p><h3 id="夜间模式"><a href="#夜间模式" class="headerlink" title="夜间模式"></a><a href="#夜間模式" title="夜间模式"></a>夜间模式</h3><p>右下角会有夜间模式按钮</p><p>配置<code>butterfly.yml</code></p><p>yaml</p><p>1<br>2<br>3  </p><p># 夜间模式<br>darkmode:<br> enable: true  </p><p><a href="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-dark-mode.png" target="_blank" rel="noopener"><img alt data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-dark-mode.png" class="lazyload"></a></p><blockquote><p>V2.0.0 开始增加一个选项，可开啓自动切换light mode 和 dark mode</p><p>autoChangeMode: 1 跟随系统而变化，不支持的浏览器/系统将按照时间晚上6点到早上6点之间切换为 dark mode</p><p>autoChangeMode: 2 只按照时间 晚上6点到早上6点之间切换为 dark mode,其余时间为light mode</p><p>autoChangeMode: false 取消自动切换</p></blockquote><p>yaml</p><p>1<br>2  </p><p># 自动切换 dark mode和 light mode<br>autoChangeMode: false  </p><h3 id="閲读模式"><a href="#閲读模式" class="headerlink" title="閲读模式"></a><a href="#閲讀模式" title="閲读模式"></a>閲读模式</h3><p>閲读模式下会去掉除文章外的内容，避免干扰閲读。</p><p>只会出现在文章页面，右下角会有閲读模式按钮。</p><p>配置<code>butterfly.yml</code></p><p>yaml</p><p>1<br>2  </p><p>readmode:<br> enable: true  </p><p><a href="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-read-mode.png" target="_blank" rel="noopener"><img alt data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-read-mode.png" class="lazyload"></a></p><h2 id="侧边栏设置"><a href="#侧边栏设置" class="headerlink" title="侧边栏设置"></a><a href="#側邊欄設置" title="侧边栏设置"></a>侧边栏设置</h2><h3 id="侧边排版"><a href="#侧边排版" class="headerlink" title="侧边排版"></a><a href="#側邊排版" title="侧边排版"></a>侧边排版</h3><p>可自行决定哪个项目需要显示，可决定位置。</p><blockquote><p>至少需要显示一个</p></blockquote><p>配置<code>butterfly.yml</code></p><p>yaml</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9  </p><p>aside:<br> position: right # left or right<br> card_author: true<br> card_announcement: true<br> card_recent_post: true<br> card_categories: true<br> card_tags: true<br> card_archives: true<br> card_webinfo: true  </p><p><strong>left</strong><br><a href="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-aside-left.png" target="_blank" rel="noopener"><img alt data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-aside-left.png" class="lazyload"></a></p><p><strong>right</strong><br><a href="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-aside-right.png" target="_blank" rel="noopener"><img alt data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-aside-right.png" class="lazyload"></a></p><h3 id="访问人数-busuanzi-UV-和-PV"><a href="#访问人数-busuanzi-UV-和-PV" class="headerlink" title="访问人数 busuanzi (UV 和 PV)"></a><a href="#訪問人數-busuanzi-UV-和-PV" title="访问人数 busuanzi (UV 和 PV)"></a>访问人数 busuanzi (UV 和 PV)</h3><p>访问 busuanzi 的<a href="http://busuanzi.ibruce.info/" target="_blank" rel="noopener">官方网站</a>查看更多的介绍。</p><p>配置<code>butterfly.yml</code></p><p>yaml</p><p>1<br>2<br>3<br>4  </p><p>busuanzi:<br> site_uv: true<br> site_pv: true<br> page_pv: true  </p><p><a href="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-busuanzi-site-pv.png" target="_blank" rel="noopener"><img alt data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-busuanzi-site-pv.png" class="lazyload"></a></p><p><a href="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-pv.png" target="_blank" rel="noopener"><img alt data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-pv.png" class="lazyload"></a></p><h3 id="运行时间"><a href="#运行时间" class="headerlink" title="运行时间"></a><a href="#運行時間" title="运行时间"></a>运行时间</h3><p>网页已运行时间</p><p>配置<code>butterfly.yml</code></p><p>yaml</p><p>1<br>2<br>3<br>4<br>5<br>6  </p><p>runtimeshow:<br> enable: true<br> start_date: 6/7/2018 00:00:00<br> ##网页开通时间<br> #格式: 月/日/年 时间<br> #也可以写成 年/月/日 时间  </p><p><a href="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-runtime.png" target="_blank" rel="noopener"><img alt data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-runtime.png" class="lazyload"></a></p><h2 id="标籤外挂（Tag-Plugins）"><a href="#标籤外挂（Tag-Plugins）" class="headerlink" title="标籤外挂（Tag Plugins）"></a><a href="#標籤外掛（Tag-Plugins）" title="标籤外挂（Tag Plugins）"></a>标籤外挂（Tag Plugins）</h2><h3 id="Note-Bootstrap-Callout"><a href="#Note-Bootstrap-Callout" class="headerlink" title="Note (Bootstrap Callout)"></a><a href="#Note-Bootstrap-Callout" title="Note (Bootstrap Callout)"></a>Note (Bootstrap Callout)</h3><p>移植于next主题（注意，书写不是markdown规範，而是hexo特有的功能，故在其它地方会显示不出效果）</p><h4 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a><a href="#配置-1" title="配置"></a>配置</h4><p>配置<code>butterfly.yml</code></p><p>yaml</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12  </p><p>note:<br> # Note tag style values:<br> #  - simple    bs-callout old alert style. Default.<br> #  - modern    bs-callout new (v2-v3) alert style.<br> #  - flat      flat callout style with background, like on Mozilla or StackOverflow.<br> #  - disabled  disable all CSS styles import of note tag.<br> style: simple<br> icons: false<br> border_radius: 3<br> # Offset lighter of background in % for modern and flat styles (modern: -12 | 12; flat: -18 | 6).<br> # Offset also applied to label tag variables. This option can work with disabled note tag.<br> light_bg_offset: 0  </p><h4 id="用法"><a href="#用法" class="headerlink" title="用法"></a><a href="#用法" title="用法"></a>用法</h4><p>Markdown</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8  </p><div class="note \[class\] \[no-icon\]">            <p>Any content (support inline tags too.io).  </p>          </div>  <p>[class]   : default | primary | success | info | warning | danger.<br>[no-icon] : Disable icon in note.  </p><p>All parameters are optional.  </p><p>具体效果、用法可查看<a href="https://theme-next.org/docs/tag-plugins/note" target="_blank" rel="noopener">这里</a></p><h3 id="Gallery相册"><a href="#Gallery相册" class="headerlink" title="Gallery相册"></a><a href="#Gallery相冊" title="Gallery相册"></a>Gallery相册</h3><blockquote><p>2.0.0以上提供</p></blockquote><p>区别于旧版的Gallery相册,新的Gallery相册会自动根据图片长度进行排版，书写也更加方便，与markdown格式一样。可根据需要插入到相应的md。</p><p>写法:</p><p>Markdown</p><p>1<br>2<br>3  </p><div class="justified-gallery"><p>markdown 图片格式  </p>          </div>  <p>例如</p><p>Markdown</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8  </p><div class="justified-gallery"><p>![](<a href="https://gratisography.com/wp-content/uploads/2019/10/gratisography-scary-pumpkin-hand-900x600.jpg" target="_blank" rel="noopener">https://gratisography.com/wp-content/uploads/2019/10/gratisography-scary-pumpkin-hand-900x600.jpg</a>)<br>![](<a href="https://gratisography.com/wp-content/uploads/2019/10/gratisography-fresh-fish-dinner-900x600.jpg" target="_blank" rel="noopener">https://gratisography.com/wp-content/uploads/2019/10/gratisography-fresh-fish-dinner-900x600.jpg</a>)<br>![](<a href="https://gratisography.com/wp-content/uploads/2019/10/gratisography-mountain-cloud-landscape-900x600.jpg" target="_blank" rel="noopener">https://gratisography.com/wp-content/uploads/2019/10/gratisography-mountain-cloud-landscape-900x600.jpg</a>)<br>![](<a href="https://picjumbo.com/wp-content/uploads/iphone-free-stock-photos-2210x3315.jpg" target="_blank" rel="noopener">https://picjumbo.com/wp-content/uploads/iphone-free-stock-photos-2210x3315.jpg</a>)<br>![](<a href="https://picjumbo.com/wp-content/uploads/young-millennial-girl-drinking-lemonade-and-overlooking-the-city-2210x1473.jpg" target="_blank" rel="noopener">https://picjumbo.com/wp-content/uploads/young-millennial-girl-drinking-lemonade-and-overlooking-the-city-2210x1473.jpg</a>)<br>![](<a href="https://picjumbo.com/wp-content/uploads/modern-graphic-designer-essentials\_free\_stock\_photos\_picjumbo\_HNCK4919-2210x1474.jpg" target="_blank" rel="noopener">https://picjumbo.com/wp-content/uploads/modern-graphic-designer-essentials\_free\_stock\_photos\_picjumbo\_HNCK4919-2210x1474.jpg</a>)  </p>          </div>  <p><a href="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/20191101143214.png" target="_blank" rel="noopener"><img alt data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/20191101143214.png" class="lazyload"></a></p><h2 id="评论"><a href="#评论" class="headerlink" title="评论"></a><a href="#評論" title="评论"></a>评论</h2><blockquote><p>只能选择一个评论服务商</p></blockquote><h3 id="Disqus"><a href="#Disqus" class="headerlink" title="Disqus"></a><a href="#Disqus" title="Disqus"></a>Disqus</h3><p>註册 <a href="https://disqus.com/" target="_blank" rel="noopener">disqus</a>，配置你自己的 disqus，然后在<code>Butterfly</code>里开启它。</p><p>配置<code>butterfly.yml</code></p><p>yaml</p><p>1<br>2<br>3<br>4  </p><p>disqus:<br> enable: true<br> shortname:<br> count: false # top_img显示评论数  </p><p><a href="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-disqus.png" target="_blank" rel="noopener"><img alt data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-disqus.png" class="lazyload"></a></p><h3 id="Laibili（来必力）"><a href="#Laibili（来必力）" class="headerlink" title="Laibili（来必力）"></a><a href="#Laibili（來必力）" title="Laibili（来必力）"></a>Laibili（来必力）</h3><p>註册<a href="http://www.laibili.com.cn/" target="_blank" rel="noopener">来必力</a>，配置你自己的来必力设置，然后在<code>Butterfly</code>里开启它。</p><p>配置<code>butterfly.yml</code></p><p>yaml</p><p>1<br>2<br>3  </p><p>laibili:<br> enable: true<br> uid:  </p><p>laibili 的 uid 你能在这里找到:</p><p><a href="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-laibili.jpg" target="_blank" rel="noopener"><img alt data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-laibili.jpg" class="lazyload"></a></p><p><a href="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-laibili_2.png" target="_blank" rel="noopener"><img alt data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-laibili_2.png" class="lazyload"></a></p><h3 id="Gitalk"><a href="#Gitalk" class="headerlink" title="Gitalk"></a><a href="#Gitalk" title="Gitalk"></a>Gitalk</h3><p>遵循 <a href="https://github.com/gitalk/gitalk" target="_blank" rel="noopener">gitalk</a>的指示去获取你的 github Oauth 应用的 client id 和 secret 值。以及查看它的相关配置説明。</p><p>然后配置<code>butterfly.yml</code>:</p><p>yaml</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9  </p><p>gitalk:<br> enable: true<br> client_id: 你的client id<br> client_secret: 你的client secret<br> repo: 你的github仓库<br> owner: 你的github用户名<br> admin: 该仓库的拥有者或协作者<br> language: # en , zh-CN , zh-TW<br> count: false # top_img显示评论数  </p><p><a href="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-gitalk.png" target="_blank" rel="noopener"><img alt data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-gitalk.png" class="lazyload"></a></p><h3 id="Valine"><a href="#Valine" class="headerlink" title="Valine"></a><a href="#Valine" title="Valine"></a>Valine</h3><p>遵循 <a href="https://github.com/xCss/Valine" target="_blank" rel="noopener">Valine</a>的指示去配置你的 LeanCloud 应用。以及查看相应的配置説明。</p><p>然后配置<code>butterfly.yml</code>:</p><p>yaml</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13  </p><p>valine:<br> enable: false # if you want use valine,please set this value is true<br> appId: # leancloud application app id<br> appKey: # leancloud application app key<br> notify: false # valine mail notify (true/false) <a href="https://github.com/xCss/Valine/wiki" target="_blank" rel="noopener">https://github.com/xCss/Valine/wiki</a><br> verify: false # valine verify code (true/false)<br> pageSize: 10 # comment list page size<br> avatar: monsterid # gravatar style <a href="https://valine.js.org/#/avatar" target="_blank" rel="noopener">https://valine.js.org/#/avatar</a><br> lang: en # i18n: zh-cn/en<br> placeholder: Please leave your footprints # valine comment input placeholder(like: Please leave your footprints )<br> guest_info: nick,mail,link #valine comment header info<br> bg: /img/comment_bg.png # valine background<br> count: false # top_img显示评论数  </p><p><a href="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-valine.png" target="_blank" rel="noopener"><img alt data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-valine.png" class="lazyload"></a></p><h2 id="分享"><a href="#分享" class="headerlink" title="分享"></a><a href="#分享" title="分享"></a>分享</h2><blockquote><p>只能选择一个分享服务商</p></blockquote><h3 id="AddThis"><a href="#AddThis" class="headerlink" title="AddThis"></a><a href="#AddThis" title="AddThis"></a>AddThis</h3><blockquote><p>找到你的 pub-id</p></blockquote><p><a href="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-addthis.jpg" target="_blank" rel="noopener"><img alt data-src="/img/loading.gif" class="lazyload"></a></p><p>配置<code>butterfly.yml</code></p><p>yaml</p><p>1<br>2<br>3  </p><p>addThis:<br> enable: true # or false<br> pubid: 你的pub-id  </p><h3 id="Sharejs"><a href="#Sharejs" class="headerlink" title="Sharejs"></a><a href="#Sharejs" title="Sharejs"></a>Sharejs</h3><p>如果你不知道 <a href="https://github.com/overtrue/share.js/" target="_blank" rel="noopener">sharejs</a>，看看它的説明。</p><p>配置<code>butterfly.yml</code></p><p>yaml</p><p>1<br>2<br>3  </p><p>sharejs:<br> enable: true<br> sites: facebook,twitter,wechat,weibo,qq  #想要显示的内容  </p><p><a href="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-sharejs.png" target="_blank" rel="noopener"><img alt data-src="/img/loading.gif" class="lazyload"></a></p><h3 id="Addtoany"><a href="#Addtoany" class="headerlink" title="Addtoany"></a><a href="#Addtoany" title="Addtoany"></a>Addtoany</h3><p>可以到<a href="https://www.addtoany.com/" target="_blank" rel="noopener">addtoany</a>查看使用説明</p><p>yaml</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10  </p><p>addtoany:<br> enable: false<br> item:   # 显示的内容<br> - facebook<br> - twitter<br> - wechat<br> - sina_weibo<br> - facebook_messenger<br> - email<br> - copy_link  </p><p><a href="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-addtoany.png" target="_blank" rel="noopener"><img alt data-src="/img/loading.gif" class="lazyload"></a></p><h2 id="搜索系统"><a href="#搜索系统" class="headerlink" title="搜索系统"></a><a href="#搜索系統" title="搜索系统"></a>搜索系统</h2><h3 id="Algolia"><a href="#Algolia" class="headerlink" title="Algolia"></a><a href="#Algolia" title="Algolia"></a>Algolia</h3><ol><li><p>你需要安装 <a href="https://github.com/oncletom/hexo-algolia" target="_blank" rel="noopener">hexo-algolia</a>或 <a href="https://github.com/LouisBarranqueiro/hexo-algoliasearch" target="_blank" rel="noopener">hexo-algoliasearch</a>. 根据它们的説明文档去做相应的配置。</p></li><li><p>配置<code>butterfly.yml</code></p></li></ol><p>yaml</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9  </p><p>algolia_search:<br> enable: true<br> hits:<br> per_page: 6  </p><p> labels:<br> input_placeholder: Search for Posts<br> hits_empty: “We didn’t find any results for the search: ${query}” # if there are no result<br> hits_stats: “${hits} results found in ${time} ms”  </p><h3 id="本地搜索"><a href="#本地搜索" class="headerlink" title="本地搜索"></a><a href="#本地搜索" title="本地搜索"></a>本地搜索</h3><ol><li><p>你需要安装 <a href="https://github.com/PaicHyperionDev/hexo-generator-search" target="_blank" rel="noopener">hexo-generator-search</a>. 根据它的文档去做相应配置。<strong>注意格式只支持 xml</strong>。</p></li><li><p>配置<code>butterfly.yml</code></p></li></ol><p>yaml</p><p>1<br>2<br>3<br>4<br>5  </p><p>local_search:<br> enable: false<br> labels:<br> input_placeholder: Search for Posts<br> hits_empty: “We didn’t find any results for the search: ${query}” # if there are no result  </p><h2 id="网站验证"><a href="#网站验证" class="headerlink" title="网站验证"></a><a href="#網站驗證" title="网站验证"></a>网站验证</h2><p>如果需要搜索引擎收录网站，可能需要登录对应搜索引擎的管理平台进行提交。<br>各自的验证码可从各自管理平台拿到</p><p>配置<code>butterfly.yml</code></p><p>yaml</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19  </p><p># Google Webmaster tools verification setting<br># See: <a href="https://www.google.com/webmasters/" target="_blank" rel="noopener">https://www.google.com/webmasters/</a><br>google_site_verification:  </p><p># Bing Webmaster tools verification setting<br># See: <a href="https://www.bing.com/webmaster/" target="_blank" rel="noopener">https://www.bing.com/webmaster/</a><br>bing_site_verification:  </p><p># Yandex Webmaster tools verification setting<br># See: <a href="https://webmaster.yandex.ru/" target="_blank" rel="noopener">https://webmaster.yandex.ru/</a><br>yandex_site_verification:  </p><p># Baidu Webmaster tools verification setting<br># See: <a href="https://ziyuan.baidu.com/site/" target="_blank" rel="noopener">https://ziyuan.baidu.com/site/</a><br>baidu_site_verification:  </p><p># 360 Webmaster tools verification setting<br># see <a href="http://zhanzhang.so.com/" target="_blank" rel="noopener">http://zhanzhang.so.com/</a><br>qihu_site_verification:  </p><h2 id="分析统计"><a href="#分析统计" class="headerlink" title="分析统计"></a><a href="#分析統計" title="分析统计"></a>分析统计</h2><h3 id="百度统计"><a href="#百度统计" class="headerlink" title="百度统计"></a><a href="#百度統計" title="百度统计"></a>百度统计</h3><ol><li><p>登录百度统计的<a href="https://tongji.baidu.com/web/welcome/login" target="_blank" rel="noopener">官方网站</a></p></li><li><p>找到你百度统计的统计代码</p></li></ol><p><a href="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-baidu-tongji.jpg" target="_blank" rel="noopener"><img alt data-src="/img/loading.gif" class="lazyload"></a></p><ol start="3"><li>配置<code>butterfly.yml</code></li></ol><p>yaml</p><p>1  </p><p>baidu_analytics: 你的代码  </p><h3 id="谷歌分析"><a href="#谷歌分析" class="headerlink" title="谷歌分析"></a><a href="#谷歌分析" title="谷歌分析"></a>谷歌分析</h3><ol><li><p>登录谷歌分析的<a href="https://www.google.com/analytics/" target="_blank" rel="noopener">官方网站</a></p></li><li><p>找到你的谷歌分析的跟踪 ID</p></li></ol><p><a href="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-google-analytics.jpg" target="_blank" rel="noopener"><img alt data-src="/img/loading.gif" class="lazyload"></a></p><ol start="3"><li>配置<code>butterfly.yml</code></li></ol><p>yaml</p><p>1  </p><p>google_analytics: 你的代码 # 通常以`UA-`打头  </p><h3 id="腾讯分析"><a href="#腾讯分析" class="headerlink" title="腾讯分析"></a><a href="#騰訊分析" title="腾讯分析"></a>腾讯分析</h3><ol><li><p>登录腾讯分析的<a href="https://ta.qq.com/" target="_blank" rel="noopener">官方网站</a></p></li><li><p>找到你的站点ID</p><p><a href="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-docs-tengxun-analysic.png" target="_blank" rel="noopener"><img alt data-src="/img/loading.gif" class="lazyload"></a></p></li><li><p>配置<code>butterfly.yml</code></p><p>Code</p><p>1<br>2  </p><p># Tencent_analytics ID<br>tencent_analytics:  </p></li></ol><h2 id="广告"><a href="#广告" class="headerlink" title="广告"></a><a href="#廣告" title="广告"></a>广告</h2><h3 id="谷歌广告"><a href="#谷歌广告" class="headerlink" title="谷歌广告"></a><a href="#谷歌廣告" title="谷歌广告"></a>谷歌广告</h3><p>主题已集成谷歌广告（自动广告）</p><p>配置<code>butterfly.yml</code></p><p>yaml</p><p>1<br>2<br>3<br>4<br>5  </p><p>google_adsense:<br> enable: true<br> js: <a href="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js" target="_blank" rel="noopener">https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js</a><br> client: # 填入个人识别码<br> enable_page_level_ads: true  </p><p><a href="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-docs-google-adsense.png" target="_blank" rel="noopener"><img alt data-src="/img/loading.gif" class="lazyload"></a></p><h2 id="MathJax"><a href="#MathJax" class="headerlink" title="MathJax"></a><a href="#MathJax" title="MathJax"></a>MathJax</h2><blockquote><p>建议使用 KaTex 获得更好的效果，下文有介绍！</p></blockquote><p>配置<code>butterfly.yml</code>:</p><p>yaml</p><p>1<br>2<br>3<br>4<br>5  </p><p>mathjax:<br> enable: true<br> # true 表示每一页都加载mathjax.js<br> # false 需要时加载，须在使用的Markdown Front-matter 加上 mathjax: true<br> per_page: false  </p><blockquote><p>如果<code>per_page</code>设爲<code>true</code>,则每一页都会加载Mathjax服务。设爲<code>false</code>，则需要在文章<code>Front-matter</code>添加<code>mathjax: true</code>,对应的文章才会加载Mathjax服务。</p></blockquote><p>然后你需要修改一下默认的<code>markdown</code>渲染引擎来实现 MathJax 的效果。</p><p>查看: <a href="https://www.npmjs.com/package/hexo-renderer-kramed" target="_blank" rel="noopener">hexo-renderer-kramed</a></p><p>以下操作在你 hexo 博客的目录下 (<strong>不是 Butterfly 的目录!</strong>):</p><p><a href="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-mathjax.png" target="_blank" rel="noopener"><img alt data-src="/img/loading.gif" class="lazyload"></a></p><p>效果：</p><p><a href="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-mathjax-2.jpg" target="_blank" rel="noopener"><img alt data-src="/img/loading.gif" class="lazyload"></a></p><h2 id="KaTeX"><a href="#KaTeX" class="headerlink" title="KaTeX"></a><a href="#KaTeX" title="KaTeX"></a>KaTeX</h2><p>首先禁用<code>MathJax</code>（如果你配置过 MathJax 的话），然后修改你的<code>butterfly.yml</code>以便加载<code>katex.min.css</code>:</p><p>yaml</p><p>1<br>2<br>3<br>4<br>5<br>6  </p><p>katex:<br> enable: true<br> # true 表示每一页都加载katex.js<br> # false 需要时加载，须在使用的Markdown Front-matter 加上 katex: true<br> per_page: false<br> hide_scrollbar: true  </p><p>你不需要添加<code>katex.min.js</code>来渲染数学方程。相应的你需要卸载你之前的 hexo 的 markdown 渲染器以及<code>hexo-math</code>，然后安装新的<code>hexo-renderer-markdown-it-plus</code>:</p><p>yaml</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13  </p><p># 替换 `hexo-renderer-kramed` 或者 `hexo-renderer-marked` 等hexo的markdown渲染器<br># 你可以在你的package.json里找到hexo的markdwon渲染器，并将其卸载<br>npm un hexo-renderer-marked --save  </p><p># or  </p><p>npm un hexo-renderer-kramed --save  </p><p># 卸载 `hexo-math`<br>npm un hexo-math --save  </p><p># 然后安装 `hexo-renderer-markdown-it-plus`<br>npm i @upupming/hexo-renderer-markdown-it-plus --save  </p><p>注意到 <a href="https://github.com/CHENXCHEN/hexo-renderer-markdown-it-plus" target="_blank" rel="noopener"><code>hexo-renderer-markdown-it-plus</code></a>已经无人持续维护, 所以我们使用 <a href="https://github.com/upupming/hexo-renderer-markdown-it-plus" target="_blank" rel="noopener"><code>@upupming/hexo-renderer-markdown-it-plus</code></a>。 这份 fork 的代码使用了 <a href="https://github.com/yzhang-gh/markdown-it-katex" target="_blank" rel="noopener"><code>@neilsustc/markdown-it-katex</code></a>同时它也是 VSCode 的插件 <a href="https://github.com/yzhang-gh/vscode-markdown" target="_blank" rel="noopener">Markdown All in One</a>所使用的, 所以我们可以获得最新的 KaTex 功能例如 <code>\tag{}</code>。</p><p>你还可以通过 <a href="https://github.com/yzhang-gh/markdown-it-katex" target="_blank" rel="noopener"><code>@neilsustc/markdown-it-katex</code></a>控制 KaTeX 的设置，所有可配置的选项参见 <a href="https://katex.org/docs/options.html。" target="_blank" rel="noopener">https://katex.org/docs/options.html。</a> 比如你想要禁用掉 KaTeX 在命令行上输出的宂长的警告信息，你可以在根目录的 <code>_config.yml</code> 中使用下面的配置将 <code>strict</code> 设置为 false:</p><p>yaml</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7  </p><p>markdown_it_plus:<br> plugins:<br> - plugin:<br> name: ‘@neilsustc/markdown-it-katex’<br> enable: true<br> options:<br> strict: false  </p><p>当然，你还可以利用这个特性来定义一些自己常用的 <code>macros</code>。</p><p>因为 KaTeX 更快更轻量，因此没有 MathJax 的功能多（比如右键菜单）。为那些使用 MathJax 的用户，我们也为 KaTeX 默认添加了 <a href="https://github.com/upupming/katex-copytex" target="_blank" rel="noopener"><em>Copy As TeX Code</em></a>的功能。</p><p><a href="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-katex.gif" target="_blank" rel="noopener"><img alt data-src="/img/loading.gif" class="lazyload"></a></p><h2 id="美化-特效"><a href="#美化-特效" class="headerlink" title="美化/特效"></a><a href="#美化-特效" title="美化/特效"></a>美化/特效</h2><h3 id="自定义主题色"><a href="#自定义主题色" class="headerlink" title="自定义主题色"></a><a href="#自定義主題色" title="自定义主题色"></a>自定义主题色</h3><p>可以修改大部分UI颜色</p><p>配置<code>butterfly.yml</code>，比如：</p><blockquote><p>颜色值必须被双引号包裹，就像<code>&quot;#000&quot;</code>而不是<code>#000</code>。否则将会在构建的时候报错！</p></blockquote><p>yaml</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9  </p><p>theme_color:<br> enable: true<br> main: “#9370DB”<br> paginator: “#7A7FF1”<br> button_hover: “#FF7242”<br> text_selection: “#69c46d”<br> link_color: “#858585”<br> hr_color: “#A4D8FA”<br> read-mode-bg_color: ‘#FAF9DE’  </p><p><a href="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-color_1.png" target="_blank" rel="noopener"><img alt data-src="/img/loading.gif" class="lazyload"></a><br><a href="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-color_2.png" target="_blank" rel="noopener"><img alt data-src="/img/loading.gif" class="lazyload"></a></p><h3 id="网站背景"><a href="#网站背景" class="headerlink" title="网站背景"></a><a href="#網站背景" title="网站背景"></a>网站背景</h3><p>默认显示白色，可设置图片或者顔色</p><p>配置<code>butterfly.yml</code></p><p>yaml</p><p>1<br>2<br>3<br>4  </p><p># 图片格式 background: url(<a href="http://xxxxxx.com/xxx.jpg" target="_blank" rel="noopener">http://xxxxxx.com/xxx.jpg</a>)<br># 顔色 background: ‘#49B202’<br># 留空 显示白色<br>background:  </p><p><code>background:&#39;#49B202&#39;</code></p><p><a href="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-set-body-background-color.png" target="_blank" rel="noopener"><img alt data-src="/img/loading.gif" class="lazyload"></a></p><p><code>background: url(https://i.loli.net/2019/09/09/5oDRkWVKctx2b6A.png)</code></p><p><a href="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-set-body-background-img.png" target="_blank" rel="noopener"><img alt data-src="/img/loading.gif" class="lazyload"></a></p><h3 id="footer-背景"><a href="#footer-背景" class="headerlink" title="footer 背景"></a><a href="#footer-背景" title="footer 背景"></a>footer 背景</h3><p>footer 的背景会与<code>top_img</code>的一致, 当设置<code>false</code>时，将与主题色一致。</p><p>配置<code>butterfly.yml</code></p><p>yaml</p><p>1<br>2  </p><p># footer是否显示图片背景(与top_img一致)<br>footer_bg: true  </p><p><code>true</code></p><p><a href="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-footer-img.png" target="_blank" rel="noopener"><img alt data-src="/img/loading.gif" class="lazyload"></a></p><h3 id="打字效果"><a href="#打字效果" class="headerlink" title="打字效果"></a><a href="#打字效果" title="打字效果"></a>打字效果</h3><p>打字效果<a href="https://github.com/disjukr/activate-power-mode" target="_blank" rel="noopener">activate-power-mode</a></p><p>配置<code>butterfly.yml</code></p><p>yaml</p><p>1<br>2<br>3<br>4<br>5  </p><p># 打字效果<br>activate_power_mode:<br> enable: false<br> colorful: true # 冒光特效<br> shake: true # 抖动特效  </p><p><a href="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-type-animation.gif" target="_blank" rel="noopener"><img alt data-src="/img/loading.gif" class="lazyload"></a></p><h3 id="静止彩带"><a href="#静止彩带" class="headerlink" title="静止彩带"></a><a href="#靜止彩帶" title="静止彩带"></a>静止彩带</h3><p>好看的彩带背景，可设置每次刷新更换彩带，或者每次点击更换彩带</p><p>配置<code>butterfly.yml</code></p><p>yaml</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7  </p><p>canvas_ribbon:<br> enable: false<br> size: 150<br> alpha: 0.6<br> zIndex: -1<br> click_to_change: false  #设置是否每次点击都更换彩带<br> mobile: false # false 手机端不显示 true 手机端显示  </p><p>相关配置可查看<a href="https://github.com/hustcc/ribbon.js" target="_blank" rel="noopener">canvas_ribbon</a></p><h3 id="动态彩带"><a href="#动态彩带" class="headerlink" title="动态彩带"></a><a href="#動態彩帶" title="动态彩带"></a>动态彩带</h3><p>好看的彩带背景，会飘动</p><p>配置<code>butterfly.yml</code></p><p>yaml</p><p>1<br>2<br>3  </p><p>canvas_ribbon_piao:<br> enable: true<br> mobile: false # false 手机端不显示 true 手机端显示  </p><p><a href="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-canvas-ribbon-piao.gif" target="_blank" rel="noopener"><img alt data-src="/img/loading.gif" class="lazyload"></a></p><h3 id="canvas-nest"><a href="#canvas-nest" class="headerlink" title="canvas-nest"></a><a href="#canvas-nest" title="canvas-nest"></a>canvas-nest</h3><p>配置<code>butterfly.yml</code></p><p>yaml</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7  </p><p>canvas_nest:<br> enable: true<br> color: ‘0,0,255’ #color of lines, default: ‘0,0,0’; RGB values: (R,G,B).(note: use ‘,’ to separate.)<br> opacity: 0.7 # the opacity of line (0~1), default: 0.5.<br> zIndex: -1 # z-index property of the background, default: -1.<br> count: 99 # the number of lines, default: 99.<br> mobile: false # false 手机端不显示 true 手机端显示  </p><p><a href="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-canvas_nest.gif" target="_blank" rel="noopener"><img alt data-src="/img/loading.gif" class="lazyload"></a></p><h3 id="鼠标点击效果"><a href="#鼠标点击效果" class="headerlink" title="鼠标点击效果"></a><a href="#鼠標點擊效果" title="鼠标点击效果"></a>鼠标点击效果</h3><h4 id="烟花"><a href="#烟花" class="headerlink" title="烟花"></a><a href="#煙花" title="烟花"></a>烟花</h4><p>配置<code>butterfly.yml</code></p><p>yaml</p><p>1<br>2  </p><p>fireworks:<br> enable: true  </p><p><a href="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-firewall.gif" target="_blank" rel="noopener"><img alt data-src="/img/loading.gif" class="lazyload"></a></p><h4 id="爱心"><a href="#爱心" class="headerlink" title="爱心"></a><a href="#愛心" title="爱心"></a>爱心</h4><p>配置<code>butterfly.yml</code></p><p>yaml</p><p>1<br>2<br>3  </p><p># 点击出现爱心<br>click_heart:<br> enable: true  </p><p><a href="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/click_love.gif" target="_blank" rel="noopener"><img alt data-src="/img/loading.gif" class="lazyload"></a></p><h4 id="文字"><a href="#文字" class="headerlink" title="文字"></a><a href="#文字" title="文字"></a>文字</h4><p>配置<code>butterfly.yml</code></p><p>yaml</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17  </p><p># 点击出现文字，文字可自行修改<br>ClickShowText:<br> enable: false<br> text:<br> - 富强<br> - 民主<br> - 文明<br> - 和谐<br> - 自由<br> - 平等<br> - 公正<br> - 法治<br> - 爱国<br> - 敬业<br> - 诚信<br> - 友善<br> fontSize: 15px  </p><p><a href="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/click_word.gif" target="_blank" rel="noopener"><img alt data-src="/img/loading.gif" class="lazyload"></a></p><h3 id="文章页美化"><a href="#文章页美化" class="headerlink" title="文章页美化"></a><a href="#文章頁美化" title="文章页美化"></a>文章页美化</h3><p>会改变ol、ul、h1-h5的样式</p><p>配置<code>butterfly.yml</code></p><p>yaml</p><p>1<br>2<br>3<br>4  </p><p>post_beautify:<br> enable: true<br> title-prefix-icon: ‘\f0c1’<br> title-prefix-icon-color: “#F47466”  </p><p><code>title-prefix-icon</code>填写的是fontawesome的icon的Unicode数。<br><a href="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-fontwesome-unicode.png" target="_blank" rel="noopener"><img alt data-src="/img/loading.gif" class="lazyload"></a></p><blockquote><p>未开啓美化</p></blockquote><p><a href="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-post-beautify.png" target="_blank" rel="noopener"><img alt data-src="/img/loading.gif" class="lazyload"></a></p><blockquote><p>开啓美化</p></blockquote><p><a href="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-post-beautif.png" target="_blank" rel="noopener"><img alt data-src="/img/loading.gif" class="lazyload"></a></p><h3 id="自定义字体"><a href="#自定义字体" class="headerlink" title="自定义字体"></a><a href="#自定義字體" title="自定义字体"></a>自定义字体</h3><p>可自行设置字体的<code>font-family</code></p><p>配置<code>butterfly.yml</code></p><p>yaml</p><p>1<br>2<br>3<br>4  </p><p>font:<br> enable: true<br> font-family: Lato, Helvetica Neue For Number, -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, PingFang SC, Hiragino Sans GB,”Microsoft JhengHei”, “MicrMicrosoft YaHei”, Helvetica Neue, Helvetica, Arial, sans-serif<br> code-font: consolas, Menlo, “PingFang SC”, “Microsoft JhengHei”,”Microsoft YaHei”, monospace, Helvetica Neue For Number  </p><h3 id="网站副标题"><a href="#网站副标题" class="headerlink" title="网站副标题"></a><a href="#網站副標題" title="网站副标题"></a>网站副标题</h3><blockquote><p>适用于 版本号 &gt;= V1.2.0</p><p>V2.0.0开始增加一些第三方api调用</p></blockquote><p>可设置主页中显示的网站副标题或者喜欢的座右铭。</p><p>配置<code>butterfly.yml</code></p><p>yaml</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16  </p><p># 主页subtitle<br># 打字效果<br>subtitle:<br> enable: true<br> # source调用第三方服务<br> # source: false 关闭调用<br> # source: 1  调用金山词霸的每日一句（简体）<br> # source: 2  调用一言网的一句话（简体） #<a href="https://hitokoto.cn/" target="_blank" rel="noopener">https://hitokoto.cn/</a><br> # source: 3  调用一句网（简体） <a href="http://yijuzhan.com/" target="_blank" rel="noopener">http://yijuzhan.com/</a><br> # source: 4  调用今日诗词（简体） <a href="https://www.jinrishici.com/" target="_blank" rel="noopener">https://www.jinrishici.com/</a><br> # subtitle 会先显示 source , 再显示 sub 的内容<br> source: false<br> # (如果有英文逗号’ , ‘，请使用转义字符 &#44;)<br> sub:<br> - 今日事&#44;今日毕<br> - Never put off till tomorrow what you can do today  </p><p><a href="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-index-subtitle.gif" target="_blank" rel="noopener"><img alt data-src="/img/loading.gif" class="lazyload"></a></p><h3 id="主页文章cover位置"><a href="#主页文章cover位置" class="headerlink" title="主页文章cover位置"></a><a href="#主頁文章cover位置" title="主页文章cover位置"></a>主页文章cover位置</h3><p>Code</p><p>1<br>2<br>3<br>4  </p><p># 主页文章COVER显示位置<br># 三个值可配置 left , right , both<br># left(全部图片显示在左边)，right(全部图片显示在右边)，both(左右左右顺序显示)<br>index_post_cover: left  </p><p><code>left</code></p><p><a href="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-docs-cover-left.png" target="_blank" rel="noopener"><img alt data-src="/img/loading.gif" class="lazyload"></a></p><p><code>right</code></p><p><a href="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-docs-cover-right.png" target="_blank" rel="noopener"><img alt data-src="/img/loading.gif" class="lazyload"></a></p><p><code>both</code></p><p><a href="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-docs-cover-both.png" target="_blank" rel="noopener"><img alt data-src="/img/loading.gif" class="lazyload"></a></p><h3 id="主页top-img显示大小"><a href="#主页top-img显示大小" class="headerlink" title="主页top_img显示大小"></a><a href="#主頁top-img顯示大小" title="主页top_img显示大小"></a>主页top_img显示大小</h3><blockquote><p>适用于 版本号 &gt;= V1.2.0</p></blockquote><p>默认的显示为全屏。site-info的区域会居中显示</p><p>yaml</p><p>1<br>2<br>3<br>4  </p><p># 主页设置<br># 默认top_img全屏，site_info在中间<br># 使用默认, 都无需填写（建议默认）<br>index_top_img_height:  #主页top_img高度 例如 300px/300em/300rem  不能使用百分比  </p><p>注意：<code>index_top_img_height</code>的值不能使用百分比。<br>2个都不填的话，会使用默认值</p><p>举例，当</p><p>yaml</p><p>1  </p><p>index_top_img_height: 400px  </p><p>效果</p><p><a href="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-index-top-img-setting.png" target="_blank" rel="noopener"><img alt data-src="/img/loading.gif" class="lazyload"></a></p><h2 id="PWA"><a href="#PWA" class="headerlink" title="PWA"></a><a href="#PWA" title="PWA"></a>PWA</h2><p>要为<code>Butterfly</code>配上 PWA 特性, 你需要如下几个步骤:</p><ol><li><p>打开 hexo 工作目录</p></li><li><p><code>npm install hexo-offline --save</code> 或者 <code>yarn add hexo-offline</code></p></li><li><p>修改<code>_config.yml</code> 在站点<code>_config.yml</code>中增加以下内容。</p></li></ol><p>yaml</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14  </p><p># offline config passed to sw-precache.<br>offline:<br> maximumFileSizeToCacheInBytes: 10485760 # 缓存的最大文件大小，以字节为单位<br> staticFileGlobs:<br> - public/**/*.{js,html,css,png,jpg,gif,svg,webp,eot,ttf,woff,woff2}<br> # 静态文件合集，如果你的站点使用了例如webp格式的文件，请将文件类型添加进去。<br> stripPrefix: public<br> verbose: true<br> runtimeCaching:<br> # CDNs - should be cacheFirst, since they should be used specific versions so should not change<br> - urlPattern: /* # 如果你需要加载CDN资源，请配置该选项，如果没有，可以不配置。<br> handler: cacheFirst<br> options:<br> origin: your_websie_url # 可替换成你的 url  </p><p>更多内容请查看 <a href="https://github.com/JLHwung/hexo-offline" target="_blank" rel="noopener">hexo-offline</a>的官方文档</p><ol start="4"><li>在<code>butterfly.yml</code>中开启 pwa 选项。</li></ol><p>yaml</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8  </p><p>pwa:<br> enable: true<br> manifest: /img/pwa/manifest.json<br> theme_color: “#fff”<br> apple_touch_icon: /img/pwa/apple-touch-icon.png<br> favicon_32_32: /img/pwa/32.png<br> favicon_16_16: /img/pwa/16.png<br> mask_icon: /img/pwa/safari-pinned-tab.svg  </p><ol start="5"><li>在创建<code>source/</code>目录中创建<code>manifest.json</code>文件。</li></ol><p>json</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47  </p><p>{<br> “name”: “string”, //应用全称<br> “short_name”: “Junzhou”, //应用简称<br> “theme_color”: “#49b1f5”, //匹配浏览器的地址栏颜色<br> “background_color”: “#49b1f5”,//加载应用时的背景色<br> “display”: “standalone”,//首选显示模式 其他选项有：fullscreen,minimal-ui,browser<br> “scope”: “/“,<br> “start_url”: “/“,<br> “icons”: [ //该数组指定icons图标参数，用来时适配不同设备（需为png，至少包含一个192px*192px的图标）<br> {<br> “src”: “images/pwaicons/36.png”, //图标文件的目录，需在source/目录下自行创建。<br> “sizes”: “36x36”,<br> “type”: “image/png”<br> },<br> {<br> “src”: “images/pwaicons/48.png”,<br> “sizes”: “48x48”,<br> “type”: “image/png”<br> },<br> {<br> “src”: “images/pwaicons/72.png”,<br> “sizes”: “72x72”,<br> “type”: “image/png”<br> },<br> {<br> “src”: “images/pwaicons/96.png”,<br> “sizes”: “96x96”,<br> “type”: “image/png”<br> },<br> {<br> “src”: “images/pwaicons/144.png”,<br> “sizes”: “144x144”,<br> “type”: “image/png”<br> },<br> {<br> “src”: “images/pwaicons/192.png”,<br> “sizes”: “192x192”,<br> “type”: “image/png”<br> },<br> {<br> “src”: “images/pwaicons/512.png”,<br> “sizes”: “512x512”,<br> “type”: “image/png”<br> }<br> ],<br> “splash_pages”: null //配置自定义启动动画。<br> }  </p><p>你也可以通过 <a href="https://app-manifest.firebaseapp.com/" target="_blank" rel="noopener">Web App Manifest</a>快速创建<code>manifest.json</code>。（Web App Manifest 要求至少包含一个 512*512 像素的图标）</p><ol start="6"><li><p>可以通过<code>Chrome</code>插件<code>Lighthouse</code>检查 PWA 配置是否生效以及配置是否正确。</p><ul><li>打开博客页面</li><li>启动<code>Lighthouse</code>插件 (<code>Lighthouse</code>插件要求至少包含一个 512*512 像素的图标)</li></ul></li></ol><p>关于 PWA（渐进式增强 Web 应用）的更多内容请参閲 <a href="https://developers.google.com/web/tools/lighthouse/audits/address-bar" target="_blank" rel="noopener">Google Tools for Web Developers</a></p><h2 id="字数统计"><a href="#字数统计" class="headerlink" title="字数统计"></a><a href="#字數統計" title="字数统计"></a>字数统计</h2><p>要为<code>Butterfly</code>配上字数统计特性, 你需要如下几个步骤:</p><ol><li><p>打开 hexo 工作目录</p></li><li><p><code>npm install hexo-wordcount --save</code> or <code>yarn add hexo-wordcount</code></p></li><li><p>配置<code>butterfly.yml</code>:</p></li></ol><p>yaml</p><p>1<br>2  </p><p>wordcount:<br> enable: true  </p><p><a href="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-word-count.png" target="_blank" rel="noopener"><img alt data-src="/img/loading.gif" class="lazyload"></a></p><h2 id="文章置顶"><a href="#文章置顶" class="headerlink" title="文章置顶"></a><a href="#文章置頂" title="文章置顶"></a>文章置顶</h2><p>要为你一些文章置顶，你需要如下步骤:</p><ol><li>打开 hexo 工作目录</li><li><code>npm uninstall hexo-generator-index --save</code> 然后 <code>npm install hexo-generator-index-pin-top --save</code></li><li>你要在文章的<code>front-matter</code>区域里添加<code>top: True</code>属性来把这篇文章置顶。</li><li>你可以参考 <a href="https://github.com/netcan/hexo-generator-index-pin-top" target="_blank" rel="noopener">hexo-generator-index-pin-top</a>这个仓库来了解更多细节。</li></ol><p>举个例子:</p><p>你的某篇文章开头如下：</p><p>Markdown</p><p>1<br>2<br>3<br>4<br>5<br>6  </p><p>title: xxxx<br>tags:  </p><ul><li>xxx<br>date: 2018-08-08 08:08:08<br>-–<br>// ….  </li></ul><p>现在把<code>top: True</code>加进去：</p><p>Markdown</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7  </p><p>title: xxxx<br>tags:  </p><ul><li>xxx<br>date: 2018-08-08 08:08:08<br>top: True<br>-–<br>// ….  </li></ul><h2 id="图片大图查看模式"><a href="#图片大图查看模式" class="headerlink" title="图片大图查看模式"></a><a href="#圖片大圖查看模式" title="图片大图查看模式"></a>图片大图查看模式</h2><h3 id="fancybox"><a href="#fancybox" class="headerlink" title="fancybox"></a><a href="#fancybox" title="fancybox"></a>fancybox</h3><p>配置<code>butterfly.yml</code></p><p>yaml</p><p>1<br>2<br>3  </p><p># fancybox <a href="http://fancyapps.com/fancybox/3/" target="_blank" rel="noopener">http://fancyapps.com/fancybox/3/</a><br>fancybox:<br> enable: true  </p><p><a href="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/fancybox.gif" target="_blank" rel="noopener"><img alt="fancybox.gif" title="fancybox.gif" data-src="/img/loading.gif" class="lazyload"></a></p><h3 id="medium-zoom"><a href="#medium-zoom" class="headerlink" title="medium_zoom"></a><a href="#medium-zoom" title="medium_zoom"></a>medium_zoom</h3><p>配置<code>butterfly.yml</code></p><p>yaml</p><p>1<br>2  </p><p>medium_zoom:<br> enable: true  </p><p><a href="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/medium_zoom.gif" target="_blank" rel="noopener"><img alt="medium_zoom.gif" title="medium_zoom.gif" data-src="/img/loading.gif" class="lazyload"></a></p><h2 id="Snackbar-弹窗"><a href="#Snackbar-弹窗" class="headerlink" title="Snackbar 弹窗"></a><a href="#Snackbar-彈窗" title="Snackbar 弹窗"></a>Snackbar 弹窗</h2><p>Snackbar弹窗,根据自己爱好开啓</p><p>配置<code>butterfly.yml</code></p><p>yaml</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9  </p><p># Snackbar 弹窗<br># <a href="https://github.com/polonel/SnackBar" target="_blank" rel="noopener">https://github.com/polonel/SnackBar</a><br># position 弹窗位置<br># 可选 top-left / top-center / top-right / bottom-left / bottom-center / bottom-right<br>snackbar:<br> enable: true<br> position: bottom-left<br> bg_light: ‘#49b1f5’ #light mode时弹窗背景<br> bg_dark: ‘#2d3035’ #dark mode时弹窗背景  </p><blockquote><p>未开啓Snackbar</p></blockquote><p><a href="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/snackbar_false.gif" target="_blank" rel="noopener"><img alt="snackbar_false.gif" title="snackbar_false.gif" data-src="/img/loading.gif" class="lazyload"></a></p><blockquote><p>开啓Snackbar</p></blockquote><p><a href="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/snackbar_true.gif" target="_blank" rel="noopener"><img alt="snackbar_true.gif" title="snackbar_true.gif" data-src="/img/loading.gif" class="lazyload"></a></p><h1 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q &amp; A"></a><a href="#Q-amp-A" title="Q &amp; A"></a>Q &amp; A</h1><p>整理了一些网友在安装过程中出现的问题。在提问题之前，先看有没有解决方法。<br><a href="../cbfcd1ae">Butterfly主题的Q&amp;A</a></p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> Hexo </tag>
            
            <tag> 主题 </tag>
            
            <tag> Butterfly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈IaaS、PaaS、SaaS的区别</title>
      <link href="/2020/01/09/%E6%B5%85%E8%B0%88IaaS%E3%80%81PaaS%E3%80%81SaaS/"/>
      <url>/2020/01/09/%E6%B5%85%E8%B0%88IaaS%E3%80%81PaaS%E3%80%81SaaS/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="/images/a55676f8e1b084a398f8cd5f85cdae7d_hd.jpg" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/a55676f8e1b084a398f8cd5f85cdae7d_hd.jpg" class="lazyload"></a></p><blockquote><p>你一定听说过云计算中的三个“高大上”的概念：IaaS、PaaS和SaaS，这几个术语并不好理解。<strong>不过，如果你是个吃货，还喜欢披萨，这个问题就好解决了!</strong>好吧，其实你根本不是一个吃货，之所以自我标榜为吃货，其实是为了收获赞叹式的夸奖，“吃货还这么瘦，好羡慕啊!”或者，总得给伦家的微丰找个像样的理由。一个“吃货”是怎样吃到披萨的呢?</p></blockquote><p><strong>1. 在家自己做</strong></p><p>这真是个麻烦事，你的准备很多东西，发面、做面团、进烤箱。。。。。简单列一下，需要下图所示的一切：</p><p><a href="/images/9acf7b0482902a634f654ae8d7e7fbe1_hd.jpg" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/9acf7b0482902a634f654ae8d7e7fbe1_hd.jpg" class="lazyload"></a></p><p><strong>2. 买好速食披萨回家自己做着吃</strong></p><p>你只需要从披萨店里买回成品，回家烘焙就好了，在自己的餐桌上吃。和自己在家做不同，你需要一个pizza供应商。</p><p><a href="/images/b642b741b04857b513824913d0e71863_hd.jpg" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/b642b741b04857b513824913d0e71863_hd.jpg" class="lazyload"></a></p><p><strong>3. 打电话叫外卖将披萨送到家中</strong></p><p>打个电话，pizza就送到家门口。</p><p><a href="/images/b7849abcf2233f18b62df90d134b2295_hd.jpg" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/b7849abcf2233f18b62df90d134b2295_hd.jpg" class="lazyload"></a></p><p><strong>4. 在披萨店吃披萨</strong></p><p>你什么都不需要准备，连餐桌也是pizza店的。</p><p><a href="/images/1e2589df4b3c7caa86e361e3f8796080_hd.jpg" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/1e2589df4b3c7caa86e361e3f8796080_hd.jpg" class="lazyload"></a></p><p><strong>总结一下，吃货可以通过如下途径吃披萨：</strong></p><p><a href="/images/be14da9aaf55270380dae3f37eabda7e_hd.jpg" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/be14da9aaf55270380dae3f37eabda7e_hd.jpg" class="lazyload"></a></p><p><strong>好了，现在忘掉pizza!</strong></p><p>假设你是一家超牛X的技术公司，根本不需要别人提供服务，你拥有基础设施、应用等等其它一切，你把它们分为三层：<strong>基础设施(infrastructure)、平台(platform)和软件(software)</strong>，如下图：</p><p><a href="/images/f3cc3fca72da988a748cc87173d36e1a_hd.jpg" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/f3cc3fca72da988a748cc87173d36e1a_hd.jpg" class="lazyload"></a></p><p>这其实就是云计算的三个分层，基础设施在最下端，平台在中间，软件在顶端，分别是分别是Infrastructure-as-a-Service(IaaS)，Platform-as-a-Service(PaaS)，Software-as-a-Service(SaaS)，别的一些“软”的层可以在这些层上面添加。</p><p>而你的公司什么都有，现在所处的状态叫本地部署(On-Premises)，就像在自己家做pizza一样。几年前如果你想在办公室或者公司的网站上运行一些企业应用，你需要去买服务器，或者别的高昂的硬件来控制本地应用，让你的业务运行起来，这就叫本地部署。</p><p>假如你家BOSS突然有一天想明白了，只是为了吃上pizza，为什么非要自己做呢?于是，准备考虑一家云服务供应商，这个云服务供应商能提供哪些服务呢?其所能提供的云服务也就是云计算的三个分层：IaaS、PaaS和SaaS，就像pizza店提供三种服务：买成品回家做、外卖和到披萨店吃。</p><p>用一张图来表示就是这样的。</p><p><a href="/images/0f8566256a31169d93094fd0b90c9720_hd.jpg" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/0f8566256a31169d93094fd0b90c9720_hd.jpg" class="lazyload"></a></p><p>现在我们来谈谈具体细节。</p><h2 id="IaaS-Infrastructure-as-a-Service-基础设施即服务"><a href="#IaaS-Infrastructure-as-a-Service-基础设施即服务" class="headerlink" title="IaaS: Infrastructure-as-a-Service(基础设施即服务)"></a>IaaS: Infrastructure-as-a-Service(基础设施即服务)</h2><p>有了IaaS，你可以将硬件外包到别的地方去。IaaS公司会提供场外服务器，存储和网络硬件，你可以租用。节省了维护成本和办公场地，公司可以在任何时候利用这些硬件来运行其应用。</p><p>一些大的IaaS公司包括Amazon, Microsoft, VMWare, Rackspace和Red Hat.不过这些公司又都有自己的专长，比如Amazon和微软给你提供的不只是IaaS，他们还会将其计算能力出租给你来host你的网站。</p><h2 id="PaaS-Platform-as-a-Service-平台即服务"><a href="#PaaS-Platform-as-a-Service-平台即服务" class="headerlink" title="PaaS: Platform-as-a-Service(平台即服务)"></a>PaaS: Platform-as-a-Service(平台即服务)</h2><p>第二层就是所谓的PaaS，某些时候也叫做中间件。你公司所有的开发都可以在这一层进行，节省了时间和资源。</p><p>PaaS公司在网上提供各种开发和分发应用的解决方案，比如虚拟服务器和操作系统。这节省了你在硬件上的费用，也让分散的工作室之间的合作变得更加容易。网页应用管理，应用设计，应用虚拟主机，存储，安全以及应用开发协作工具等。</p><p>一些大的PaaS提供者有Google App Engine,Microsoft Azure，Force.com,Heroku，Engine Yard。最近兴起的公司有AppFog,Mendix和Standing Cloud.</p><h2 id="SaaS-Software-as-a-Service-软件即服务"><a href="#SaaS-Software-as-a-Service-软件即服务" class="headerlink" title="SaaS: Software-as-a-Service(软件即服务)"></a>SaaS: Software-as-a-Service(软件即服务)</h2><p>第三层也就是所谓SaaS。这一层是和你的生活每天接触的一层，大多是通过网页浏览器来接入。任何一个远程服务器上的应用都可以通过网络来运行，就是SaaS了。</p><p>你消费的服务完全是从网页如Netflix,MOG,Google Apps,Box.net,Dropbox或者苹果的iCloud那里进入这些分类。尽管这些网页服务是用作商务和娱乐或者两者都有，但这也算是云技术的一部分。</p><p>一些用作商务的SaaS应用包括Citrix的Go To Meeting，Cisco的WebEx，Salesforce的CRM，ADP，Workday和SuccessFactors。</p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><blockquote><ol><li>IaaS就是台服务器。</li><li>PaaS就是Tomcat加MySQL。</li><li>SaaS就是三千块一套的加个Logo就能开业的电商网站。</li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> IaaS、PaaS、SaaS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IaaS </tag>
            
            <tag> PaaS </tag>
            
            <tag> SaaS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git创建远程仓库并推送代码</title>
      <link href="/2020/01/05/Git%E5%88%9B%E5%BB%BA%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E5%B9%B6%E6%8E%A8%E9%80%81%E4%BB%A3%E7%A0%81/"/>
      <url>/2020/01/05/Git%E5%88%9B%E5%BB%BA%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E5%B9%B6%E6%8E%A8%E9%80%81%E4%BB%A3%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Git的使用"><a href="#Git的使用" class="headerlink" title="Git的使用"></a>Git的使用</h1><blockquote><p>创建git仓库<br>生成签名<br>上传到远程版本库（github）</p></blockquote><h2 id="什么是Git？"><a href="#什么是Git？" class="headerlink" title="什么是Git？"></a>什么是Git？</h2><p>Git是目前世界上最先进的分布式版本控制系统。<br>Git是免费、开源的<br>最初Git是为辅助 Linux 内核开发的，来替代 BitKeeper</p><p><strong>优点：</strong></p><ul><li>适合分布式开发，强调个体。</li><li>公共服务器压力和数据量都不会太大。</li><li>速度快、灵活。</li><li>任意两个开发者之间可以很容易的解决冲突。</li><li>离线工作。</li></ul><p><strong>缺点：</strong></p><ul><li>模式上比SVN更加复杂。</li><li>不符合常规思维。</li><li>代码保密性差，一旦开发者把整个库克隆下来就可以完全公开所有代码和版本信息。</li></ul><p><strong>官网：</strong> <a href="https://git-scm.com/" target="_blank" rel="noopener">https://git-scm.com/</a><br><strong>源码：</strong> <a href="https://github.com/git/git/" target="_blank" rel="noopener">https://github.com/git/git/</a></p><h2 id="待见Git工作环境"><a href="#待见Git工作环境" class="headerlink" title="待见Git工作环境"></a>待见Git工作环境</h2><h3 id="下载Git"><a href="#下载Git" class="headerlink" title="下载Git"></a>下载Git</h3><p>打开 <a href="https://git-scm.com/" target="_blank" rel="noopener" title="Git下载地址">git官网</a>，下载git对应操作系统的版本。</p><p><a href="/images/63651-20170904224935226-646404598.png" data-fancybox="group" data-caption="image" class="fancybox"><img alt="image" title="image" data-src="/images/63651-20170904224935226-646404598.png" class="lazyload"></a></p><p>选择版本：</p><p><a href="/images/63651-20170904225056351-1443818096.png" data-fancybox="group" data-caption="image" class="fancybox"><img alt="image" title="image" data-src="/images/63651-20170904225056351-1443818096.png" class="lazyload"></a></p><p>这里我选择下载<a href="https://github.com/git-for-windows/git/releases/download/v2.14.1.windows.1/Git-2.14.1-64-bit.exe" target="_blank" rel="noopener"><strong>64-bit Git for Windows Setup</strong></a></p><p><a href="/images/63651-20170904225407569-334038713.png" data-fancybox="group" data-caption="image" class="fancybox"><img alt="image" title="image" data-src="/images/63651-20170904225407569-334038713.png" class="lazyload"></a></p><h3 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h3><p><a href="/images/63651-20170904225914054-2025747538.png" data-fancybox="group" data-caption="image" class="fancybox"><img alt="image" title="image" data-src="/images/63651-20170904225914054-2025747538.png" class="lazyload"></a></p><p>选择安装配置信息</p><p><a href="/images/63651-20170904225939491-904441630.png" data-fancybox="group" data-caption="image" class="fancybox"><img alt="image" title="image" data-src="/images/63651-20170904225939491-904441630.png" class="lazyload"></a></p><p>一直Next默认就好了，如果需要设置就要仔细读一下安装界面上的选项。</p><h2 id="创建本地项目"><a href="#创建本地项目" class="headerlink" title="创建本地项目"></a>创建本地项目</h2><p>在任意目录下创建文件夹，然后进入文件夹后右键选择Git Bash ，进入git cmd，执行代码git init</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure></div><p><a href="/images/13098542-9ee61d2518499afc.png" data-fancybox="group" data-caption="image" class="fancybox"><img alt="image" title="image" data-src="/images/13098542-9ee61d2518499afc.png" class="lazyload"></a></p><p><strong>这时你会发现test里面多了个.git文件夹，它是Git用来跟踪和管理版本库的。</strong>如果你看不到，是因为它默认是隐藏文件，那你就需要设置一下让隐藏文件可见。</p><p>这时候你就可以把你的项目粘贴到这个本地Git仓库里面（粘贴后你可以通过git status来查看你当前的状态）</p><h2 id="添加项目文件到暂存区"><a href="#添加项目文件到暂存区" class="headerlink" title="添加项目文件到暂存区"></a>添加项目文件到暂存区</h2><p>使用命令 git add . 把项目添加到暂存区里面去，不要忘记后面的小数点“.”，意为添加文件夹下的所有文件</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure></div><p><a href="/images/13098542-aaee408f02dd4e72.png" data-fancybox="group" data-caption="image" class="fancybox"><img alt="image" title="image" data-src="/images/13098542-aaee408f02dd4e72.png" class="lazyload"></a></p><p>在这个过程中你其实可以一直使用git status来查看你当前的状态。</p><h2 id="Commit"><a href="#Commit" class="headerlink" title="Commit"></a>Commit</h2><p>用 git commit -m “第一次提交”把项目提交到仓库。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;第一次提交&quot;</span><br></pre></td></tr></table></figure></div><blockquote><p>-m后面引号里面是本次提交的注释内容，这个可以不写，但最好写上，不然会报错，详情自行Google。 好了，我们本地Git仓库这边的工作做完了，下面就到了连接远程仓库（也就是连接Github）</p></blockquote><p><a href="/images/13098542-fba33f7a8f851b29%5B1%5D.png" data-fancybox="group" data-caption="image" class="fancybox"><img alt="image" title="image" data-src="/images/13098542-fba33f7a8f851b29%5B1%5D.png" class="lazyload"></a></p><h2 id="创建远程仓库"><a href="#创建远程仓库" class="headerlink" title="创建远程仓库"></a>创建远程仓库</h2><p>由于本地Git仓库和Github仓库之间的传输是通过SSH加密的，所以连接时需要设置一下：</p><h3 id="创建SSH-KEY"><a href="#创建SSH-KEY" class="headerlink" title="创建SSH KEY"></a>创建SSH KEY</h3><p>创建SSH KEY。先看一下你C盘用户目录下有没有.ssh目录，有的话看下里面有没有id_rsa和id_rsa.pub这两个文件，有就跳到下一步，没有就通过下面命令创建<br>$ ssh-keygen -t rsa -C “<a href="mailto:t.zhangl@qq.com">t.zhangl@qq.com</a>“</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C &quot;t.zhangl@qq.com&quot;</span><br></pre></td></tr></table></figure></div><h3 id="登录Github"><a href="#登录Github" class="headerlink" title="登录Github"></a>登录Github</h3><p>—&gt;点击右上角的图标 —&gt;选择Settings —&gt;点击左边的SSH and GPG KEYS —&gt;点击右上角的New SSH key —&gt;Title随便填 —&gt;把刚才id_rsa.pub里面的内容复制到Title下面的Key内容框里面 —&gt;最后点击Add SSH key —&gt;完成SSH Key的加密。具体步骤如下：</p><p><a href="/images/13098542-1bd5d81617e91e3e%5B1%5D.png" data-fancybox="group" data-caption="image" class="fancybox"><img alt="image" title="image" data-src="/images/13098542-1bd5d81617e91e3e%5B1%5D.png" class="lazyload"></a></p><h3 id="在Github上创建一个Git仓库。"><a href="#在Github上创建一个Git仓库。" class="headerlink" title="在Github上创建一个Git仓库。"></a>在Github上创建一个Git仓库。</h3><p><a href="/images/13098542-cc9081220c33a824%5B1%5D.png" data-fancybox="group" data-caption="image" class="fancybox"><img alt="image" title="image" data-src="/images/13098542-cc9081220c33a824%5B1%5D.png" class="lazyload"></a></p><h2 id="创建关联"><a href="#创建关联" class="headerlink" title="创建关联"></a>创建关联</h2><p>在Github上创建好Git仓库后通过命令git remote add origin <a href="mailto:git@github.com">git@github.com</a>:linsan925/test.git和本地仓库进行关联</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@github.com:linsan925&#x2F;test.git</span><br></pre></td></tr></table></figure></div><p><a href="/images/13098542-1a0dcf2ee4e03a37%5B1%5D.png" data-fancybox="group" data-caption="image" class="fancybox"><img alt="image" title="image" data-src="/images/13098542-1a0dcf2ee4e03a37%5B1%5D.png" class="lazyload"></a></p><p>注意 origin 后面加的是你Github上创建好的仓库的地址。</p><p><a href="/images/13098542-db664836f0524179%5B1%5D.png" data-fancybox="group" data-caption="image" class="fancybox"><img alt="image" title="image" data-src="/images/13098542-db664836f0524179%5B1%5D.png" class="lazyload"></a></p><h2 id="推送"><a href="#推送" class="headerlink" title="推送"></a>推送</h2><p>关联好之后通过命令git push -u origin master将本地库的所有内容推送到远程仓（Github）</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure></div><p><a href="/images/13098542-c4f5586f356eaaab%5B1%5D.png" data-fancybox="group" data-caption="image" class="fancybox"><img alt="image" title="image" data-src="/images/13098542-c4f5586f356eaaab%5B1%5D.png" class="lazyload"></a></p><blockquote><p>由于新建的远程仓库是空的，所以要加上-u这个参数，等远程仓库里面有了内容之后，下次再从本地库上传内容的时候只需 git push origin master<br>刷新Github页面进入刚才新建的仓库里面就会发现项目已经上传成功</p></blockquote><p><strong><font color="red">注意有坑：</font></strong> 在上面第5步新建远程仓库的时候如果你勾选了Initialize this repository with a README（就是创建仓库的时候自动给你创建一个README文件），那么到了第7步你将本地仓库内容推送到远程仓库的时候就会报一个failed to push some refs to <a href="https://github.com/guyibang/TEST2.git" target="_blank" rel="noopener">https://github.com/guyibang/TEST2.git</a> 的错。</p><p><strong><font color="red">原因：</font></strong> 由于你新创建的那个仓库里面的README文件不在本地仓库目录中，这时我们可以通过<strong>git pull –rebase origin master</strong>命令先将内容合并,此时再push就能成功了。</p><blockquote><p>总结：本地项目通过git上传到github</p><p>1、在本地创建一个版本库（即文件夹），通过git init把它变成Git仓库；<br>2、把项目复制到这个文件夹里面，再通过git add .把项目添加到仓库；<br>3、再通过git commit -m “注释内容”把项目提交到仓库；<br>4、在Github上设置好SSH密钥后，新建一个远程仓库，通过git remote add origin 远程仓库地址将本地仓库和远程仓库进行关联；<br>5、最后通过git push -u origin master把本地仓库的项目推送到远程仓库（也就是Github）上。</p></blockquote><h2 id="克隆仓库-–-git-clone"><a href="#克隆仓库-–-git-clone" class="headerlink" title="克隆仓库 – git clone"></a>克隆仓库 – git clone</h2><p>放在Github上的开源项目，人们可以看到你的代码。可以使用 git clone进行下载到本地。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https:&#x2F;&#x2F;github.com&#x2F;tutorialzine&#x2F;awesome-project.git</span><br></pre></td></tr></table></figure></div><blockquote><p>本地也会创建一个新的仓库，并自动将github上的分支设为远端分支。</p></blockquote><h2 id="从服务器上拉取代码-–-git-pull"><a href="#从服务器上拉取代码-–-git-pull" class="headerlink" title="从服务器上拉取代码 – git pull"></a>从服务器上拉取代码 – git pull</h2><p>如果你更新了代码到仓库上，其他人可以通过git pull命令拉取你的变动：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git pull origin master</span><br><span class="line">From https:&#x2F;&#x2F;github.com&#x2F;tutorialzine&#x2F;awesome-project</span><br><span class="line">* branch            master     -&gt; FETCH_HEAD</span><br><span class="line">Already up-to-date.</span><br></pre></td></tr></table></figure></div><blockquote><p>因为暂时没有其他人提交，所有没有任何变动</p></blockquote><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><p>当你在做一个新功能的时候，最好是在一个独立的区域上开发，通常称之为分支。分支之间相互独立，并且拥有自己的历史记录。这样做的原因是：</p><ul><li>稳定版本的代码不会被破坏</li><li>不同的功能可以由不同开发者同时开发。</li><li>开发者可以专注于自己的分支，不用担心被其他人破坏了环境</li><li>在不确定之前，同一个特性可以拥有几个版本，便于比较</li></ul><h3 id="创建新分支-–-git-branch"><a href="#创建新分支-–-git-branch" class="headerlink" title="创建新分支 – git branch"></a>创建新分支 – git branch</h3><p>每一个仓库的默认分支都叫master, 创建新分支可以这样：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch amazing_new_feature</span><br></pre></td></tr></table></figure></div><blockquote><p>创建了一个名为amazing_new_feature的新分支，它跟当前分支同一起点</p></blockquote><h3 id="切换分支-–-git-checkout"><a href="#切换分支-–-git-checkout" class="headerlink" title="切换分支 – git checkout"></a>切换分支 – git checkout</h3><p>单独使用git branch，可以查看分支状态：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">  amazing_new_feature</span><br><span class="line">* master</span><br></pre></td></tr></table></figure></div><blockquote><p>*号表示当前活跃分支为master，使用git checkout切换分支。</p></blockquote><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout amazing_new_feature</span><br></pre></td></tr></table></figure></div><h3 id="合并分支-–-git-merge"><a href="#合并分支-–-git-merge" class="headerlink" title="合并分支 – git merge"></a>合并分支 – git merge</h3><p>我们的 amazing_new_feature 分支的任务是增加一个featuer.txt。我们来创建，添加到暂存区，提交。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git add feature.txt</span><br><span class="line">$ git commit -m &quot;New feature complete.&quot;</span><br></pre></td></tr></table></figure></div><p>新分支任务完成了，回到master分支</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br></pre></td></tr></table></figure></div><blockquote><p>现在去查看文件，你会发现，之前创建的feature.txt文件不见了，因为master分支上并没有feature.txt。使用git merge 把 amazing_new_feature 分支合并到master上。</p></blockquote><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git merge amazing_new_feature</span><br></pre></td></tr></table></figure></div><p><strong>ok! 然后再把amazing_new_feature 分支删掉吧。</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d amazing_new_feature</span><br></pre></td></tr></table></figure></div><h2 id="高级"><a href="#高级" class="headerlink" title="高级"></a>高级</h2><p>这篇文章的最后一节，我们来说些比较高级并且使用的技巧。</p><h3 id="比对两个不同提交之间的差别"><a href="#比对两个不同提交之间的差别" class="headerlink" title="比对两个不同提交之间的差别"></a>比对两个不同提交之间的差别</h3><p>每次提交都有一个唯一id，查看所有提交和他们的id，可以使用 git log:</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ git log</span><br><span class="line"> </span><br><span class="line">commit ba25c0ff30e1b2f0259157b42b9f8f5d174d80d7</span><br><span class="line">Author: Tutorialzine</span><br><span class="line">Date:   Mon May 30 17:15:28 2016 +0300</span><br><span class="line"> </span><br><span class="line">    New feature complete</span><br><span class="line"> </span><br><span class="line">commit b10cc1238e355c02a044ef9f9860811ff605c9b4</span><br><span class="line">Author: Tutorialzine</span><br><span class="line">Date:   Mon May 30 16:30:04 2016 +0300</span><br><span class="line"> </span><br><span class="line">    Added content to hello.txt</span><br><span class="line"> </span><br><span class="line">commit 09bd8cc171d7084e78e4d118a2346b7487dca059</span><br><span class="line">Author: Tutorialzine</span><br><span class="line">Date:   Sat May 28 17:52:14 2016 +0300</span><br><span class="line"> </span><br><span class="line">    Initial commit</span><br></pre></td></tr></table></figure></div><p>id 很长，但是你并不需要复制整个字符串，前一小部分就够了。</p><p>查看某一次提交更新了什么，使用 git show:</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ git show b10cc123</span><br><span class="line"> </span><br><span class="line">commit b10cc1238e355c02a044ef9f9860811ff605c9b4</span><br><span class="line">Author: Tutorialzine</span><br><span class="line">Date:   Mon May 30 16:30:04 2016 +0300</span><br><span class="line"> </span><br><span class="line">    Added content to hello.txt</span><br><span class="line"> </span><br><span class="line">diff --git a&#x2F;hello.txt b&#x2F;hello.txt</span><br><span class="line">index e69de29..b546a21 100644</span><br><span class="line">--- a&#x2F;hello.txt</span><br><span class="line">+++ b&#x2F;hello.txt</span><br><span class="line">  -0,0 +1</span><br><span class="line">+Nice weather today, isn&#39;t it?</span><br></pre></td></tr></table></figure></div><p>查看两次提交的不同，可以使用git diff [commit-from]..[commit-to] 语法：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git diff 09bd8cc..ba25c0ff</span><br><span class="line"> </span><br><span class="line">diff --git a&#x2F;feature.txt b&#x2F;feature.txt</span><br><span class="line">new file mode 100644</span><br><span class="line">index 0000000..e69de29</span><br><span class="line">diff --git a&#x2F;hello.txt b&#x2F;hello.txt</span><br><span class="line">index e69de29..b546a21 100644</span><br><span class="line">--- a&#x2F;hello.txt</span><br><span class="line">+++ b&#x2F;hello.txt</span><br><span class="line">  -0,0 +1</span><br><span class="line">+Nice weather today, isn&#39;t it?</span><br></pre></td></tr></table></figure></div><p>比较首次提交和最后一次提交，我们可以看到所有的更改。当然使用git difftool命令更加方便。</p><h3 id="回滚某个文件到之前的版本"><a href="#回滚某个文件到之前的版本" class="headerlink" title="回滚某个文件到之前的版本"></a>回滚某个文件到之前的版本</h3><p>git 允许我们将某个特定的文件回滚到特定的提交，使用的也是 git checkout。</p><p>下面的例子，我们将hello.txt回滚到最初的状态，需要指定回滚到哪个提交，以及文件的全路径。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout 09bd8cc1 hello.txt</span><br></pre></td></tr></table></figure></div><h3 id="回滚提交"><a href="#回滚提交" class="headerlink" title="回滚提交"></a>回滚提交</h3><p>如果你发现最新的一次提交完了加某个文件，你可以通过 git commit —amend来修复，它会把最新的提交打回暂存区，并尝试重新提交。<br>如果是更复杂的情况，比如不是最新的提交了。那你可以使用git revert。<br>最新的一次提交别名也叫HEAD。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git revert HEAD</span><br></pre></td></tr></table></figure></div><p>其他提交可以使用id:</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git revert b10cc123</span><br></pre></td></tr></table></figure></div><p>回滚提交时，发生冲突是非常频繁的。当文件被后面的提交修改了以后，git不能正确回滚。</p><h3 id="解决合并冲突"><a href="#解决合并冲突" class="headerlink" title="解决合并冲突"></a>解决合并冲突</h3><p>冲突经常出现在合并分支或者是拉去别人的代码。有些时候git能自动处理冲突，但大部分需要我们手动处理。</p><p>比如John 和 Tim 分别在各自的分支上写了两部分代码。<br>John 喜欢 for:</p><p>// Use a for loop to console.log contents.<br>for(var i=0; i console.log(arr[i]);<br>}<br>Tim 喜欢 forEach:</p><p>// Use forEach to console.log contents.<br>arr.forEach(function(item) {<br>console.log(item);<br>});<br>假设John 现在去拉取 Tim的代码:</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git merge tim_branch</span><br><span class="line"> </span><br><span class="line">Auto-merging print_array.js</span><br><span class="line">CONFLICT (content): Merge conflict in print_array.js</span><br><span class="line">Automatic merge failed; fix conflicts and then commit the result.</span><br></pre></td></tr></table></figure></div><p>这时候git并不知道如何解决冲突，因为他不知道John和Tim谁写得更好。<br>于是它就在代码中插入标记。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">HEAD</span><br><span class="line">&#x2F;&#x2F; Use a for loop to console.log contents.</span><br><span class="line">for(var i&#x3D;0; iarr.length; i++) &#123;</span><br><span class="line">    console.log(arr[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&#x2F;&#x2F; Use forEach to console.log contents.</span><br><span class="line">arr.forEach(function(item) &#123;</span><br><span class="line">    console.log(item);</span><br><span class="line">&#125;);</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; Tim s commit.</span><br></pre></td></tr></table></figure></div><p>==== 号上方是当前最新一次提交，下方是冲突的代码。我们需要解决这样的冲突，经过组委会成员讨论，一致认定，在座的各位都是垃圾！两个都不要。改成下面的代码。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Not using for loop or forEach.</span><br><span class="line">&#x2F;&#x2F; Use Array.toString() to console.log contents.</span><br><span class="line">console.log(arr.toString());</span><br></pre></td></tr></table></figure></div><p>好了，再提交一下：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git add -A</span><br><span class="line">$ git commit -m &quot;Array printing conflict resolved.&quot;</span><br></pre></td></tr></table></figure></div><p>如果在大型项目中，这个过程可能容易出问题。你可以使用<a href="https://git-scm.com/download/gui/linux" target="_blank" rel="noopener">GUI 工具</a>来帮助你。使用 git mergetool。</p><h3 id="配置-gitignore"><a href="#配置-gitignore" class="headerlink" title="配置 .gitignore"></a>配置 .gitignore</h3><p>大部分项目中，会有写文件，文件夹是我们不想提交的。为了防止一不小心提交，我们需要gitignore文件：</p><ol><li>在项目根目录创建.gitignore文件</li><li>在文件中列出不需要提交的文件名，文件夹名，每个一行</li><li>.gitignore文件需要提交，就像普通文件一样</li></ol><p>通常会被ignore的文件有：</p><ul><li>log文件</li><li>task runner builds</li><li>node_modules等文件夹</li><li>IDEs生成的文件</li><li>个人笔记</li></ul><p><strong>例如：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*.log</span><br><span class="line">build&#x2F;</span><br><span class="line">node_modules&#x2F;</span><br><span class="line">.idea&#x2F;</span><br><span class="line">my_notes.txt</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> 代码管理 </category>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> 远程仓库 </tag>
            
            <tag> 代码管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>后端架构师技术图谱</title>
      <link href="/2020/01/04/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84%E5%B8%88%E6%8A%80%E6%9C%AF%E5%9B%BE%E8%B0%B1/"/>
      <url>/2020/01/04/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84%E5%B8%88%E6%8A%80%E6%9C%AF%E5%9B%BE%E8%B0%B1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>最后更新于20180502</strong></p><ul><li><a href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">数据结构</a><ul><li><a href="#%E9%98%9F%E5%88%97">队列</a></li><li><a href="#%E9%9B%86%E5%90%88">集合</a></li><li><a href="#%E9%93%BE%E8%A1%A8%E6%95%B0%E7%BB%84">链表、数组</a></li><li><a href="#%E5%AD%97%E5%85%B8%E5%85%B3%E8%81%94%E6%95%B0%E7%BB%84">字典、关联数组</a></li><li><a href="#%E6%A0%88">栈</a></li><li><a href="#%E6%A0%91">树</a><ul><li><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91">二叉树</a></li><li><a href="#%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91">完全二叉树</a></li><li><a href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91">平衡二叉树</a></li><li><a href="#%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91bst">二叉查找树（BST）</a></li><li><a href="#%E7%BA%A2%E9%BB%91%E6%A0%91">红黑树</a></li><li><a href="#b-bb%E6%A0%91">B-，B+，B*树</a></li><li><a href="#lsm-%E6%A0%91">LSM 树</a></li></ul></li><li><a href="#bitset">BitSet</a></li></ul></li><li><a href="#%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95">常用算法</a><ul><li><a href="#%E6%8E%92%E5%BA%8F%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95">排序、查找算法</a><ul><li><a href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F">选择排序</a></li><li><a href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F">冒泡排序</a></li><li><a href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F">插入排序</a></li><li><a href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F">快速排序</a></li><li><a href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F">归并排序</a></li><li><a href="#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F">希尔排序</a></li><li><a href="#%E5%A0%86%E6%8E%92%E5%BA%8F">堆排序</a></li><li><a href="#%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F">计数排序</a></li><li><a href="#%E6%A1%B6%E6%8E%92%E5%BA%8F">桶排序</a></li><li><a href="#%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F">基数排序</a></li><li><a href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE">二分查找</a></li><li><a href="#java-%E4%B8%AD%E7%9A%84%E6%8E%92%E5%BA%8F%E5%B7%A5%E5%85%B7">Java 中的排序工具</a></li></ul></li><li><a href="#%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8">布隆过滤器</a></li><li><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%83">字符串比较</a><ul><li><a href="#kmp-%E7%AE%97%E6%B3%95">KMP 算法</a></li></ul></li><li><a href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88">深度优先、广度优先</a></li><li><a href="#%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95">贪心算法</a></li><li><a href="#%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95">回溯算法</a></li><li><a href="#%E5%89%AA%E6%9E%9D%E7%AE%97%E6%B3%95">剪枝算法</a></li><li><a href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92">动态规划</a></li><li><a href="#%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF">朴素贝叶斯</a></li><li><a href="#%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%95">推荐算法</a></li><li><a href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%AE%97%E6%B3%95">最小生成树算法</a></li><li><a href="#%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95">最短路径算法</a></li></ul></li><li><a href="#%E5%B9%B6%E5%8F%91">并发</a><ul><li><a href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B">多线程</a></li><li><a href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8">线程安全</a></li><li><a href="#%E4%B8%80%E8%87%B4%E6%80%A7%E4%BA%8B%E5%8A%A1">一致性、事务</a><ul><li><a href="#%E4%BA%8B%E5%8A%A1-acid-%E7%89%B9%E6%80%A7">事务 ACID 特性</a></li><li><a href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB">事务的隔离级别</a></li><li><a href="#mvcc">MVCC</a></li></ul></li><li><a href="#%E9%94%81">锁</a><ul><li><a href="#java%E4%B8%AD%E7%9A%84%E9%94%81%E5%92%8C%E5%90%8C%E6%AD%A5%E7%B1%BB">Java中的锁和同步类</a></li><li><a href="#%E5%85%AC%E5%B9%B3%E9%94%81--%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81">公平锁 &amp; 非公平锁</a></li><li><a href="#%E6%82%B2%E8%A7%82%E9%94%81">悲观锁</a></li><li><a href="#%E4%B9%90%E8%A7%82%E9%94%81--cas">乐观锁 &amp; CAS</a></li><li><a href="#aba-%E9%97%AE%E9%A2%98">ABA 问题</a></li><li><a href="#copyonwrite%E5%AE%B9%E5%99%A8">CopyOnWrite容器</a></li><li><a href="#ringbuffer">RingBuffer</a></li><li><a href="#%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81--%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81">可重入锁 &amp; 不可重入锁</a></li><li><a href="#%E4%BA%92%E6%96%A5%E9%94%81--%E5%85%B1%E4%BA%AB%E9%94%81">互斥锁 &amp; 共享锁</a></li><li><a href="#%E6%AD%BB%E9%94%81">死锁</a></li></ul></li><li><a href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">操作系统</a><ul><li><a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86">计算机原理</a></li><li><a href="#cpu">CPU</a><ul><li><a href="#%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98">多级缓存</a></li></ul></li><li><a href="#%E8%BF%9B%E7%A8%8B">进程</a></li><li><a href="#%E7%BA%BF%E7%A8%8B">线程</a></li><li><a href="#%E5%8D%8F%E7%A8%8B">协程</a></li><li><a href="#linux">Linux</a></li></ul></li><li><a href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F">设计模式</a><ul><li><a href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99">设计模式的六大原则</a></li><li><a href="#23%E7%A7%8D%E5%B8%B8%E8%A7%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F">23种常见设计模式</a></li><li><a href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">应用场景</a></li><li><a href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F">单例模式</a></li><li><a href="#%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F">责任链模式</a></li><li><a href="#mvc">MVC</a></li><li><a href="#ioc">IOC</a></li><li><a href="#aop">AOP</a></li><li><a href="#uml">UML</a></li><li><a href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%80%9D%E6%83%B3">微服务思想</a><ul><li><a href="#%E5%BA%B7%E5%A8%81%E5%AE%9A%E5%BE%8B">康威定律</a></li></ul></li><li><a href="#%E8%BF%90%E7%BB%B4--%E7%BB%9F%E8%AE%A1--%E6%8A%80%E6%9C%AF%E6%94%AF%E6%8C%81">运维 &amp; 统计 &amp; 技术支持</a><ul><li><a href="#%E5%B8%B8%E8%A7%84%E7%9B%91%E6%8E%A7">常规监控</a></li><li><a href="#apm">APM</a></li><li><a href="#%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90">统计分析</a></li><li><a href="#%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90cicd">持续集成(CI/CD)</a><ul><li><a href="#jenkins">Jenkins</a></li><li><a href="#%E7%8E%AF%E5%A2%83%E5%88%86%E7%A6%BB">环境分离</a></li></ul></li><li><a href="#%E8%87%AA%E5%8A%A8%E5%8C%96%E8%BF%90%E7%BB%B4">自动化运维</a><ul><li><a href="#ansible">Ansible</a></li><li><a href="#puppet">puppet</a></li><li><a href="#chef">chef</a></li></ul></li><li><a href="#%E6%B5%8B%E8%AF%95">测试</a><ul><li><a href="#tdd-%E7%90%86%E8%AE%BA">TDD 理论</a></li><li><a href="#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95">单元测试</a></li><li><a href="#%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95">压力测试</a></li><li><a href="#%E5%85%A8%E9%93%BE%E8%B7%AF%E5%8E%8B%E6%B5%8B">全链路压测</a></li><li><a href="#ab-%E7%81%B0%E5%BA%A6%E8%93%9D%E7%BB%BF%E6%B5%8B%E8%AF%95">A/B 、灰度、蓝绿测试</a></li></ul></li><li><a href="#%E8%99%9A%E6%8B%9F%E5%8C%96">虚拟化</a><ul><li><a href="#kvm">KVM</a></li><li><a href="#xen">Xen</a></li><li><a href="#openvz">OpenVZ</a></li></ul></li><li><a href="#%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF">容器技术</a><ul><li><a href="#docker">Docker</a></li></ul></li><li><a href="#%E4%BA%91%E6%8A%80%E6%9C%AF">云技术</a><ul><li><a href="#openstack">OpenStack</a></li></ul></li><li><a href="#devops">DevOps</a></li><li><a href="#%E6%96%87%E6%A1%A3%E7%AE%A1%E7%90%86">文档管理</a></li></ul></li><li><a href="#%E4%B8%AD%E9%97%B4%E4%BB%B6">中间件</a><ul><li><a href="#web-server">Web Server</a><ul><li><a href="#nginx">Nginx</a></li><li><a href="#openresty">OpenResty</a></li><li><a href="#apache-httpd">Apache Httpd</a></li><li><a href="#tomcat">Tomcat</a><ul><li><a href="#%E6%9E%B6%E6%9E%84%E5%8E%9F%E7%90%86">架构原理</a></li><li><a href="#%E8%B0%83%E4%BC%98%E6%96%B9%E6%A1%88">调优方案</a></li></ul></li><li><a href="#jetty">Jetty</a></li></ul></li><li><a href="#%E7%BC%93%E5%AD%98">缓存</a><ul><li><a href="#%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98">本地缓存</a></li></ul></li><li><a href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%BC%93%E5%AD%98">客户端缓存</a></li><li><a href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%BC%93%E5%AD%98">服务端缓存</a><ul><li><a href="#memcached">Memcached</a></li><li><a href="#redis">Redis</a><ul><li><a href="#%E6%9E%B6%E6%9E%84">架构</a></li><li><a href="#%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5">回收策略</a></li></ul></li><li><a href="#tair">Tair</a></li></ul></li><li><a href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97">消息队列</a><ul><li><a href="#%E6%B6%88%E6%81%AF%E6%80%BB%E7%BA%BF">消息总线</a></li><li><a href="#%E6%B6%88%E6%81%AF%E7%9A%84%E9%A1%BA%E5%BA%8F">消息的顺序</a></li><li><a href="#rabbitmq">RabbitMQ</a></li><li><a href="#rocketmq">RocketMQ</a></li><li><a href="#activemq">ActiveMQ</a></li><li><a href="#kafka">Kafka</a></li><li><a href="#redis-%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81">Redis 消息推送</a></li><li><a href="#zeromq">ZeroMQ</a></li></ul></li><li><a href="#%E5%AE%9A%E6%97%B6%E8%B0%83%E5%BA%A6">定时调度</a><ul><li><a href="#%E5%8D%95%E6%9C%BA%E5%AE%9A%E6%97%B6%E8%B0%83%E5%BA%A6">单机定时调度</a></li><li><a href="#%E5%88%86%E5%B8%83%E5%BC%8F%E5%AE%9A%E6%97%B6%E8%B0%83%E5%BA%A6">分布式定时调度</a></li></ul></li><li><a href="#rpc">RPC</a><ul><li><a href="#dubbo">Dubbo</a></li><li><a href="#thrift">Thrift</a></li><li><a href="#grpc">gRPC</a></li></ul></li><li><a href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E9%97%B4%E4%BB%B6">数据库中间件</a><ul><li><a href="#sharding-jdbc">Sharding Jdbc</a></li></ul></li><li><a href="#%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F">日志系统</a><ul><li><a href="#%E6%97%A5%E5%BF%97%E6%90%9C%E9%9B%86">日志搜集</a></li></ul></li><li><a href="#%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83">配置中心</a></li><li><a href="#api-%E7%BD%91%E5%85%B3">API 网关</a></li></ul></li><li><a href="#%E7%BD%91%E7%BB%9C">网络</a><ul><li><a href="#%E5%8D%8F%E8%AE%AE">协议</a><ul><li><a href="#osi-%E4%B8%83%E5%B1%82%E5%8D%8F%E8%AE%AE">OSI 七层协议</a></li><li><a href="#tcpip">TCP/IP</a></li><li><a href="#http">HTTP</a></li><li><a href="#http20">0</a></li><li><a href="#https">HTTPS</a></li></ul></li><li><a href="#%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B">网络模型</a><ul><li><a href="#epoll">Epoll</a></li><li><a href="#java-nio">Java NIO</a></li><li><a href="#kqueue">kqueue</a></li></ul></li><li><a href="#%E8%BF%9E%E6%8E%A5%E5%92%8C%E7%9F%AD%E8%BF%9E%E6%8E%A5">连接和短连接</a></li><li><a href="#%E6%A1%86%E6%9E%B6">框架</a></li><li><a href="#%E9%9B%B6%E6%8B%B7%E8%B4%9Dzero-copy">零拷贝（Zero-copy）</a></li><li><a href="#%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8D%8F%E8%AE%AE">序列化(二进制协议)</a><ul><li><a href="#hessian">Hessian</a></li><li><a href="#protobuf">Protobuf</a></li></ul></li><li><a href="#%E6%95%B0%E6%8D%AE%E5%BA%93">数据库</a><ul><li><a href="#%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA">基础理论</a><ul><li><a href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E8%8C%83%E5%BC%8F">数据库设计的三大范式</a></li></ul></li><li><a href="#mysql">MySQL</a><ul><li><a href="#%E5%8E%9F%E7%90%86">原理</a></li><li><a href="#innodb">InnoDB</a></li><li><a href="#%E4%BC%98%E5%8C%96">优化</a></li><li><a href="#%E7%B4%A2%E5%BC%95">索引</a><ul><li><a href="#%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95-%E9%9D%9E%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95">聚集索引, 非聚集索引</a></li><li><a href="#%E5%A4%8D%E5%90%88%E7%B4%A2%E5%BC%95">复合索引</a></li><li><a href="#%E8%87%AA%E9%80%82%E5%BA%94%E5%93%88%E5%B8%8C%E7%B4%A2%E5%BC%95ahi">自适应哈希索引(AHI)</a></li></ul></li><li><a href="#explain">explain</a></li></ul></li><li><a href="#nosql">NoSQL</a><ul><li><a href="#mongodb">MongoDB</a></li><li><a href="#hbase">Hbase</a></li></ul></li><li><a href="#%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E">搜索引擎</a><ul><li><a href="#%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E5%8E%9F%E7%90%86">搜索引擎原理</a></li><li><a href="#lucene">Lucene</a></li><li><a href="#elasticsearch">Elasticsearch</a></li><li><a href="#solr">Solr</a></li><li><a href="#sphinx">sphinx</a></li></ul></li><li><a href="#%E6%80%A7%E8%83%BD">性能</a><ul><li><a href="#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95%E8%AE%BA">性能优化方法论</a></li><li><a href="#%E5%AE%B9%E9%87%8F%E8%AF%84%E4%BC%B0">容量评估</a></li><li><a href="#cdn-%E7%BD%91%E7%BB%9C">CDN 网络</a></li><li><a href="#%E8%BF%9E%E6%8E%A5%E6%B1%A0">连接池</a></li><li><a href="#%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98">性能调优</a></li></ul></li><li><a href="#%E5%A4%A7%E6%95%B0%E6%8D%AE">大数据</a><ul><li><a href="#%E6%B5%81%E5%BC%8F%E8%AE%A1%E7%AE%97">流式计算</a><ul><li><a href="#storm">Storm</a></li><li><a href="#flink">Flink</a></li><li><a href="#kafka-stream">Kafka Stream</a></li><li><a href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-1">应用场景</a></li></ul></li><li><a href="#hadoop">Hadoop</a><ul><li><a href="#hdfs">HDFS</a></li><li><a href="#mapreduce">MapReduce</a></li><li><a href="#yarn">Yarn</a></li></ul></li><li><a href="#spark">Spark</a></li></ul></li><li><a href="#%E5%AE%89%E5%85%A8">安全</a><ul><li><a href="#web-%E5%AE%89%E5%85%A8">web 安全</a><ul><li><a href="#xss">XSS</a></li><li><a href="#csrf">CSRF</a></li><li><a href="#sql-%E6%B3%A8%E5%85%A5">SQL 注入</a></li><li><a href="#hash-dos">Hash Dos</a></li><li><a href="#%E8%84%9A%E6%9C%AC%E6%B3%A8%E5%85%A5">脚本注入</a></li><li><a href="#%E6%BC%8F%E6%B4%9E%E6%89%AB%E6%8F%8F%E5%B7%A5%E5%85%B7">漏洞扫描工具</a></li><li><a href="#%E9%AA%8C%E8%AF%81%E7%A0%81">验证码</a></li></ul></li><li><a href="#ddos-%E9%98%B2%E8%8C%83">DDoS 防范</a></li><li><a href="#%E7%94%A8%E6%88%B7%E9%9A%90%E7%A7%81%E4%BF%A1%E6%81%AF%E4%BF%9D%E6%8A%A4">用户隐私信息保护</a></li><li><a href="#%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E">序列化漏洞</a></li><li><a href="#%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86">加密解密</a><ul><li><a href="#%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86">对称加密</a></li><li><a href="#%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95">哈希算法</a></li><li><a href="#%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86">非对称加密</a></li></ul></li><li><a href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E5%85%A8">服务器安全</a></li><li><a href="#%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8">数据安全</a><ul><li><a href="#%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD">数据备份</a></li></ul></li><li><a href="#%E7%BD%91%E7%BB%9C%E9%9A%94%E7%A6%BB">网络隔离</a><ul><li><a href="#%E5%86%85%E5%A4%96%E7%BD%91%E5%88%86%E7%A6%BB">内外网分离</a></li><li><a href="#%E7%99%BB%E5%BD%95%E8%B7%B3%E6%9D%BF%E6%9C%BA">登录跳板机</a></li></ul></li><li><a href="#%E6%8E%88%E6%9D%83%E8%AE%A4%E8%AF%81">授权、认证</a><ul><li><a href="#rbac">RBAC</a></li><li><a href="#oauth20">0</a></li><li><a href="#%E5%8F%8C%E5%9B%A0%E7%B4%A0%E8%AE%A4%E8%AF%812fa">双因素认证（2FA）</a></li><li><a href="#%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95sso">单点登录(SSO)</a></li></ul></li><li><a href="#%E5%B8%B8%E7%94%A8%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6">常用开源框架</a><ul><li><a href="#%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE">开源协议</a></li><li><a href="#%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6">日志框架</a><ul><li><a href="#log4jlog4j2">Log4j、Log4j2</a></li><li><a href="#logback">Logback</a></li></ul></li><li><a href="#orm">ORM</a></li><li><a href="#%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6">网络框架</a></li><li><a href="#web-%E6%A1%86%E6%9E%B6">Web 框架</a><ul><li><a href="#spring-%E5%AE%B6%E6%97%8F">Spring 家族</a></li></ul></li><li><a href="#%E5%B7%A5%E5%85%B7%E6%A1%86%E6%9E%B6">工具框架</a></li></ul></li><li><a href="#%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%BE%E8%AE%A1">分布式设计</a><ul><li><a href="#%E6%89%A9%E5%B1%95%E6%80%A7%E8%AE%BE%E8%AE%A1">扩展性设计</a></li><li><a href="#%E7%A8%B3%E5%AE%9A%E6%80%A7--%E9%AB%98%E5%8F%AF%E7%94%A8">稳定性 &amp; 高可用</a><ul><li><a href="#%E7%A1%AC%E4%BB%B6%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1">硬件负载均衡</a></li><li><a href="#%E8%BD%AF%E4%BB%B6%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1">软件负载均衡</a></li><li><a href="#%E9%99%90%E6%B5%81">限流</a></li><li><a href="#%E5%BA%94%E7%94%A8%E5%B1%82%E5%AE%B9%E7%81%BE">应用层容灾</a></li><li><a href="#%E8%B7%A8%E6%9C%BA%E6%88%BF%E5%AE%B9%E7%81%BE">跨机房容灾</a></li><li><a href="#%E5%AE%B9%E7%81%BE%E6%BC%94%E7%BB%83%E6%B5%81%E7%A8%8B">容灾演练流程</a></li><li><a href="#%E5%B9%B3%E6%BB%91%E5%90%AF%E5%8A%A8">平滑启动</a></li></ul></li><li><a href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E6%89%A9%E5%B1%95">数据库扩展</a><ul><li><a href="#%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E6%A8%A1%E5%BC%8F">读写分离模式</a></li><li><a href="#%E5%88%86%E7%89%87%E6%A8%A1%E5%BC%8F">分片模式</a></li></ul></li><li><a href="#%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86">服务治理</a><ul><li><a href="#%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0">服务注册与发现</a></li><li><a href="#%E6%9C%8D%E5%8A%A1%E8%B7%AF%E7%94%B1%E6%8E%A7%E5%88%B6">服务路由控制</a></li></ul></li><li><a href="#%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4">分布式一致</a><ul><li><a href="#cap-%E4%B8%8E-base-%E7%90%86%E8%AE%BA">CAP 与 BASE 理论</a></li><li><a href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81">分布式锁</a></li><li><a href="#%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95">分布式一致性算法</a><ul><li><a href="#paxos">PAXOS</a></li><li><a href="#zab">Zab</a></li><li><a href="#raft">Raft</a></li><li><a href="#gossip">Gossip</a></li><li><a href="#%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4%E5%A4%9A%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4">两阶段提交、多阶段提交</a></li></ul></li><li><a href="#%E5%B9%82%E7%AD%89">幂等</a></li><li><a href="#%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%96%B9%E6%A1%88">分布式一致方案</a></li><li><a href="#%E5%88%86%E5%B8%83%E5%BC%8F-leader-%E8%8A%82%E7%82%B9%E9%80%89%E4%B8%BE">分布式 Leader 节点选举</a></li><li><a href="#tcctryconfirmcancel-%E6%9F%94%E6%80%A7%E4%BA%8B%E5%8A%A1">TCC(Try/Confirm/Cancel) 柔性事务</a></li></ul></li><li><a href="#%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F">分布式文件系统</a></li><li><a href="#%E5%94%AF%E4%B8%80id-%E7%94%9F%E6%88%90">唯一ID 生成</a><ul><li><a href="#%E5%85%A8%E5%B1%80%E5%94%AF%E4%B8%80id">全局唯一ID</a></li></ul></li><li><a href="#%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%AE%97%E6%B3%95">一致性Hash算法</a></li></ul></li><li><a href="#%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3--%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F">设计思想 &amp; 开发模式</a><ul><li><a href="#ddddomain-driven-design---%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1">DDD(Domain-driven Design - 领域驱动设计)</a><ul><li><a href="#%E5%91%BD%E4%BB%A4%E6%9F%A5%E8%AF%A2%E8%81%8C%E8%B4%A3%E5%88%86%E7%A6%BBcqrs">命令查询职责分离(CQRS)</a></li><li><a href="#%E8%B4%AB%E8%A1%80%E5%85%85%E8%A1%80%E6%A8%A1%E5%9E%8B">贫血，充血模型</a></li></ul></li><li><a href="#actor-%E6%A8%A1%E5%BC%8F">Actor 模式</a></li><li><a href="#%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B">响应式编程</a><ul><li><a href="#reactor">Reactor</a></li><li><a href="#rxjava">RxJava</a></li><li><a href="#vertx">x</a></li></ul></li><li><a href="#dodaf20">0</a></li><li><a href="#serverless">Serverless</a></li><li><a href="#service-mesh">Service Mesh</a></li></ul></li><li><a href="#%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86">项目管理</a><ul><li><a href="#%E6%9E%B6%E6%9E%84%E8%AF%84%E5%AE%A1">架构评审</a></li><li><a href="#%E9%87%8D%E6%9E%84">重构</a></li><li><a href="#%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83">代码规范</a></li><li><a href="#%E4%BB%A3%E7%A0%81-review">代码 Review</a></li><li><a href="#rup">RUP</a></li><li><a href="#%E7%9C%8B%E6%9D%BF%E7%AE%A1%E7%90%86">看板管理</a></li><li><a href="#scrum">SCRUM</a></li><li><a href="#%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91">敏捷开发</a></li><li><a href="#%E6%9E%81%E9%99%90%E7%BC%96%E7%A8%8Bxp">极限编程（XP）</a></li><li><a href="#%E7%BB%93%E5%AF%B9%E7%BC%96%E7%A8%8B">结对编程</a></li><li><a href="#fmea%E7%AE%A1%E7%90%86%E6%A8%A1%E5%BC%8F">FMEA管理模式</a></li></ul></li><li><a href="#%E9%80%9A%E7%94%A8%E4%B8%9A%E5%8A%A1%E6%9C%AF%E8%AF%AD">通用业务术语</a></li><li><a href="#%E6%8A%80%E6%9C%AF%E8%B6%8B%E5%8A%BF">技术趋势</a></li><li><a href="#%E6%94%BF%E7%AD%96%E6%B3%95%E8%A7%84">政策、法规</a><ul><li><a href="#%E6%B3%95%E5%BE%8B">法律</a><ul><li><a href="#%E4%B8%A5%E6%A0%BC%E9%81%B5%E5%AE%88%E5%88%91%E6%B3%95253%E6%B3%95%E6%9D%A1">严格遵守刑法253法条</a></li></ul></li><li><a href="#%E6%9E%B6%E6%9E%84%E5%B8%88%E7%B4%A0%E8%B4%A8">架构师素质</a></li><li><a href="#%E5%9B%A2%E9%98%9F%E7%AE%A1%E7%90%86">团队管理</a><ul><li><a href="#%E6%8B%9B%E8%81%98">招聘</a></li></ul></li><li><a href="#%E8%B5%84%E8%AE%AF">资讯</a><ul><li><a href="#%E8%A1%8C%E4%B8%9A%E8%B5%84%E8%AE%AF">行业资讯</a></li><li><a href="#%E5%85%AC%E4%BC%97%E5%8F%B7%E5%88%97%E8%A1%A8">公众号列表</a></li><li><a href="#%E5%8D%9A%E5%AE%A2">博客</a><ul><li><a href="#%E5%9B%A2%E9%98%9F%E5%8D%9A%E5%AE%A2">团队博客</a></li><li><a href="#%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2">个人博客</a></li></ul></li><li><a href="#%E7%BB%BC%E5%90%88%E9%97%A8%E6%88%B7%E7%A4%BE%E5%8C%BA">综合门户、社区</a></li><li><a href="#%E9%97%AE%E7%AD%94%E8%AE%A8%E8%AE%BA%E7%B1%BB%E7%A4%BE%E5%8C%BA">问答、讨论类社区</a></li><li><a href="#%E8%A1%8C%E4%B8%9A%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90">行业数据分析</a></li><li><a href="#%E4%B8%93%E9%A1%B9%E7%BD%91%E7%AB%99">专项网站</a></li><li><a href="#%E5%85%B6%E4%BB%96%E7%B1%BB">其他类</a></li><li><a href="#%E6%8E%A8%E8%8D%90%E5%8F%82%E8%80%83%E4%B9%A6">推荐参考书</a><ul><li><a href="#%E5%9C%A8%E7%BA%BF%E7%94%B5%E5%AD%90%E4%B9%A6">在线电子书</a></li><li><a href="#%E7%BA%B8%E8%B4%A8%E4%B9%A6">纸质书</a><ul><li><a href="#%E5%BC%80%E5%8F%91%E6%96%B9%E9%9D%A2">开发方面</a></li><li><a href="#%E6%9E%B6%E6%9E%84%E6%96%B9%E9%9D%A2">架构方面</a></li><li><a href="#%E6%8A%80%E6%9C%AF%E7%AE%A1%E7%90%86%E6%96%B9%E9%9D%A2">技术管理方面</a></li><li><a href="#%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA-1">基础理论</a></li><li><a href="#%E5%B7%A5%E5%85%B7%E6%96%B9%E9%9D%A2">工具方面</a></li><li><a href="#%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%96%B9%E9%9D%A2">大数据方面</a></li></ul></li><li><a href="#%E6%8A%80%E6%9C%AF%E8%B5%84%E6%BA%90">技术资源</a><ul><li><a href="#%E5%BC%80%E6%BA%90%E8%B5%84%E6%BA%90">开源资源</a></li><li><a href="#%E6%89%8B%E5%86%8C%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B">手册、文档、教程</a></li><li><a href="#%E5%9C%A8%E7%BA%BF%E8%AF%BE%E5%A0%82">在线课堂</a></li><li><a href="#%E4%BC%9A%E8%AE%AE%E6%B4%BB%E5%8A%A8">会议、活动</a></li><li><a href="#%E5%B8%B8%E7%94%A8app">常用APP</a></li><li><a href="#%E6%89%BE%E5%B7%A5%E4%BD%9C">找工作</a></li><li><a href="#%E5%B7%A5%E5%85%B7">工具</a></li><li><a href="#%E4%BB%A3%E7%A0%81%E6%89%98%E7%AE%A1">代码托管</a></li><li><a href="#%E6%96%87%E4%BB%B6%E6%9C%8D%E5%8A%A1">文件服务</a></li><li><a href="#%E7%BB%BC%E5%90%88%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%95%86">综合云服务商</a></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul><p><strong>（Toc generated by **[</strong>simple-php-github-toc<strong>](<a href="https://github.com/xingshaocheng/simple-php-github-toc" target="_blank" rel="noopener">https://github.com/xingshaocheng/simple-php-github-toc</a>)</strong> ）**</p><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a><strong>数据结构</strong></h1><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a><strong>队列</strong></h2><ul><li><a href="https://www.cnblogs.com/lemon-flm/p/7877898.html" target="_blank" rel="noopener">《java队列——queue详细分析》</a><ul><li>非阻塞队列：ConcurrentLinkedQueue(无界线程安全)，采用CAS机制（compareAndSwapObject原子操作）。</li><li>阻塞队列：ArrayBlockingQueue(有界)、LinkedBlockingQueue（无界）、DelayQueue、PriorityBlockingQueue，采用锁机制；使用 ReentrantLock 锁。</li></ul></li><li><a href="https://www.cnblogs.com/mantu/p/5802393.html" target="_blank" rel="noopener">《LinkedList、ConcurrentLinkedQueue、LinkedBlockingQueue对比分析》</a></li></ul><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a><strong>集合</strong></h2><ul><li><a href="https://blog.csdn.net/qq_33642117/article/details/52040345" target="_blank" rel="noopener">《Java Set集合的详解》</a></li></ul><h2 id="链表、数组"><a href="#链表、数组" class="headerlink" title="链表、数组"></a><strong>链表、数组</strong></h2><ul><li><a href="https://blog.csdn.net/wz249863091/article/details/52853360" target="_blank" rel="noopener">《Java集合详解–什么是List》</a></li></ul><h2 id="字典、关联数组"><a href="#字典、关联数组" class="headerlink" title="字典、关联数组"></a><strong>字典、关联数组</strong></h2><ul><li><a href="https://baike.xsoftlab.net/view/250.html" target="_blank" rel="noopener">《Java map 详解 - 用法、遍历、排序、常用API等》</a></li></ul><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a><strong>栈</strong></h2><ul><li><a href="https://blog.csdn.net/javazejian/article/details/53362993" target="_blank" rel="noopener">《java数据结构与算法之栈（Stack）设计与实现》</a></li><li><a href="http://www.runoob.com/java/java-stack-class.html" target="_blank" rel="noopener">《Java Stack 类》</a></li><li><a href="https://blog.csdn.net/f2006116/article/details/51375225" target="_blank" rel="noopener">《java stack的详细实现分析》</a><ul><li>Stack 是线程安全的。</li><li>内部使用数组保存数据，不够时翻倍。</li></ul></li></ul><h2 id="树"><a href="#树" class="headerlink" title="树"></a><strong>树</strong></h2><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a><strong>二叉树</strong></h3><p>每个节点最多有两个叶子节点。</p><ul><li><a href="https://blog.csdn.net/cai2016/article/details/52589952" target="_blank" rel="noopener">《二叉树》</a></li></ul><h3 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a><strong>完全二叉树</strong></h3><ul><li><a href="https://baike.baidu.com/item/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91/7773232?fr=aladdin" target="_blank" rel="noopener">《完全二叉树》</a><ul><li>叶节点只能出现在最下层和次下层，并且最下面一层的结点都集中在该层最左边的若干位置的二叉树。</li></ul></li></ul><h3 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a><strong>平衡二叉树</strong></h3><p>左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</p><ul><li><a href="http://www.cnblogs.com/polly333/p/4798944.html" target="_blank" rel="noopener">《浅谈数据结构-平衡二叉树》</a></li><li><a href="http://www.cnblogs.com/yangecnu/p/Introduce-2-3-Search-Tree.html" target="_blank" rel="noopener">《浅谈算法和数据结构: 八 平衡查找树之2-3树》</a></li></ul><h3 id="二叉查找树（BST）"><a href="#二叉查找树（BST）" class="headerlink" title="二叉查找树（BST）"></a><strong>二叉查找树（BST）</strong></h3><p>二叉查找树（Binary Search Tree），也称有序二叉树（ordered binary tree）,排序二叉树（sorted binary tree）。</p><ul><li><a href="http://www.cnblogs.com/yangecnu/p/Introduce-Binary-Search-Tree.html" target="_blank" rel="noopener">《浅谈算法和数据结构: 七 二叉查找树》</a></li></ul><h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a><strong>红黑树</strong></h3><ul><li><a href="https://blog.csdn.net/sun_tttt/article/details/65445754" target="_blank" rel="noopener">《最容易懂得红黑树》</a><ul><li>添加阶段后，左旋或者右旋从而再次达到平衡。</li></ul></li><li><a href="http://www.cnblogs.com/yangecnu/p/Introduce-Red-Black-Tree.html" target="_blank" rel="noopener">《浅谈算法和数据结构: 九 平衡查找树之红黑树》</a></li></ul><h3 id="B-，B-，B-树"><a href="#B-，B-，B-树" class="headerlink" title="B-，B+，B*树"></a><strong>B-，B+，B*树</strong></h3><p>MySQL是基于B+树聚集索引组织表</p><ul><li><a href="https://blog.csdn.net/aqzwss/article/details/53074186" target="_blank" rel="noopener">《B-树，B+树，B*树详解》</a></li><li><a href="https://blog.csdn.net/bigtree_3721/article/details/73632405" target="_blank" rel="noopener">《B-树，B+树与B*树的优缺点比较》</a><ul><li>B+ 树的叶子节点链表结构相比于 B- 树便于扫库，和范围检索。</li></ul></li></ul><h3 id="LSM-树"><a href="#LSM-树" class="headerlink" title="LSM 树"></a><strong>LSM 树</strong></h3><p>LSM（Log-Structured Merge-Trees）和 B+ 树相比，是牺牲了部分读的性能来换取写的性能(通过批量写入)，实现读写之间的。 Hbase、LevelDB、Tair（Long DB）、nessDB 采用 LSM 树的结构。LSM可以快速建立索引。</p><ul><li><a href="https://blog.csdn.net/dbanote/article/details/8897599" target="_blank" rel="noopener">《LSM树 VS B+树》</a><ul><li>B+ 树读性能好，但由于需要有序结构，当key比较分散时，磁盘寻道频繁，造成写性能。</li><li>LSM 是将一个大树拆分成N棵小树，先写到内存（无寻道问题，性能高），在内存中构建一颗有序小树（有序树），随着小树越来越大，内存的小树会flush到磁盘上。当读时，由于不知道数据在哪棵小树上，因此必须遍历（二分查找）所有的小树，但在每颗小树内部数据是有序的。</li></ul></li><li><a href="https://blog.csdn.net/u014774781/article/details/52105708" target="_blank" rel="noopener">《LSM树（Log-Structured Merge Tree）存储引擎》</a><ul><li>极端的说，基于LSM树实现的HBase的写性能比MySQL高了一个数量级，读性能低了一个数量级。</li><li>优化方式：Bloom filter 替代二分查找；compact 小数位大树，提高查询性能。</li><li>Hbase 中，内存中达到一定阈值后，整体flush到磁盘上、形成一个文件（B+数），HDFS不支持update操作，所以Hbase做整体flush而不是merge update。flush到磁盘上的小树，定期会合并成一个大树。</li></ul></li></ul><h2 id="BitSet"><a href="#BitSet" class="headerlink" title="BitSet"></a><strong>BitSet</strong></h2><p>经常用于大规模数据的排重检查。</p><ul><li><a href="http://www.runoob.com/java/java-bitset-class.html" target="_blank" rel="noopener">《Java Bitset类》</a></li><li><a href="https://blog.csdn.net/caiandyong/article/details/51581160" target="_blank" rel="noopener">《Java BitSet（位集）》</a></li></ul><h1 id="常用算法"><a href="#常用算法" class="headerlink" title="常用算法"></a><strong>常用算法</strong></h1><ul><li><a href="https://blog.csdn.net/gane_cheng/article/details/52652705" target="_blank" rel="noopener">《常见排序算法及对应的时间复杂度和空间复杂度》</a></li></ul><h2 id="排序、查找算法"><a href="#排序、查找算法" class="headerlink" title="排序、查找算法"></a><strong>排序、查找算法</strong></h2><ul><li><a href="https://blog.csdn.net/gane_cheng/article/details/52652705" target="_blank" rel="noopener">《常见排序算法及对应的时间复杂度和空间复杂度》</a></li></ul><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a><strong>选择排序</strong></h3><ul><li><a href="https://www.cnblogs.com/shen-hua/p/5424059.html" target="_blank" rel="noopener">《Java中的经典算法之选择排序（SelectionSort）》</a><ul><li>每一趟从待排序的记录中选出最小的元素，顺序放在已排好序的序列最后，直到全部记录排序完毕。</li></ul></li></ul><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a><strong>冒泡排序</strong></h3><ul><li><a href="https://blog.csdn.net/shuaizai88/article/details/73250615" target="_blank" rel="noopener">《冒泡排序的2种写法》</a><ul><li>相邻元素前后交换、把最大的排到最后。</li><li>时间复杂度 O(n²)</li></ul></li></ul><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a><strong>插入排序</strong></h3><ul><li><a href="https://www.cnblogs.com/hapjin/p/5517667.html" target="_blank" rel="noopener">《排序算法总结之插入排序》</a></li></ul><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a><strong>快速排序</strong></h3><ul><li><a href="http://developer.51cto.com/art/201403/430986.htm" target="_blank" rel="noopener">《坐在马桶上看算法：快速排序》</a><ul><li>一侧比另外一次都大或小。</li></ul></li></ul><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a><strong>归并排序</strong></h3><ul><li><a href="http://www.cnblogs.com/chengxiao/p/6194356.html" target="_blank" rel="noopener">《图解排序算法(四)之归并排序》</a><ul><li>分而治之，分成小份排序，在合并(重建一个新空间进行复制)。</li></ul></li></ul><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a><strong>希尔排序</strong></h3><p>TODO</p><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a><strong>堆排序</strong></h3><ul><li><a href="https://www.cnblogs.com/chengxiao/p/6129630.html" target="_blank" rel="noopener">《图解排序算法(三)之堆排序》</a><ul><li>排序过程就是构建最大堆的过程，最大堆：每个结点的值都大于或等于其左右孩子结点的值，堆顶元素是最大值。</li></ul></li></ul><h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a><strong>计数排序</strong></h3><ul><li><a href="https://www.cnblogs.com/suvllian/p/5495780.html" target="_blank" rel="noopener">《计数排序和桶排序》</a><ul><li>和桶排序过程比较像，差别在于桶的数量。</li></ul></li></ul><h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a><strong>桶排序</strong></h3><ul><li><a href="http://blog.51cto.com/ahalei/1362789" target="_blank" rel="noopener">《【啊哈！算法】最快最简单的排序——桶排序》</a></li><li><a href="https://blog.csdn.net/sunjinshengli/article/details/70738527" target="_blank" rel="noopener">《排序算法（三）：计数排序与桶排序》</a><ul><li>桶排序将[0,1)区间划分为n个相同的大小的子区间，这些子区间被称为桶。</li><li>每个通单独进行排序，然后再遍历每个桶。</li></ul></li></ul><h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a><strong>基数排序</strong></h3><p>按照个位、十位、百位、…依次来排。</p><ul><li><a href="https://blog.csdn.net/lemon_tree12138/article/details/51695211" target="_blank" rel="noopener">《排序算法系列：基数排序》</a></li><li><a href="https://www.cnblogs.com/skywang12345/p/3603669.html" target="_blank" rel="noopener">《基数排序》</a></li></ul><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a><strong>二分查找</strong></h3><ul><li><a href="https://www.cnblogs.com/coderising/p/5708632.html" target="_blank" rel="noopener">《二分查找(java实现)》</a><ul><li>要求待查找的序列有序。</li><li>时间复杂度 O(logN)。</li></ul></li><li><a href="https://blog.csdn.net/maoyuanming0806/article/details/78176957" target="_blank" rel="noopener">《java实现二分查找-两种方式》</a><ul><li>while + 递归。</li></ul></li></ul><h3 id="Java-中的排序工具"><a href="#Java-中的排序工具" class="headerlink" title="Java 中的排序工具"></a><strong>Java 中的排序工具</strong></h3><ul><li><a href="https://blog.csdn.net/u011410529/article/details/56668545?locationnum=6&fps=1" target="_blank" rel="noopener">《sort和Collections.sort实现原理解析》</a><ul><li>sort算法调用的是合并排序。</li><li>sort() 采用了2种排序算法 – 基本类型数据使用快速排序法，对象数组使用归并排序。</li></ul></li></ul><h2 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a><strong>布隆过滤器</strong></h2><p>常用于大数据的排重，比如email，url 等。 核心原理：将每条数据通过计算产生一个指纹（一个字节或多个字节，但一定比原始数据要少很多），其中每一位都是通过随机计算获得，在将指纹映射到一个大的按位存储的空间中。注意：会有一定的错误率。 优点：空间和时间效率都很高。 缺点：随着存入的元素数量增加，误算率随之增加。</p><ul><li><a href="https://segmentfault.com/a/1190000002729689" target="_blank" rel="noopener">《布隆过滤器 -- 空间效率很高的数据结构》</a></li><li><a href="https://blog.csdn.net/zdxiq000/article/details/57626464" target="_blank" rel="noopener">《大量数据去重：Bitmap和布隆过滤器(Bloom Filter)》</a></li><li><a href="https://blog.csdn.net/qq_30242609/article/details/71024458" target="_blank" rel="noopener">《基于Redis的布隆过滤器的实现》</a><ul><li>基于 Redis 的 Bitmap 数据结构。</li></ul></li><li><a href="https://blog.csdn.net/lemon_tree12138/article/details/47973715" target="_blank" rel="noopener">《网络爬虫：URL去重策略之布隆过滤器(BloomFilter)的使用》</a><ul><li>使用Java中的 BitSet 类 和 加权和hash算法。</li></ul></li></ul><h2 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a><strong>字符串比较</strong></h2><h3 id="KMP-算法"><a href="#KMP-算法" class="headerlink" title="KMP 算法"></a><strong>KMP 算法</strong></h3><p>KMP：Knuth-Morris-Pratt算法（简称KMP） 核心原理是利用一个“部分匹配表”，跳过已经匹配过的元素。</p><ul><li><a href="http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html" target="_blank" rel="noopener">《字符串匹配的KMP算法》</a></li></ul><h2 id="深度优先、广度优先"><a href="#深度优先、广度优先" class="headerlink" title="深度优先、广度优先"></a><strong>深度优先、广度优先</strong></h2><ul><li><a href="https://www.cnblogs.com/0kk470/p/7555033.html" target="_blank" rel="noopener">《广度优先搜索BFS和深度优先搜索DFS》</a></li></ul><h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a><strong>贪心算法</strong></h2><ul><li><a href="https://www.cnblogs.com/MrSaver/p/8641971.html" target="_blank" rel="noopener">《算法：贪婪算法基础》</a></li><li><a href="https://blog.csdn.net/a345017062/article/details/52443781" target="_blank" rel="noopener">《常见算法及问题场景——贪心算法》</a></li></ul><h2 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a><strong>回溯算法</strong></h2><ul><li><a href="https://blog.csdn.net/qfikh/article/details/51960331" target="_blank" rel="noopener">《 五大常用算法之四：回溯法》</a></li></ul><h2 id="剪枝算法"><a href="#剪枝算法" class="headerlink" title="剪枝算法"></a><strong>剪枝算法</strong></h2><ul><li><a href="https://blog.csdn.net/luningcsdn/article/details/50930276" target="_blank" rel="noopener">《α-β剪枝算法》</a></li></ul><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a><strong>动态规划</strong></h2><ul><li><a href="https://www.cnblogs.com/little-YTMM/p/5372680.html" target="_blank" rel="noopener">《详解动态规划——邹博讲动态规划》</a></li><li><a href="https://blog.csdn.net/yao_zi_jie/article/details/54580283" target="_blank" rel="noopener">《动态规划算法的个人理解》</a></li></ul><h2 id="朴素贝叶斯"><a href="#朴素贝叶斯" class="headerlink" title="朴素贝叶斯"></a><strong>朴素贝叶斯</strong></h2><ul><li><a href="https://blog.csdn.net/amds123/article/details/70173402" target="_blank" rel="noopener">《带你搞懂朴素贝叶斯分类算法》</a><ul><li>P(B|A)=P(A|B)P(B)/P(A)</li></ul></li><li><a href="http://www.ruanyifeng.com/blog/2011/08/bayesian_inference_part_one.html" target="_blank" rel="noopener">《贝叶斯推断及其互联网应用1》</a></li><li><a href="http://www.ruanyifeng.com/blog/2011/08/bayesian_inference_part_two.html" target="_blank" rel="noopener">《贝叶斯推断及其互联网应用2》</a></li></ul><h2 id="推荐算法"><a href="#推荐算法" class="headerlink" title="推荐算法"></a><strong>推荐算法</strong></h2><ul><li><a href="http://www.infoq.com/cn/articles/recommendation-algorithm-overview-part01" target="_blank" rel="noopener">《推荐算法综述》</a></li><li><a href="https://www.oschina.net/news/51297/top-10-open-source-recommendation-systems" target="_blank" rel="noopener">《TOP 10 开源的推荐系统简介》</a></li></ul><h2 id="最小生成树算法"><a href="#最小生成树算法" class="headerlink" title="最小生成树算法"></a><strong>最小生成树算法</strong></h2><ul><li><a href="https://blog.csdn.net/luoshixian099/article/details/51908175" target="_blank" rel="noopener">《算法导论–最小生成树（Kruskal和Prim算法）》</a></li></ul><h2 id="最短路径算法"><a href="#最短路径算法" class="headerlink" title="最短路径算法"></a><strong>最短路径算法</strong></h2><ul><li><a href="https://blog.csdn.net/qq_35644234/article/details/60870719" target="_blank" rel="noopener">《Dijkstra算法详解》</a></li></ul><h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a><strong>并发</strong></h1><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a><strong>多线程</strong></h2><ul><li><a href="http://www.importnew.com/18459.html" target="_blank" rel="noopener">《40个Java多线程问题总结》</a></li></ul><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a><strong>线程安全</strong></h2><ul><li><a href="https://www.cnblogs.com/zhanht/p/5450325.html" target="_blank" rel="noopener">《Java并发编程——线程安全及解决机制简介》</a></li></ul><h2 id="一致性、事务"><a href="#一致性、事务" class="headerlink" title="一致性、事务"></a><strong>一致性、事务</strong></h2><h3 id="事务-ACID-特性"><a href="#事务-ACID-特性" class="headerlink" title="事务 ACID 特性"></a><strong>事务 ACID 特性</strong></h3><ul><li><a href="https://blog.csdn.net/u012440687/article/details/52116108" target="_blank" rel="noopener">《数据库事务ACID特性》</a></li></ul><h3 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a><strong>事务的隔离级别</strong></h3><ul><li>未提交读：一个事务可以读取另一个未提交的数据，容易出现脏读的情况。</li><li>读提交：一个事务等另外一个事务提交之后才可以读取数据，但会出现不可重复读的情况（多次读取的数据不一致），读取过程中出现UPDATE操作，会多。（大多数数据库默认级别是RC，比如SQL Server，Oracle），读取的时候不可以修改。</li><li>可重复读： 同一个事务里确保每次读取的时候，获得的是同样的数据，但不保障原始数据被其他事务更新（幻读），Mysql InnoDB 就是这个级别。</li><li>序列化：所有事物串行处理（牺牲了效率）</li><li><a href="https://blog.csdn.net/qq_33290787/article/details/51924963" target="_blank" rel="noopener">《理解事务的4种隔离级别》</a></li><li><a href="https://www.cnblogs.com/z-sm/p/7245981.html" target="_blank" rel="noopener">数据库事务的四大特性及事务隔离级别</a></li><li><a href="http://blog.sina.com.cn/s/blog_499740cb0100ugs7.html" target="_blank" rel="noopener">《MySQL的InnoDB的幻读问题 》</a><ul><li>幻读的例子非常清楚。</li><li>通过 SELECT … FOR UPDATE 解决。</li></ul></li><li><a href="http://database.51cto.com/art/201804/570101.htm" target="_blank" rel="noopener">《一篇文章带你读懂MySQL和InnoDB》</a><ul><li>图解脏读、不可重复读、幻读问题。</li></ul></li></ul><h3 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a><strong>MVCC</strong></h3><ul><li><a href="https://www.cnblogs.com/chenpingzhao/p/5065316.html" target="_blank" rel="noopener">《【mysql】关于innodb中MVCC的一些理解》</a><ul><li>innodb 中 MVCC 用在 Repeatable-Read 隔离级别。</li><li>MVCC 会产生幻读问题（更新时异常。）</li></ul></li><li><a href="https://blog.csdn.net/whoamiyang/article/details/51901888" target="_blank" rel="noopener">《轻松理解MYSQL MVCC 实现机制》</a><ul><li>通过隐藏版本列来实现 MVCC 控制，一列记录创建时间、一列记录删除时间，这里的时间</li><li>每次只操作比当前版本小（或等于）的 行。</li></ul></li></ul><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a><strong>锁</strong></h2><h3 id="Java中的锁和同步类"><a href="#Java中的锁和同步类" class="headerlink" title="Java中的锁和同步类"></a><strong>Java中的锁和同步类</strong></h3><ul><li><a href="https://www.cnblogs.com/qifengshi/p/6831055.html" target="_blank" rel="noopener">《Java中的锁分类》</a><ul><li>主要包括 synchronized、ReentrantLock、和 ReadWriteLock。</li></ul></li><li><a href="https://www.cnblogs.com/waterystone/p/4920797.html" target="_blank" rel="noopener">《Java并发之AQS详解》</a></li><li><a href="http://cuisuqiang.iteye.com/blog/2020146" target="_blank" rel="noopener">《Java中信号量 Semaphore》</a><ul><li>有数量控制</li><li>申请用 acquire，申请不要则阻塞；释放用 release。</li></ul></li><li><a href="https://www.cnblogs.com/davidwang456/p/6094947.html" target="_blank" rel="noopener">《java开发中的Mutex vs Semaphore》</a><ul><li>简单的说 就是Mutex是排它的，只有一个可以获取到资源， Semaphore也具有排它性，但可以定义多个可以获取的资源的对象。</li></ul></li></ul><h3 id="公平锁-amp-非公平锁"><a href="#公平锁-amp-非公平锁" class="headerlink" title="公平锁 &amp; 非公平锁"></a><strong>公平锁 &amp; 非公平锁</strong></h3><p>公平锁的作用就是严格按照线程启动的顺序来执行的，不允许其他线程插队执行的；而非公平锁是允许插队的。</p><ul><li><a href="https://blog.csdn.net/EthanWhite/article/details/55508357" target="_blank" rel="noopener">《公平锁与非公平锁》</a><ul><li>默认情况下 ReentrantLock 和 synchronized 都是非公平锁。ReentrantLock 可以设置成公平锁。</li></ul></li></ul><h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a><strong>悲观锁</strong></h3><p>悲观锁如果使用不当（锁的条数过多），会引起服务大面积等待。推荐优先使用乐观锁+重试。</p><ul><li><a href="https://www.cnblogs.com/zhiqian-ali/p/6200874.html" target="_blank" rel="noopener">《【MySQL】悲观锁&amp;乐观锁》</a><ul><li>乐观锁的方式：版本号+重试方式</li><li>悲观锁：通过 select … for update 进行行锁(不可读、不可写，share 锁可读不可写)。</li></ul></li><li><a href="https://www.cnblogs.com/Lawson/p/5008741.html" target="_blank" rel="noopener">《Mysql查询语句使用select.. for update导致的数据库死锁分析》</a><ul><li>mysql的innodb存储引擎实务锁虽然是锁行，但它内部是锁索引的。</li><li>锁相同数据的不同索引条件可能会引起死锁。</li></ul></li><li><a href="https://www.cnblogs.com/zejin2008/p/5262751.html" target="_blank" rel="noopener">《Mysql并发时经典常见的死锁原因及解决方法》</a></li></ul><h3 id="乐观锁-amp-CAS"><a href="#乐观锁-amp-CAS" class="headerlink" title="乐观锁 &amp; CAS"></a><strong>乐观锁 &amp; CAS</strong></h3><ul><li><a href="http://www.importnew.com/20472.html" target="_blank" rel="noopener">《乐观锁的一种实现方式——CAS》</a><ul><li>和MySQL乐观锁方式相似，只不过是通过和原值进行比较。</li></ul></li></ul><h3 id="ABA-问题"><a href="#ABA-问题" class="headerlink" title="ABA 问题"></a><strong>ABA 问题</strong></h3><p>由于高并发，在CAS下，更新后可能此A非彼A。通过版本号可以解决，类似于上文Mysql 中提到的的乐观锁。</p><ul><li><a href="https://www.cnblogs.com/549294286/p/3766717.html" target="_blank" rel="noopener">《Java CAS 和ABA问题》</a></li><li><a href="https://blog.csdn.net/li954644351/article/details/50511879" target="_blank" rel="noopener">《Java 中 ABA问题及避免》</a><ul><li>AtomicStampedReference 和 AtomicStampedReference。</li></ul></li></ul><h3 id="CopyOnWrite容器"><a href="#CopyOnWrite容器" class="headerlink" title="CopyOnWrite容器"></a><strong>CopyOnWrite容器</strong></h3><p>可以对CopyOnWrite容器进行并发的读，而不需要加锁。CopyOnWrite并发容器用于读多写少的并发场景。比如白名单，黑名单，商品类目的访问和更新场景，不适合需要数据强一致性的场景。</p><ul><li><a href="https://www.cnblogs.com/hapjin/p/4840107.html" target="_blank" rel="noopener">《JAVA中写时复制(Copy-On-Write)Map实现》</a><ul><li>实现读写分离，读取发生在原始数据上，写入发生在副本上。</li><li>不用加锁，通过最终一致实现一致性。</li></ul></li><li><a href="https://blog.csdn.net/a494303877/article/details/53404623" target="_blank" rel="noopener">《聊聊并发-Java中的Copy-On-Write容器》</a></li></ul><h3 id="RingBuffer"><a href="#RingBuffer" class="headerlink" title="RingBuffer"></a><strong>RingBuffer</strong></h3><ul><li><a href="http://www.cnblogs.com/l00l/p/4115001.html" target="_blank" rel="noopener">《线程安全的无锁RingBuffer的实现【一个读线程，一个写线程】》</a></li></ul><h3 id="可重入锁-amp-不可重入锁"><a href="#可重入锁-amp-不可重入锁" class="headerlink" title="可重入锁 &amp; 不可重入锁"></a><strong>可重入锁 &amp; 不可重入锁</strong></h3><ul><li><a href="https://www.cnblogs.com/dj3839/p/6580765.html" target="_blank" rel="noopener">《可重入锁和不可重入锁》</a><ul><li>通过简单代码举例说明可重入锁和不可重入锁。</li><li>可重入锁指同一个线程可以再次获得之前已经获得的锁。</li><li>可重入锁可以用户避免死锁。</li><li>Java中的可重入锁：synchronized 和 java.util.concurrent.locks.ReentrantLock</li></ul></li><li><a href="https://www.cnblogs.com/baizhanshi/p/7211802.html" target="_blank" rel="noopener">《ReenTrantLock可重入锁（和synchronized的区别）总结》</a><ul><li>synchronized 使用方便，编译器来加锁，是非公平锁。</li><li>ReenTrantLock 使用灵活，锁的公平性可以定制。</li><li>相同加锁场景下，推荐使用 synchronized。</li></ul></li></ul><h3 id="互斥锁-amp-共享锁"><a href="#互斥锁-amp-共享锁" class="headerlink" title="互斥锁 &amp; 共享锁"></a><strong>互斥锁 &amp; 共享锁</strong></h3><p>互斥锁：同时只能有一个线程获得锁。比如，ReentrantLock 是互斥锁，ReadWriteLock 中的写锁是互斥锁。 共享锁：可以有多个线程同时或的锁。比如，Semaphore、CountDownLatch 是共享锁，ReadWriteLock 中的读锁是共享锁。</p><ul><li><a href="https://www.cnblogs.com/liang1101/p/6475555.html" target="_blank" rel="noopener">《ReadWriteLock场景应用》</a></li></ul><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a><strong>死锁</strong></h3><ul><li><a href="https://blog.csdn.net/yunfenglw/article/details/45950305" target="_blank" rel="noopener">《“死锁”四个必要条件的合理解释》</a><ul><li>互斥、持有、不可剥夺、不可剥夺。</li></ul></li><li><a href="https://blog.csdn.net/u014039577/article/details/52351626" target="_blank" rel="noopener">Java如何查看死锁？</a><ul><li>JConsole 可以识别死锁。</li></ul></li><li><a href="https://blog.csdn.net/bohu83/article/details/51135061" target="_blank" rel="noopener">java多线程系列：死锁及检测</a><ul><li>jstack 可以显示死锁。</li></ul></li></ul><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a><strong>操作系统</strong></h1><h2 id="计算机原理"><a href="#计算机原理" class="headerlink" title="计算机原理"></a><strong>计算机原理</strong></h2><ul><li><a href="https://segmentfault.com/a/1190000003692840" target="_blank" rel="noopener">《操作系统基础知识——操作系统的原理，类型和结构》</a></li></ul><h2 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a><strong>CPU</strong></h2><h3 id="多级缓存"><a href="#多级缓存" class="headerlink" title="多级缓存"></a><strong>多级缓存</strong></h3><p>典型的 CPU 有三级缓存，举例核心越近，速度越快，空间越小。L1 一般 32k，L2 一般 256k，L3 一般12M。内存速度需要200个 CPU 周期，CPU 缓存需要1个CPU周期。</p><ul><li><a href="https://blog.csdn.net/zero__007/article/details/54089730" target="_blank" rel="noopener">《从Java视角理解CPU缓存和伪共享》</a></li></ul><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a><strong>进程</strong></h2><p>TODO</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a><strong>线程</strong></h2><ul><li><a href="https://blog.csdn.net/asdf_1024/article/details/78978437" target="_blank" rel="noopener">《线程的生命周期及状态转换详解》</a></li></ul><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a><strong>协程</strong></h2><ul><li><a href="https://www.thinksaas.cn/group/topic/839375/" target="_blank" rel="noopener">《终结python协程—-从yield到actor模型的实现》</a><ul><li>线程的调度是由操作系统负责，协程调度是程序自行负责</li><li>与线程相比，协程减少了无畏的操作系统切换.</li><li>实际上当遇到IO操作时做切换才更有意义，（因为IO操作不用占用CPU），如果没遇到IO操作，按照时间片切换.</li></ul></li></ul><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a><strong>Linux</strong></h2><ul><li><a href="http://www.runoob.com/linux/linux-command-manual.html" target="_blank" rel="noopener">《Linux 命令大全》</a></li></ul><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a><strong>设计模式</strong></h1><h2 id="设计模式的六大原则"><a href="#设计模式的六大原则" class="headerlink" title="设计模式的六大原则"></a><strong>设计模式的六大原则</strong></h2><ul><li><a href="https://blog.csdn.net/q291611265/article/details/48465113" target="_blank" rel="noopener">《设计模式的六大原则》</a><ul><li>开闭原则：对扩展开放,对修改关闭，多使用抽象类和接口。</li><li>里氏代换原则：基类可以被子类替换，使用抽象类继承,不使用具体类继承。</li><li>依赖倒转原则：要依赖于抽象,不要依赖于具体，针对接口编程,不针对实现编程。</li><li>接口隔离原则：使用多个隔离的接口,比使用单个接口好，建立最小的接口。</li><li>迪米特法则：一个软件实体应当尽可能少地与其他实体发生相互作用，通过中间类建立联系。</li><li>合成复用原则：尽量使用合成/聚合,而不是使用继承，尽量使用合成/聚合,而不是使用继承。</li></ul></li></ul><h2 id="23种常见设计模式"><a href="#23种常见设计模式" class="headerlink" title="23种常见设计模式"></a><strong>23种常见设计模式</strong></h2><ul><li><a href="http://www.runoob.com/design-pattern/design-pattern-tutorial.html" target="_blank" rel="noopener">《设计模式》</a></li><li><a href="https://www.cnblogs.com/susanws/p/5510229.html" target="_blank" rel="noopener">《23种设计模式全解析》</a></li></ul><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a><strong>应用场景</strong></h2><ul><li><a href="http://blog.jobbole.com/62314/" target="_blank" rel="noopener">《细数JDK里的设计模式》</a><ul><li>结构型模式：<ul><li>适配器：用来把一个接口转化成另一个接口，如util.Arrays#asList()。</li><li>桥接模式：这个模式将抽象和抽象操作的实现进行了解耦，这样使得抽象和实现可以独立地变化，如JDBC；</li><li>组合模式：使得客户端看来单个对象和对象的组合是同等的。换句话说，某个类型的方法同时也接受自身类型作为参数，如putAll，List.addAll、Set.addAll。</li><li>装饰者模式：动态的给一个对象附加额外的功能，这也是子类的一种替代方式，如util.Collections#checkedList|Map|Set|SortedSet|SortedMap。</li><li>享元模式：使用缓存来加速大量小对象的访问时间，如 valueOf(int)。</li><li>代理模式：代理模式是用一个简单的对象来代替一个复杂的或者创建耗时的对象，如lang.reflect.Proxy</li></ul></li><li>创建模式:<ul><li>抽象工厂模式：抽象工厂模式提供了一个协议来生成一系列的相关或者独立的对象，而不用指定具体对象的类型，如util.Calendar#getInstance()。</li><li>建造模式(Builder)：定义了一个新的类来构建另一个类的实例，以简化复杂对象的创建，如：java.lang.StringBuilder#append()。</li><li>工厂方法：就是<strong>一个返</strong>* 回具体对象的方法，而不是多个，如 java.lang.Object#toString()、java.lang.Class#newInstance()。</li><li>原型模式：使得类的实例能够生成自身的拷贝、如：lang.Object#clone()。</li><li>单例模式：全局只有一个实例，如lang.Runtime#getRuntime()。</li></ul></li><li>行为模式：<ul><li>责任链模式：通过把请求从一个对象传递到链条中下一个对象的方式，直到请求被处理完毕，以实现对象间的解耦。如servlet.Filter#doFilter()。</li><li>命令模式：将操作封装到对象内，以便存储，传递和返回，如：lang.Runnable。</li><li>解释器模式：定义了一个语言的语法，然后解析相应语法的语句，如，text.Format，java.text.Normalizer。</li><li>迭代器模式：提供一个一致的方法来顺序访问集合中的对象，如util.Iterator。</li><li>中介者模式：通过使用一个中间对象来进行消息分发以及减少类之间的直接依赖，lang.reflect.Method#invoke()。</li><li>空对象模式：如util.Collections#emptyList()。</li><li>观察者模式：它使得一个对象可以灵活的将消息发送给感兴趣的对象，如util.EventListener。</li><li>模板方法模式：让子类可以重写方法的一部分，而不是整个重写，如util.Collections#sort()。</li></ul></li><li><a href="https://www.cnblogs.com/hwaggLee/p/4510687.html" target="_blank" rel="noopener">《Spring-涉及到的设计模式汇总》</a></li><li><a href="https://blog.csdn.net/u012387062/article/details/54719114" target="_blank" rel="noopener">《Mybatis使用的设计模式》</a></li></ul></li></ul><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a><strong>单例模式</strong></h2><ul><li><a href="https://blog.csdn.net/YECrazy/article/details/79481964" target="_blank" rel="noopener">《单例模式的三种实现 以及各自的优缺点》</a></li><li><a href="https://www.cnblogs.com/ttylinux/p/6498822.html" target="_blank" rel="noopener">《单例模式－－反射－－防止序列化破坏单例模式》</a><ul><li>使用枚举类型。</li></ul></li></ul><h2 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a><strong>责任链模式</strong></h2><p>TODO</p><h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a><strong>MVC</strong></h2><ul><li><a href="http://www.runoob.com/design-pattern/mvc-pattern.html" target="_blank" rel="noopener">《MVC 模式》</a><ul><li>模型(model)－视图(view)－控制器(controller)</li></ul></li></ul><h2 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a><strong>IOC</strong></h2><ul><li><a href="https://www.zhihu.com/question/23277575" target="_blank" rel="noopener">《理解 IOC》</a></li><li><a href="https://www.cnblogs.com/NancyStartOnce/p/6813162.html" target="_blank" rel="noopener">《IOC 的理解与解释》</a><ul><li>正向控制：传统通过new的方式。反向控制，通过容器注入对象。</li><li>作用：用于模块解耦。</li><li>DI：Dependency Injection，即依赖注入，只关心资源使用，不关心资源来源。</li></ul></li></ul><h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a><strong>AOP</strong></h2><ul><li><a href="https://my.oschina.net/yanquan345/blog/203415" target="_blank" rel="noopener">《轻松理解AOP(面向切面编程)》</a></li><li><a href="https://www.cnblogs.com/hongwz/p/5764917.html" target="_blank" rel="noopener">《Spring AOP详解》</a></li><li><a href="http://www.importnew.com/24305.html" target="_blank" rel="noopener">《Spring AOP的实现原理》</a><ul><li>Spring AOP使用的动态代理，主要有两种方式：JDK动态代理和CGLIB动态代理。</li></ul></li><li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-springaopcglib/" target="_blank" rel="noopener">《Spring AOP 实现原理与 CGLIB 应用》</a><ul><li>Spring AOP 框架对 AOP 代理类的处理原则是：如果目标对象的实现类实现了接口，Spring AOP 将会采用 JDK 动态代理来生成 AOP 代理类；如果目标对象的实现类没有实现接口，Spring AOP 将会采用 CGLIB 来生成 AOP 代理类</li></ul></li></ul><h2 id="UML"><a href="#UML" class="headerlink" title="UML"></a><strong>UML</strong></h2><ul><li><a href="https://www.w3cschool.cn/uml_tutorial/" target="_blank" rel="noopener">《UML教程》</a></li></ul><h2 id="微服务思想"><a href="#微服务思想" class="headerlink" title="微服务思想"></a><strong>微服务思想</strong></h2><ul><li><a href="https://www.cnblogs.com/wintersun/p/6219259.html" target="_blank" rel="noopener">《微服务架构设计》</a></li><li><a href="http://www.infoq.com/cn/articles/micro-service-technology-stack" target="_blank" rel="noopener">《微服务架构技术栈选型手册》</a></li></ul><h3 id="康威定律"><a href="#康威定律" class="headerlink" title="康威定律"></a><strong>康威定律</strong></h3><ul><li><a href="https://yq.aliyun.com/articles/8611" target="_blank" rel="noopener">《微服务架构的理论基础 - 康威定律》</a><ul><li>定律一：组织沟通方式会通过系统设计表达出来，就是说架构的布局和组织结构会有相似。</li><li>定律二：时间再多一件事情也不可能做的完美，但总有时间做完一件事情。一口气吃不成胖子，先搞定能搞定的。</li><li>定律三：线型系统和线型组织架构间有潜在的异质同态特性。种瓜得瓜，做独立自治的子系统减少沟通成本。</li><li>定律四：大的系统组织总是比小系统更倾向于分解。合久必分，分而治之。</li></ul></li><li><a href="https://static.geekbang.org/PDF-%E4%BF%AE%E6%94%B9%E7%89%88-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4-%E5%9B%BE%E7%89%87-%E6%9D%A8%E6%B3%A2-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84.pdf" target="_blank" rel="noopener">《微服务架构核⼼20讲》</a></li></ul><h1 id="运维-amp-统计-amp-技术支持"><a href="#运维-amp-统计-amp-技术支持" class="headerlink" title="运维 &amp; 统计 &amp; 技术支持"></a><strong>运维 &amp; 统计 &amp; 技术支持</strong></h1><h2 id="常规监控"><a href="#常规监控" class="headerlink" title="常规监控"></a><strong>常规监控</strong></h2><ul><li><a href="https://blog.csdn.net/enweitech/article/details/77849205" target="_blank" rel="noopener">《腾讯业务系统监控的修炼之路》</a><ul><li>监控的方式：主动、被动、旁路(比如舆情监控)</li><li>监控类型： 基础监控、服务端监控、客户端监控、 监控、用户端监控</li><li>监控的目标：全、块、准</li><li>核心指标：请求量、成功率、耗时</li></ul></li><li><a href="https://www.oschina.net/news/67525/monitoring-tools" target="_blank" rel="noopener">《开源还是商用？十大云运维监控工具横评》</a><ul><li>Zabbix、Nagios、Ganglia、Zenoss、Open-falcon、监控宝、 360网站服务监控、阿里云监控、百度云观测、小蜜蜂网站监测等。</li></ul></li><li><a href="http://developer.51cto.com/art/201612/525373.htm" target="_blank" rel="noopener">《监控报警系统搭建及二次开发经验》</a></li></ul><p><strong>命令行监控工具</strong></p><ul><li><a href="https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/44-an-quan-yu-yun-wei/445-fu-wu-qi-zhuang-tai-jian-ce/4451-ming-ling-xing-gong-ju.html" target="_blank" rel="noopener">《常用命令行监控工具》</a><ul><li>top、sar、tsar、nload</li></ul></li><li><a href="http://blog.jobbole.com/96846/" target="_blank" rel="noopener">《20个命令行工具监控 Linux 系统性能》</a></li><li><a href="https://my.oschina.net/feichexia/blog/196575" target="_blank" rel="noopener">《JVM性能调优监控工具jps、jstack、jmap、jhat、jstat、hprof使用详解》</a></li></ul><h2 id="APM"><a href="#APM" class="headerlink" title="APM"></a><strong>APM</strong></h2><p>APM — Application Performance Management</p><ul><li><a href="http://bigbully.github.io/Dapper-translation/" target="_blank" rel="noopener">《Dapper，大规模分布式系统的跟踪系统》</a></li><li><a href="http://opentracing.io/" target="_blank" rel="noopener">CNCF OpenTracing</a>，<a href="https://github.com/opentracing-contrib/opentracing-specification-zh" target="_blank" rel="noopener">中文版</a></li><li>主要开源软件，按字母排序<ul><li><a href="https://github.com/apache/incubator-skywalking" target="_blank" rel="noopener">Apache SkyWalking</a></li><li><a href="https://github.com/dianping/cat" target="_blank" rel="noopener">CAT</a></li><li><a href="https://github.com/jaegertracing/jaeger" target="_blank" rel="noopener">CNCF jaeger</a></li><li><a href="https://github.com/naver/pinpoint" target="_blank" rel="noopener">Pinpoint</a></li><li><a href="https://github.com/openzipkin/zipkin" target="_blank" rel="noopener">Zipkin</a></li></ul></li><li><a href="http://www.infoq.com/cn/articles/apm-Pinpoint-practice" target="_blank" rel="noopener">《开源APM技术选型与实战》</a><ul><li>主要基于 Google的Dapper（大规模分布式系统的跟踪系统） 思想。</li></ul></li></ul><h2 id="统计分析"><a href="#统计分析" class="headerlink" title="统计分析"></a><strong>统计分析</strong></h2><ul><li><a href="https://zhuanlan.zhihu.com/p/25195217" target="_blank" rel="noopener">《流量统计的基础：埋点》</a><ul><li>常用指标：访问与访客、停留时长、跳出率、退出率、转化率、参与度</li></ul></li><li><a href="http://www.25xt.com/company/17066.html" target="_blank" rel="noopener">《APP埋点常用的统计工具、埋点目标和埋点内容》</a><ul><li>第三方统计：友盟、百度移动、魔方、App Annie、talking data、神策数据等。</li></ul></li><li><a href="https://tech.meituan.com/mt-mobile-analytics-practice.html" target="_blank" rel="noopener">《美团点评前端无痕埋点实践》</a><ul><li>所谓无痕、即通过可视化工具配置采集节点，在前端自动解析配置并上报埋点数据，而非硬编码。</li></ul></li></ul><h2 id="持续集成-CI-CD"><a href="#持续集成-CI-CD" class="headerlink" title="持续集成(CI/CD)"></a><strong>持续集成(CI/CD)</strong></h2><ul><li><a href="http://www.ruanyifeng.com/blog/2015/09/continuous-integration.html" target="_blank" rel="noopener">《持续集成是什么？》</a></li><li><a href="https://www.testwo.com/article/1170" target="_blank" rel="noopener">《8个流行的持续集成工具》</a></li></ul><h3 id="Jenkins"><a href="#Jenkins" class="headerlink" title="Jenkins"></a><strong>Jenkins</strong></h3><ul><li><a href="https://www.liaoxuefeng.com/article/001463233913442cdb2d1bd1b1b42e3b0b29eb1ba736c5e000" target="_blank" rel="noopener">《使用Jenkins进行持续集成》</a></li></ul><h3 id="环境分离"><a href="#环境分离" class="headerlink" title="环境分离"></a><strong>环境分离</strong></h3><p>开发、测试、生成环境分离。</p><ul><li><a href="https://my.oschina.net/sancuo/blog/214904" target="_blank" rel="noopener">《开发环境、生产环境、测试环境的基本理解和区》</a></li></ul><h2 id="自动化运维"><a href="#自动化运维" class="headerlink" title="自动化运维"></a><strong>自动化运维</strong></h2><h3 id="Ansible"><a href="#Ansible" class="headerlink" title="Ansible"></a><strong>Ansible</strong></h3><ul><li><a href="http://www.ansible.com.cn/" target="_blank" rel="noopener">《Ansible中文权威指南》</a></li><li><a href="https://www.cnblogs.com/heiye123/articles/7855890.html" target="_blank" rel="noopener">《Ansible基础配置和企业级项目实用案例》</a></li></ul><h3 id="puppet"><a href="#puppet" class="headerlink" title="puppet"></a><strong>puppet</strong></h3><ul><li><a href="https://www.cnblogs.com/keerya/p/8040071.html" target="_blank" rel="noopener">《自动化运维工具——puppet详解》</a></li></ul><h3 id="chef"><a href="#chef" class="headerlink" title="chef"></a><strong>chef</strong></h3><ul><li><a href="https://www.ibm.com/developerworks/cn/cloud/library/1407_caomd_chef/" target="_blank" rel="noopener">《Chef 的安装与使用》</a></li></ul><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a><strong>测试</strong></h2><h3 id="TDD-理论"><a href="#TDD-理论" class="headerlink" title="TDD 理论"></a><strong>TDD 理论</strong></h3><ul><li><a href="https://www.jianshu.com/p/62f16cd4fef3" target="_blank" rel="noopener">《深度解读 - TDD（测试驱动开发）》</a><ul><li>基于测试用例编码功能代码，XP（Extreme Programming）的核心实践.</li><li>好处：一次关注一个点，降低思维负担；迎接需求变化或改善代码的设计；提前澄清需求；快速反馈；</li></ul></li></ul><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a><strong>单元测试</strong></h3><ul><li><a href="https://www.cnblogs.com/happyzm/p/6482886.html" target="_blank" rel="noopener">《Java单元测试之JUnit篇》</a></li><li><a href="https://blog.csdn.net/hotdust/article/details/53406086" target="_blank" rel="noopener">《JUnit 4 与 TestNG 对比》</a><ul><li>TestNG 覆盖 JUnit 功能，适用于更复杂的场景。</li></ul></li><li><a href="https://blog.csdn.net/wqetfg/article/details/50900512" target="_blank" rel="noopener">《单元测试主要的测试功能点》</a><ul><li>模块接口测试、局部数据结构测试、路径测试 、错误处理测试、边界条件测试 。</li></ul></li></ul><h3 id="压力测试"><a href="#压力测试" class="headerlink" title="压力测试"></a><strong>压力测试</strong></h3><ul><li><a href="https://blog.csdn.net/blueheart20/article/details/52170790" target="_blank" rel="noopener">《Apache ab 测试使用指南》</a></li><li><a href="https://www.cnblogs.com/binyue/p/6141088.html" target="_blank" rel="noopener">《大型网站压力测试及优化方案》</a></li><li><a href="http://news.chinabyte.com/466/14126966.shtml" target="_blank" rel="noopener">《10大主流压力/负载/性能测试工具推荐》</a></li><li><a href="http://quentinxxz.iteye.com/blog/2249799" target="_blank" rel="noopener">《真实流量压测工具 tcpcopy应用浅析》</a></li><li><a href="https://www.cnblogs.com/jwentest/p/7136727.html" target="_blank" rel="noopener">《nGrinder 简易使用教程》</a></li></ul><h3 id="全链路压测"><a href="#全链路压测" class="headerlink" title="全链路压测"></a><strong>全链路压测</strong></h3><ul><li><a href="http://www.infoq.com/cn/articles/jd-618-upgrade-full-link-voltage-test-program-forcebot" target="_blank" rel="noopener">《京东618：升级全链路压测方案，打造军演机器人ForceBot》</a></li><li><a href="https://zhuanlan.zhihu.com/p/30306892" target="_blank" rel="noopener">《饿了么全链路压测的探索与实践》</a></li><li><a href="https://zhuanlan.zhihu.com/p/28355759" target="_blank" rel="noopener">《四大语言，八大框架｜滴滴全链路压测解决之道》</a></li><li><a href="https://www.jianshu.com/p/27060fd61f72" target="_blank" rel="noopener">《全链路压测经验》</a></li></ul><h3 id="A-B-、灰度、蓝绿测试"><a href="#A-B-、灰度、蓝绿测试" class="headerlink" title="A/B 、灰度、蓝绿测试"></a><strong>A/B 、灰度、蓝绿测试</strong></h3><ul><li><a href="https://testerhome.com/topics/11165" target="_blank" rel="noopener">《技术干货 | AB 测试和灰度发布探索及实践》</a></li><li><a href="http://blog.51cto.com/purplegrape/1403123" target="_blank" rel="noopener">《nginx 根据IP 进行灰度发布》</a></li><li><a href="https://www.v2ex.com/t/344341" target="_blank" rel="noopener">《蓝绿部署、A/B 测试以及灰度发布》</a></li></ul><h2 id="虚拟化"><a href="#虚拟化" class="headerlink" title="虚拟化"></a><strong>虚拟化</strong></h2><ul><li><a href="https://blog.csdn.net/enweitech/article/details/52910082" target="_blank" rel="noopener">《VPS的三种虚拟技术OpenVZ、Xen、KVM优缺点比较》</a></li></ul><h3 id="KVM"><a href="#KVM" class="headerlink" title="KVM"></a><strong>KVM</strong></h3><ul><li><a href="http://blog.chinaunix.net/uid-20201831-id-5775661.html" target="_blank" rel="noopener">《KVM详解，太详细太深入了，经典》</a></li><li><a href="https://www.coderxing.com/kvm-install.html" target="_blank" rel="noopener">《【图文】KVM 虚拟机安装详解》</a></li></ul><h3 id="Xen"><a href="#Xen" class="headerlink" title="Xen"></a><strong>Xen</strong></h3><ul><li><a href="https://www.cnblogs.com/sddai/p/5931201.html" target="_blank" rel="noopener">《Xen虚拟化基本原理详解》</a></li></ul><h3 id="OpenVZ"><a href="#OpenVZ" class="headerlink" title="OpenVZ"></a><strong>OpenVZ</strong></h3><ul><li><a href="https://blog.csdn.net/longerzone/article/details/44829255" target="_blank" rel="noopener">《开源Linux容器 OpenVZ 快速上手指南》</a></li></ul><h2 id="容器技术"><a href="#容器技术" class="headerlink" title="容器技术"></a><strong>容器技术</strong></h2><h3 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a><strong>Docker</strong></h3><ul><li><a href="https://www.cnblogs.com/SzeCheng/p/6822905.html" target="_blank" rel="noopener">《几张图帮你理解 docker 基本原理及快速入门》</a></li><li><a href="https://draveness.me/docker" target="_blank" rel="noopener">《Docker 核心技术与实现原理》</a></li><li><a href="http://www.runoob.com/docker/docker-tutorial.html" target="_blank" rel="noopener">《Docker 教程》</a></li></ul><h2 id="云技术"><a href="#云技术" class="headerlink" title="云技术"></a><strong>云技术</strong></h2><h3 id="OpenStack"><a href="#OpenStack" class="headerlink" title="OpenStack"></a><strong>OpenStack</strong></h3><ul><li><a href="https://www.cnblogs.com/klb561/p/8660264.html" target="_blank" rel="noopener">《OpenStack构架知识梳理》</a></li></ul><h2 id="DevOps"><a href="#DevOps" class="headerlink" title="DevOps"></a><strong>DevOps</strong></h2><ul><li><a href="https://www.cnblogs.com/jetzhang/p/6068773.html" target="_blank" rel="noopener">《一分钟告诉你究竟DevOps是什么鬼？》</a></li><li><a href="http://www.infoq.com/cn/articles/detail-analysis-of-devops" target="_blank" rel="noopener">《DevOps详解》</a></li></ul><h2 id="文档管理"><a href="#文档管理" class="headerlink" title="文档管理"></a><strong>文档管理</strong></h2><ul><li><a href="http://www.confluence.cn/" target="_blank" rel="noopener">Confluence-收费文档管理系统</a></li><li>GitLab?</li><li>Wiki</li></ul><h1 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a><strong>中间件</strong></h1><h2 id="Web-Server"><a href="#Web-Server" class="headerlink" title="Web Server"></a><strong>Web Server</strong></h2><h3 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a><strong>Nginx</strong></h3><ul><li><a href="https://blog.csdn.net/qq_25797077/article/details/52200722" target="_blank" rel="noopener">《Ngnix的基本学习-多进程和Apache的比较》</a><ul><li>Nginx 通过异步非阻塞的事件处理机制实现高并发。Apache 每个请求独占一个线程，非常消耗系统资源。</li><li>事件驱动适合于IO密集型服务(Nginx)，多进程或线程适合于CPU密集型服务(Apache)，所以Nginx适合做反向代理，而非web服务器使用。</li></ul></li><li><a href="https://www.cnblogs.com/cunkouzh/p/5410154.html" target="_blank" rel="noopener">《nginx与Apache的对比以及优缺点》</a><ul><li>nginx只适合静态和反向代理，不适合处理动态请求。</li></ul></li></ul><h3 id="OpenResty"><a href="#OpenResty" class="headerlink" title="OpenResty"></a><strong>OpenResty</strong></h3><ul><li><a href="http://openresty.org/cn/" target="_blank" rel="noopener">官方网站</a></li><li><a href="http://www.linkedkeeper.com/detail/blog.action?bid=1034" target="_blank" rel="noopener">《浅谈 OpenResty》</a><ul><li>通过 Lua 模块可以在Nginx上进行开发。</li></ul></li></ul><h3 id="Apache-Httpd"><a href="#Apache-Httpd" class="headerlink" title="Apache Httpd"></a><strong>Apache Httpd</strong></h3><ul><li><a href="http://httpd.apache.org/" target="_blank" rel="noopener">官方网站</a></li></ul><h3 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a><strong>Tomcat</strong></h3><h4 id="架构原理"><a href="#架构原理" class="headerlink" title="架构原理"></a><strong>架构原理</strong></h4><ul><li><a href="https://www.cnblogs.com/hggen/p/6264475.html" target="_blank" rel="noopener">《TOMCAT原理详解及请求过程》</a></li><li><a href="https://www.cnblogs.com/crazylqy/p/4706223.html" target="_blank" rel="noopener">《Tomcat服务器原理详解》</a></li><li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-tomcat1/" target="_blank" rel="noopener">《Tomcat 系统架构与设计模式,第 1 部分: 工作原理》</a></li><li><a href="https://blog.csdn.net/xlgen157387/article/details/79006434" target="_blank" rel="noopener">《四张图带你了解Tomcat系统架构》</a></li><li><a href="https://www.futurehosting.com/blog/jboss-vs-tomcat-choosing-a-java-application-server/" target="_blank" rel="noopener">《JBoss vs. Tomcat: Choosing A Java Application Server》</a><ul><li>Tomcat 是轻量级的 Serverlet 容器，没有实现全部 JEE 特性（比如持久化和事务处理），但可以通过其他组件代替，比如Srping。</li><li>Jboss 实现全部了JEE特性，软件开源免费、文档收费。</li></ul></li></ul><h4 id="调优方案"><a href="#调优方案" class="headerlink" title="调优方案"></a><strong>调优方案</strong></h4><ul><li><a href="https://www.cnblogs.com/sunfenqing/p/7339058.html" target="_blank" rel="noopener">《Tomcat 调优方案》</a><ul><li>启动NIO模式（或者APR）；调整线程池；禁用AJP连接器（Nginx+tomcat的架构，不需要AJP）；</li></ul></li><li><a href="http://blog.chinaunix.net/uid-20662363-id-3012760.html" target="_blank" rel="noopener">《tomcat http协议与ajp协议》</a></li><li><a href="http://dmouse.iteye.com/blog/1354527" target="_blank" rel="noopener">《AJP与HTTP比较和分析》</a><ul><li>AJP 协议（8009端口）用于降低和前端Server（如Apache，而且需要支持AJP协议）的连接数(前端)，通过长连接提高性能。</li><li>并发高时，AJP协议优于HTTP协议。</li></ul></li></ul><h3 id="Jetty"><a href="#Jetty" class="headerlink" title="Jetty"></a><strong>Jetty</strong></h3><ul><li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-jetty/" target="_blank" rel="noopener">《Jetty 的工作原理以及与 Tomcat 的比较》</a></li><li><a href="https://blog.csdn.net/doutao6677/article/details/51957288" target="_blank" rel="noopener">《jetty和tomcat优势比较》</a><ul><li>架构比较:Jetty的架构比Tomcat的更为简单。</li><li>性能比较：Jetty和Tomcat性能方面差异不大，Jetty默认采用NIO结束在处理I/O请求上更占优势，Tomcat默认采用BIO处理I/O请求，Tomcat适合处理少数非常繁忙的链接，处理静态资源时性能较差。</li><li>其他方面：Jetty的应用更加快速，修改简单，对新的Servlet规范的支持较好;Tomcat 对JEE和Servlet 支持更加全面。</li></ul></li></ul><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a><strong>缓存</strong></h2><ul><li><a href="https://blog.csdn.net/clementad/article/details/48229243" target="_blank" rel="noopener">《缓存失效策略（FIFO 、LRU、LFU三种算法的区别）》</a></li></ul><h3 id="本地缓存"><a href="#本地缓存" class="headerlink" title="本地缓存"></a><strong>本地缓存</strong></h3><ul><li><a href="https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/421-ying-yong-ceng-ben-di-huan-cun/4211.html" target="_blank" rel="noopener">《HashMap本地缓存》</a></li><li><a href="https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/421-ying-yong-ceng-ben-di-huan-cun/4212-ehcache.html" target="_blank" rel="noopener">《EhCache本地缓存》</a><ul><li>堆内、堆外、磁盘三级缓存。</li><li>可按照缓存空间容量进行设置。</li><li>按照时间、次数等过期策略。</li></ul></li><li><a href="https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/421-ying-yong-ceng-ben-di-huan-cun/4213-guava-cache.html" target="_blank" rel="noopener">《Guava Cache》</a><ul><li>简单轻量、无堆外、磁盘缓存。</li></ul></li><li><a href="https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/422-fu-wu-duan-ben-di-huan-cun/nginx-ben-di-huan-cun.html" target="_blank" rel="noopener">《Nginx本地缓存》</a></li><li><a href="https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/422-fu-wu-duan-ben-di-huan-cun/4222-pagespeed.html" target="_blank" rel="noopener">《Pagespeed—懒人工具，服务器端加速》</a></li></ul><h2 id="客户端缓存"><a href="#客户端缓存" class="headerlink" title="客户端缓存"></a><strong>客户端缓存</strong></h2><ul><li><a href="https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/423-ke-hu-duan-huan-cun.html" target="_blank" rel="noopener">《浏览器端缓存》</a><ul><li>主要是利用 Cache-Control 参数。</li></ul></li><li><a href="https://mp.weixin.qq.com/s/qHm_dJBhVbv0pJs8Crp77w" target="_blank" rel="noopener">《H5 和移动端 WebView 缓存机制解析与实战》</a></li></ul><h2 id="服务端缓存"><a href="#服务端缓存" class="headerlink" title="服务端缓存"></a><strong>服务端缓存</strong></h2><h3 id="Memcached"><a href="#Memcached" class="headerlink" title="Memcached"></a><strong>Memcached</strong></h3><ul><li><a href="http://www.runoob.com/Memcached/Memcached-tutorial.html" target="_blank" rel="noopener">《Memcached 教程》</a></li><li><a href="https://blog.csdn.net/chenleixing/article/details/47035453" target="_blank" rel="noopener">《深入理解Memcached原理》</a><ul><li>采用多路复用技术提高并发性。</li><li>slab分配算法： memcached给Slab分配内存空间，默认是1MB。分配给Slab之后 把slab的切分成大小相同的chunk，Chunk是用于缓存记录的内存空间，Chunk 的大小默认按照1.25倍的速度递增。好处是不会频繁申请内存，提高IO效率，坏处是会有一定的内存浪费。</li></ul></li><li><a href="https://www.jianshu.com/p/36e5cd400580" target="_blank" rel="noopener">《Memcached软件工作原理》</a></li><li><a href="http://zhihuzeye.com/archives/2361" target="_blank" rel="noopener">《Memcache技术分享：介绍、使用、存储、算法、优化、命中率》</a></li><li><a href="https://blog.csdn.net/liu251890347/article/details/37690045" target="_blank" rel="noopener">《memcache 中 add 、 set 、replace 的区别》</a><ul><li>区别在于当key存在还是不存在时，返回值是true和false的。</li></ul></li><li>[<strong>《memcached全面剖析》</strong>](<a href="https://pan.baidu.com/s/1qX00Lti?errno=0&amp;errmsg=Auth" target="_blank" rel="noopener">https://pan.baidu.com/s/1qX00Lti?errno=0&amp;errmsg=Auth</a> Login Sucess&amp;&amp;bduss=&amp;ssnerror=0&amp;traceid=)</li></ul><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a><strong>Redis</strong></h3><ul><li><a href="http://www.runoob.com/redis/redis-tutorial.html" target="_blank" rel="noopener">《Redis 教程》</a></li><li><a href="https://blog.csdn.net/wcf373722432/article/details/78678504" target="_blank" rel="noopener">《redis底层原理》</a><ul><li>使用 ziplist 存储链表，ziplist是一种压缩链表，它的好处是更能节省内存空间，因为它所存储的内容都是在连续的内存区域当中的。</li><li>使用 skiplist(跳跃表)来存储有序集合对象、查找上先从高Level查起、时间复杂度和红黑树相当，实现容易，无锁、并发性好。</li></ul></li><li><a href="http://doc.redisfans.com/topic/persistence.html" target="_blank" rel="noopener">《Redis持久化方式》</a><ul><li>RDB方式：定期备份快照，常用于灾难恢复。优点：通过fork出的进程进行备份，不影响主进程、RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。缺点：会丢数据。</li><li>AOF方式：保存操作日志方式。优点：恢复时数据丢失少，缺点：文件大，回复慢。</li><li>也可以两者结合使用。</li></ul></li><li><a href="https://blog.csdn.net/chunlongyu/article/details/53346436" target="_blank" rel="noopener">《分布式缓存–序列3–原子操作与CAS乐观锁》</a></li></ul><h4 id="架构"><a href="#架构" class="headerlink" title="架构"></a><strong>架构</strong></h4><ul><li><a href="https://blog.csdn.net/sunhuiliang85/article/details/73656830" target="_blank" rel="noopener">《Redis单线程架构》</a></li></ul><h4 id="回收策略"><a href="#回收策略" class="headerlink" title="回收策略"></a><strong>回收策略</strong></h4><ul><li><a href="https://blog.csdn.net/qq_29108585/article/details/63251491" target="_blank" rel="noopener">《redis的回收策略》</a></li></ul><h3 id="Tair"><a href="#Tair" class="headerlink" title="Tair"></a><strong>Tair</strong></h3><ul><li><a href="https://github.com/alibaba/tair" target="_blank" rel="noopener">官方网站</a></li><li><a href="http://blog.csdn.net/farphone/article/details/53522383" target="_blank" rel="noopener">《Tair和Redis的对比》</a></li><li>特点：可以配置备份节点数目，通过异步同步到备份节点</li><li>一致性Hash算法。</li><li>架构：和Hadoop 的设计思想类似，有Configserver，DataServer，Configserver 通过心跳来检测，Configserver也有主备关系。</li></ul><p>几种存储引擎:</p><ul><li>MDB，完全内存性，可以用来存储Session等数据。</li><li>Rdb（类似于Redis），轻量化，去除了aof之类的操作，支持Restfull操作</li><li>LDB（LevelDB存储引擎），持久化存储，LDB 作为rdb的持久化，google实现，比较高效，理论基础是LSM(Log-Structured-Merge Tree)算法，现在内存中修改数据，达到一定量时（和内存汇总的旧数据一同写入磁盘）再写入磁盘，存储更加高效，县比喻Hash算法。</li><li>Tair采用共享内存来存储数据，如果服务挂掉（非服务器），重启服务之后，数据亦然还在。</li></ul><h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a><strong>消息队列</strong></h2><ul><li><a href="https://www.cnblogs.com/charlesblc/p/6045238.html" target="_blank" rel="noopener">《消息队列-推/拉模式学习 &amp; ActiveMQ及JMS学习》</a><ul><li>RabbitMQ 消费者默认是推模式（也支持拉模式）。</li><li>Kafka 默认是拉模式。</li><li>Push方式：优点是可以尽可能快地将消息发送给消费者，缺点是如果消费者处理能力跟不上，消费者的缓冲区可能会溢出。</li><li>Pull方式：优点是消费端可以按处理能力进行拉去，缺点是会增加消息延迟。</li></ul></li><li><a href="https://blog.csdn.net/yunfeng482/article/details/72856762" target="_blank" rel="noopener">《Kafka、RabbitMQ、RocketMQ等消息中间件的对比 —— 消息发送性能和区别》</a></li></ul><h3 id="消息总线"><a href="#消息总线" class="headerlink" title="消息总线"></a><strong>消息总线</strong></h3><p>消息总线相当于在消息队列之上做了一层封装，统一入口，统一管控、简化接入成本。</p><ul><li><a href="https://blog.csdn.net/yanghua_kobe/article/details/43877281" target="_blank" rel="noopener">《消息总线VS消息队列》</a></li></ul><h3 id="消息的顺序"><a href="#消息的顺序" class="headerlink" title="消息的顺序"></a><strong>消息的顺序</strong></h3><ul><li><a href="https://www.cnblogs.com/cjsblog/p/8267892.html" target="_blank" rel="noopener">《如何保证消费者接收消息的顺序》</a></li></ul><h3 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a><strong>RabbitMQ</strong></h3><p>支持事务，推拉模式都是支持、适合需要可靠性消息传输的场景。</p><ul><li><a href="https://blog.csdn.net/whoamiyang/article/details/54954780" target="_blank" rel="noopener">《RabbitMQ的应用场景以及基本原理介绍》</a></li><li><a href="https://www.jianshu.com/p/79ca08116d57" target="_blank" rel="noopener">《消息队列之 RabbitMQ》</a></li><li><a href="https://blog.csdn.net/u013256816/article/details/55515234" target="_blank" rel="noopener">《RabbitMQ之消息确认机制（事务+Confirm）》</a></li></ul><h3 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a><strong>RocketMQ</strong></h3><p>Java实现，推拉模式都是支持，吞吐量逊于Kafka。可以保证消息顺序。</p><ul><li><a href="https://www.jianshu.com/p/824066d70da8" target="_blank" rel="noopener">《RocketMQ 实战之快速入门》</a></li></ul><h3 id="ActiveMQ"><a href="#ActiveMQ" class="headerlink" title="ActiveMQ"></a><strong>ActiveMQ</strong></h3><p>纯Java实现，兼容JMS，可以内嵌于Java应用中。</p><ul><li><a href="https://www.cnblogs.com/wintersun/p/3962302.html" target="_blank" rel="noopener">《ActiveMQ消息队列介绍》</a></li></ul><h3 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a><strong>Kafka</strong></h3><p>高吞吐量、采用拉模式。适合搞IO场景，比如日志同步。</p><ul><li><a href="http://kafka.apache.org/" target="_blank" rel="noopener">官方网站</a></li><li><a href="https://blog.csdn.net/allthesametome/article/details/47362451" target="_blank" rel="noopener">《各消息队列对比，Kafka深度解析，众人推荐，精彩好文！》</a></li><li><a href="http://lxw1234.com/archives/2015/10/538.htm" target="_blank" rel="noopener">《Kafka分区机制介绍与示例》</a></li></ul><h3 id="Redis-消息推送"><a href="#Redis-消息推送" class="headerlink" title="Redis 消息推送"></a><strong>Redis 消息推送</strong></h3><p>生产者、消费者模式完全是客户端行为，list 和 拉模式实现，阻塞等待采用 blpop 指令。</p><ul><li><a href="https://blog.csdn.net/qq_34212276/article/details/78455004" target="_blank" rel="noopener">《Redis学习笔记之十：Redis用作消息队列》</a></li></ul><h3 id="ZeroMQ"><a href="#ZeroMQ" class="headerlink" title="ZeroMQ"></a><strong>ZeroMQ</strong></h3><p>TODO</p><h2 id="定时调度"><a href="#定时调度" class="headerlink" title="定时调度"></a><strong>定时调度</strong></h2><h3 id="单机定时调度"><a href="#单机定时调度" class="headerlink" title="单机定时调度"></a><strong>单机定时调度</strong></h3><ul><li><a href="https://www.cnblogs.com/shuaiqing/p/7742382.html" target="_blank" rel="noopener">《linux定时任务cron配置》</a></li><li><a href="https://my.oschina.net/daquan/blog/483305" target="_blank" rel="noopener">《Linux cron运行原理》</a><ul><li>fork 进程 + sleep 轮询</li></ul></li><li><a href="https://www.cnblogs.com/drift-ice/p/3817269.html" target="_blank" rel="noopener">《Quartz使用总结》</a></li><li><a href="https://blog.csdn.net/wenniuwuren/article/details/42082981/" target="_blank" rel="noopener">《Quartz源码解析 —- 触发器按时启动原理》</a></li><li><a href="https://www.jianshu.com/p/bab8e4e32952" target="_blank" rel="noopener">《quartz原理揭秘和源码解读》</a><ul><li>定时调度在 QuartzSchedulerThread 代码中，while()无限循环，每次循环取出时间将到的trigger，触发对应的job，直到调度器线程被关闭。</li></ul></li></ul><h3 id="分布式定时调度"><a href="#分布式定时调度" class="headerlink" title="分布式定时调度"></a><strong>分布式定时调度</strong></h3><ul><li><a href="https://blog.csdn.net/qq_16216221/article/details/70314337" target="_blank" rel="noopener">《这些优秀的国产分布式任务调度系统，你用过几个？》</a><ul><li>opencron、LTS、XXL-JOB、Elastic-Job、Uncode-Schedule、Antares</li></ul></li><li><a href="https://www.cnblogs.com/zhenyuyaodidiao/p/4755649.html" target="_blank" rel="noopener">《Quartz任务调度的基本实现原理》</a><ul><li>Quartz集群中，独立的Quartz节点并不与另一其的节点或是管理节点通信，而是通过相同的数据库表来感知到另一Quartz应用的</li></ul></li></ul><h2 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a><strong>RPC</strong></h2><ul><li><a href="https://blog.csdn.net/top_code/article/details/54615853" target="_blank" rel="noopener">《从零开始实现RPC框架 - RPC原理及实现》</a><ul><li>核心角色：Server: 暴露服务的服务提供方、Client: 调用远程服务的服务消费方、Registry: 服务注册与发现的注册中心。</li></ul></li><li><a href="https://blog.csdn.net/testcs_dn/article/details/78050590" target="_blank" rel="noopener">《分布式RPC框架性能大比拼 dubbo、motan、rpcx、gRPC、thrift的性能比较》</a></li></ul><h3 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a><strong>Dubbo</strong></h3><ul><li><a href="http://dubbo.apache.org/" target="_blank" rel="noopener">官方网站</a></li><li><a href="https://www.cnblogs.com/steven520213/p/7606598.html" target="_blank" rel="noopener">dubbo实现原理简单介绍</a></li></ul><p>** SPI ** TODO</p><h3 id="Thrift"><a href="#Thrift" class="headerlink" title="Thrift"></a><strong>Thrift</strong></h3><ul><li><a href="http://thrift.apache.org/" target="_blank" rel="noopener">官方网站</a></li><li><a href="https://blog.csdn.net/kesonyk/article/details/50924489" target="_blank" rel="noopener">《Thrift RPC详解》</a><ul><li>支持多语言，通过中间语言定义接口。</li></ul></li></ul><h3 id="gRPC"><a href="#gRPC" class="headerlink" title="gRPC"></a><strong>gRPC</strong></h3><p>服务端可以认证加密，在外网环境下，可以保证数据安全。</p><ul><li><a href="https://grpc.io/" target="_blank" rel="noopener">官方网站</a></li><li><a href="https://www.cnblogs.com/LBSer/p/4853234.html" target="_blank" rel="noopener">《你应该知道的RPC原理》</a></li></ul><h2 id="数据库中间件"><a href="#数据库中间件" class="headerlink" title="数据库中间件"></a><strong>数据库中间件</strong></h2><h3 id="Sharding-Jdbc"><a href="#Sharding-Jdbc" class="headerlink" title="Sharding Jdbc"></a><strong>Sharding Jdbc</strong></h3><ul><li><a href="http://shardingjdbc.io/" target="_blank" rel="noopener">官网</a></li></ul><h2 id="日志系统"><a href="#日志系统" class="headerlink" title="日志系统"></a><strong>日志系统</strong></h2><h3 id="日志搜集"><a href="#日志搜集" class="headerlink" title="日志搜集"></a><strong>日志搜集</strong></h3><ul><li><a href="http://cjting.me/misc/build-log-system-with-elkb/" target="_blank" rel="noopener">《从零开始搭建一个ELKB日志收集系统》</a></li><li><a href="https://blog.csdn.net/lzw_2006/article/details/51280058" target="_blank" rel="noopener">《用ELK搭建简单的日志收集分析系统》</a></li><li><a href="https://www.cnblogs.com/beginmind/p/6058194.html" target="_blank" rel="noopener">《日志收集系统-探究》</a></li></ul><h2 id="配置中心"><a href="#配置中心" class="headerlink" title="配置中心"></a><strong>配置中心</strong></h2><ul><li><a href="https://github.com/ctripcorp/apollo" target="_blank" rel="noopener">Apollo - 携程开源的配置中心应用</a><ul><li>Spring Boot 和 Spring Cloud</li><li>支持推、拉模式更新配置</li><li>支持多种语言</li></ul></li><li><a href="https://blog.csdn.net/u011320740/article/details/78742625" target="_blank" rel="noopener">《基于zookeeper实现统一配置管理》</a></li><li><a href="https://www.cnblogs.com/shamo89/p/8016908.html" target="_blank" rel="noopener">《 Spring Cloud Config 分布式配置中心使用教程》</a></li></ul><p>servlet 3.0 异步特性可用于配置中心的客户端</p><ul><li><a href="https://www.cnblogs.com/dogdogwang/p/7151866.html" target="_blank" rel="noopener">《0 新特性——异步处理》</a></li></ul><h2 id="API-网关"><a href="#API-网关" class="headerlink" title="API 网关"></a><strong>API 网关</strong></h2><p>主要职责：请求转发、安全认证、协议转换、容灾。</p><ul><li><a href="http://yunlzheng.github.io/2017/03/14/the-things-about-api-gateway/" target="_blank" rel="noopener">《API网关那些儿》</a></li><li><a href="http://www.infoq.com/cn/news/2016/07/API-background-architecture-floo" target="_blank" rel="noopener">《谈API网关的背景、架构以及落地方案》</a></li><li><a href="https://blog.csdn.net/zhanglh046/article/details/78651993" target="_blank" rel="noopener">《使用Zuul构建API Gateway》</a></li><li><a href="https://mp.weixin.qq.com/s/LIq2CiXJQmmjBC0yvYLY5A" target="_blank" rel="noopener">《HTTP API网关选择之一Kong介绍》</a></li></ul><h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a><strong>网络</strong></h1><h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a><strong>协议</strong></h2><h3 id="OSI-七层协议"><a href="#OSI-七层协议" class="headerlink" title="OSI 七层协议"></a><strong>OSI 七层协议</strong></h3><ul><li><a href="https://www.cnblogs.com/Robin-YB/p/6668762.html" target="_blank" rel="noopener">《OSI七层协议模型、TCP/IP四层模型学习笔记》</a></li></ul><h3 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a><strong>TCP/IP</strong></h3><ul><li><a href="https://www.cnblogs.com/onepixel/p/7092302.html" target="_blank" rel="noopener">《深入浅出 TCP/IP 协议》</a></li><li><a href="https://blog.csdn.net/whuslei/article/details/6667471/" target="_blank" rel="noopener">《TCP协议中的三次握手和四次挥手》</a></li></ul><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a><strong>HTTP</strong></h3><ul><li><a href="https://www.cnblogs.com/wangning528/p/6388464.html" target="_blank" rel="noopener">《http协议详解(超详细)》</a></li></ul><h3 id="HTTP2-0"><a href="#HTTP2-0" class="headerlink" title="HTTP2.0"></a><strong>HTTP2.0</strong></h3><ul><li><a href="https://blog.csdn.net/zhuyiquan/article/details/69257126" target="_blank" rel="noopener">《HTTP 2.0 原理详细分析》</a></li><li><a href="https://blog.csdn.net/u012657197/article/details/77877840" target="_blank" rel="noopener">《0的基本单位为二进制帧》</a><ul><li>利用二进制帧负责传输。</li><li>多路复用。</li></ul></li></ul><h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a><strong>HTTPS</strong></h3><ul><li><a href="https://www.cnblogs.com/zhangshitong/p/6478721.html" target="_blank" rel="noopener">《https原理通俗了解》</a><ul><li>使用非对称加密协商加密算法</li><li>使用对称加密方式传输数据</li><li>使用第三方机构签发的证书，来加密公钥，用于公钥的安全传输、防止被中间人串改。</li></ul></li><li><a href="https://blog.csdn.net/enweitech/article/details/53213862" target="_blank" rel="noopener">《八大免费SSL证书-给你的网站免费添加Https安全加密》</a></li></ul><h2 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a><strong>网络模型</strong></h2><ul><li><a href="http://blog.51cto.com/litaotao/1289790" target="_blank" rel="noopener">《web优化必须了解的原理之I/o的五种模型和web的三种工作模式》</a><ul><li>五种I/O模型：阻塞I/O，非阻塞I/O，I/O复用、事件(信号)驱动I/O、异步I/O，前四种I/O属于同步操作，I/O的第一阶段不同、第二阶段相同，最后的一种则属于异步操作。</li><li>三种 Web Server 工作方式：Prefork(多进程)、Worker方式(线程方式)、Event方式。</li></ul></li><li><a href="http://www.cnblogs.com/Anker/p/3265058.html" target="_blank" rel="noopener">《select、poll、epoll之间的区别总结》</a><ul><li>select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的。</li><li>select 有打开文件描述符数量限制，默认1024（2048 for x64），100万并发，就要用1000个进程、切换开销大；poll采用链表结构，没有数量限制。</li><li>select，poll “醒着”的时候要遍历整个fd集合，而epoll在“醒着”的时候只要判断一下就绪链表是否为空就行了，通过回调机制节省大量CPU时间；select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，而epoll只要一次拷贝。</li><li>poll会随着并发增加，性能逐渐下降，epoll采用红黑树结构，性能稳定，不会随着连接数增加而降低。</li></ul></li><li><a href="http://xingyunbaijunwei.blog.163.com/blog/static/76538067201241685556302/" target="_blank" rel="noopener">《select，poll，epoll比较 》</a><ul><li>在连接数少并且连接都十分活跃的情况下，select和poll的性能可能比epoll好，毕竟epoll的通知机制需要很多函数回调。</li></ul></li><li><a href="https://www.cnblogs.com/geason/p/5774096.html" target="_blank" rel="noopener">《深入理解Java NIO》</a><ul><li>NIO 是一种同步非阻塞的 IO 模型。同步是指线程不断轮询 IO 事件是否就绪，非阻塞是指线程在等待 IO 的时候，可以同时做其他任务</li></ul></li><li><a href="https://blog.csdn.net/skiof007/article/details/52873421" target="_blank" rel="noopener">《BIO与NIO、AIO的区别》</a></li><li><a href="https://blog.csdn.net/u013074465/article/details/46276967" target="_blank" rel="noopener">《两种高效的服务器设计模型：Reactor和Proactor模型》</a></li></ul><h3 id="Epoll"><a href="#Epoll" class="headerlink" title="Epoll"></a><strong>Epoll</strong></h3><ul><li><a href="https://www.cnblogs.com/fnlingnzb-learner/p/5835573.html" target="_blank" rel="noopener">《epoll使用详解（精髓）》</a></li></ul><h3 id="Java-NIO"><a href="#Java-NIO" class="headerlink" title="Java NIO"></a><strong>Java NIO</strong></h3><ul><li><a href="https://www.cnblogs.com/geason/p/5774096.html" target="_blank" rel="noopener">《深入理解Java NIO》</a></li><li><a href="https://blog.csdn.net/xidianliuy/article/details/51612676" target="_blank" rel="noopener">《Java NIO编写Socket服务器的一个例子》</a></li></ul><h3 id="kqueue"><a href="#kqueue" class="headerlink" title="kqueue"></a><strong>kqueue</strong></h3><ul><li><a href="http://www.cnblogs.com/luminocean/p/5631336.html" target="_blank" rel="noopener">《kqueue用法简介》</a></li></ul><h2 id="连接和短连接"><a href="#连接和短连接" class="headerlink" title="连接和短连接"></a><strong>连接和短连接</strong></h2><ul><li><a href="https://www.cnblogs.com/pangguoping/p/5571422.html" target="_blank" rel="noopener">《TCP/IP系列——长连接与短连接的区别》</a></li></ul><h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a><strong>框架</strong></h2><ul><li><a href="https://blog.csdn.net/excellentyuxiao/article/details/53390408" target="_blank" rel="noopener">《Netty原理剖析》</a><ul><li>Reactor 模式介绍。</li><li>Netty 是 Reactor 模式的一种实现。</li></ul></li></ul><h2 id="零拷贝（Zero-copy）"><a href="#零拷贝（Zero-copy）" class="headerlink" title="零拷贝（Zero-copy）"></a><strong>零拷贝（Zero-copy）</strong></h2><ul><li><a href="https://www.cnblogs.com/xys1228/p/6088805.html" target="_blank" rel="noopener">《对于 Netty ByteBuf 的零拷贝(Zero Copy) 的理解》</a><ul><li>多个物理分离的buffer，通过逻辑上合并成为一个，从而避免了数据在内存之间的拷贝。</li></ul></li></ul><h2 id="序列化-二进制协议"><a href="#序列化-二进制协议" class="headerlink" title="序列化(二进制协议)"></a><strong>序列化(二进制协议)</strong></h2><h3 id="Hessian"><a href="#Hessian" class="headerlink" title="Hessian"></a><strong>Hessian</strong></h3><ul><li><a href="https://www.cnblogs.com/happyday56/p/4268249.html" target="_blank" rel="noopener">《Hessian原理分析》</a>Binary-RPC;不仅仅是序列化</li></ul><h3 id="Protobuf"><a href="#Protobuf" class="headerlink" title="Protobuf"></a><strong>Protobuf</strong></h3><ul><li><a href="https://blog.csdn.net/antgan/article/details/52103966" target="_blank" rel="noopener">《Protobuf协议的Java应用例子》</a>Goolge出品、占用空间和效率完胜其他序列化类库，如Hessian；需要编写 .proto 文件。</li><li><a href="https://worktile.com/tech/share/prototol-buffers" target="_blank" rel="noopener">《Protocol Buffers序列化协议及应用》</a><ul><li>关于协议的解释；缺点：可读性差;</li></ul></li><li><a href="https://blog.csdn.net/eric520zenobia/article/details/53766571" target="_blank" rel="noopener">《简单的使用 protobuf 和 protostuff》</a><ul><li>protostuff 的好处是不用写 .proto 文件，Java 对象直接就可以序列化。</li></ul></li></ul><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a><strong>数据库</strong></h1><h2 id="基础理论"><a href="#基础理论" class="headerlink" title="基础理论"></a><strong>基础理论</strong></h2><h3 id="数据库设计的三大范式"><a href="#数据库设计的三大范式" class="headerlink" title="数据库设计的三大范式"></a><strong>数据库设计的三大范式</strong></h3><ul><li><a href="https://www.cnblogs.com/waj6511988/p/7027127.html" target="_blank" rel="noopener">《数据库的三大范式以及五大约束》</a><ul><li>第一范式：数据表中的每一列（每个字段）必须是不可拆分的最小单元，也就是确保每一列的原子性；</li><li>第二范式（2NF）：满足1NF后，要求表中的所有列，都必须依赖于主键，而不能有任何一列与主键没有关系，也就是说一个表只描述一件事情；</li><li>第三范式：必须先满足第二范式（2NF），要求：表中的每一列只与主键直接相关而不是间接相关，（表中的每一列只能依赖于主键）；</li></ul></li></ul><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a><strong>MySQL</strong></h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a><strong>原理</strong></h3><ul><li><a href="http://www.admin10000.com/document/5372.html" target="_blank" rel="noopener">《MySQL的InnoDB索引原理详解》</a></li><li><a href="https://blog.csdn.net/xifeijian/article/details/20316775" target="_blank" rel="noopener">《MySQL存储引擎－－MyISAM与InnoDB区别》</a><ul><li>两种类型最主要的差别就是Innodb 支持事务处理与外键和行级锁</li></ul></li><li><a href="https://www.2cto.com/database/201211/172380.html" target="_blank" rel="noopener">《myisam和innodb索引实现的不同》</a></li></ul><h3 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a><strong>InnoDB</strong></h3><ul><li><a href="https://my.oschina.net/kailuncen/blog/1504217" target="_blank" rel="noopener">《一篇文章带你读懂Mysql和InnoDB》</a></li></ul><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a><strong>优化</strong></h3><ul><li><a href="http://vdisk.weibo.com/s/muWOT" target="_blank" rel="noopener">《MySQL36条军规》</a></li><li><a href="https://www.cnblogs.com/zhouyusheng/p/8038224.html" target="_blank" rel="noopener">《MYSQL性能优化的最佳20+条经验》</a></li><li><a href="https://blog.csdn.net/when_less_is_more/article/details/70187459" target="_blank" rel="noopener">《SQL优化之道》</a></li><li><a href="https://www.cnblogs.com/sivkun/p/7518540.html" target="_blank" rel="noopener">《mysql数据库死锁的产生原因及解决办法》</a></li><li><a href="https://blog.csdn.net/monkey_d_feilong/article/details/52291556" target="_blank" rel="noopener">《导致索引失效的可能情况》</a></li><li><a href="https://blog.csdn.net/zy_281870667/article/details/51604540" target="_blank" rel="noopener">《 MYSQL分页limit速度太慢优化方法》</a><ul><li>原则上就是缩小扫描范围。</li></ul></li></ul><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a><strong>索引</strong></h3><h4 id="聚集索引-非聚集索引"><a href="#聚集索引-非聚集索引" class="headerlink" title="聚集索引, 非聚集索引"></a><strong>聚集索引, 非聚集索引</strong></h4><ul><li><a href="https://blog.csdn.net/no_endless/article/details/77073549" target="_blank" rel="noopener">《MySQL 聚集索引/非聚集索引简述》</a></li><li><a href="https://www.cnblogs.com/zlcxbb/p/5757245.html" target="_blank" rel="noopener">《MyISAM和InnoDB的索引实现》</a></li></ul><p>MyISAM 是非聚集，InnoDB 是聚集</p><h4 id="复合索引"><a href="#复合索引" class="headerlink" title="复合索引"></a><strong>复合索引</strong></h4><ul><li><a href="https://www.cnblogs.com/summer0space/p/7247778.html" target="_blank" rel="noopener">《复合索引的优点和注意事项》</a></li></ul><h4 id="自适应哈希索引-AHI"><a href="#自适应哈希索引-AHI" class="headerlink" title="自适应哈希索引(AHI)"></a><strong>自适应哈希索引(AHI)</strong></h4><ul><li><a href="https://blog.csdn.net/Linux_ever/article/details/62043708" target="_blank" rel="noopener">《InnoDB存储引擎——自适应哈希索引》</a></li></ul><h3 id="explain"><a href="#explain" class="headerlink" title="explain"></a><strong>explain</strong></h3><ul><li><a href="https://segmentfault.com/a/1190000008131735" target="_blank" rel="noopener">《MySQL 性能优化神器 Explain 使用分析》</a></li></ul><h2 id="NoSQL"><a href="#NoSQL" class="headerlink" title="NoSQL"></a><strong>NoSQL</strong></h2><h3 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a><strong>MongoDB</strong></h3><ul><li><a href="http://www.runoob.com/mongodb/mongodb-tutorial.html" target="_blank" rel="noopener">MongoDB 教程</a></li><li><a href="http://mxdxm.iteye.com/blog/2093603" target="_blank" rel="noopener">《Mongodb相对于关系型数据库的优缺点》</a><ul><li>优点：弱一致性（最终一致），更能保证用户的访问速度；内置GridFS，支持大容量的存储；Schema-less 数据库，不用预先定义结构；内置Sharding；相比于其他NoSQL，第三方支持丰富；性能优越；</li><li>缺点：mongodb不支持事务操作；mongodb占用空间过大；MongoDB没有如MySQL那样成熟的维护工具，这对于开发和IT运营都是个值得注意的地方；</li></ul></li></ul><h3 id="Hbase"><a href="#Hbase" class="headerlink" title="Hbase"></a><strong>Hbase</strong></h3><ul><li><a href="http://www.thebigdata.cn/HBase/35831.html" target="_blank" rel="noopener">《简明 HBase 入门教程（开篇）》</a></li><li><a href="https://www.cnblogs.com/qiaoyihang/p/6246424.html" target="_blank" rel="noopener">《深入学习HBase架构原理》</a></li><li><a href="https://blog.csdn.net/youzhouliu/article/details/67632882" target="_blank" rel="noopener">《传统的行存储和（HBase）列存储的区别》</a></li><li><a href="https://blog.csdn.net/lifuxiangcaohui/article/details/39891099" target="_blank" rel="noopener">《Hbase与传统数据库的区别》</a><ul><li>空数据不存储，节省空间，且适用于并发。</li></ul></li><li><a href="https://blog.csdn.net/u014091123/article/details/73163088" target="_blank" rel="noopener">《HBase Rowkey设计》</a><ul><li>rowkey 按照字典顺序排列，便于批量扫描。</li><li>通过散列可以避免热点。</li></ul></li></ul><h1 id="搜索引擎"><a href="#搜索引擎" class="headerlink" title="搜索引擎"></a><strong>搜索引擎</strong></h1><h2 id="搜索引擎原理"><a href="#搜索引擎原理" class="headerlink" title="搜索引擎原理"></a><strong>搜索引擎原理</strong></h2><ul><li><a href="https://www.jianshu.com/p/0193dc44135b" target="_blank" rel="noopener">《倒排索引–搜索引擎入门》</a></li></ul><h2 id="Lucene"><a href="#Lucene" class="headerlink" title="Lucene"></a><strong>Lucene</strong></h2><ul><li><a href="https://www.cnblogs.com/rodge-run/p/6551152.html" target="_blank" rel="noopener">《Lucene入门简介》</a></li></ul><h2 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a><strong>Elasticsearch</strong></h2><ul><li><a href="https://blog.csdn.net/laoyang360/article/details/52244917" target="_blank" rel="noopener">《Elasticsearch学习，请先看这一篇！》</a></li><li><a href="https://blog.csdn.net/cyony/article/details/65437708" target="_blank" rel="noopener">《Elasticsearch索引原理》</a></li></ul><h2 id="Solr"><a href="#Solr" class="headerlink" title="Solr"></a><strong>Solr</strong></h2><ul><li><a href="https://blog.csdn.net/u011936655/article/details/51960005" target="_blank" rel="noopener">《 Apache Solr入门教程》</a></li><li><a href="https://blog.csdn.net/convict_eva/article/details/53537837" target="_blank" rel="noopener">《elasticsearch与solr比较》</a></li></ul><h2 id="sphinx"><a href="#sphinx" class="headerlink" title="sphinx"></a><strong>sphinx</strong></h2><ul><li><a href="http://blog.jobbole.com/101672/" target="_blank" rel="noopener">《Sphinx 的介绍和原理探索》</a></li></ul><h1 id="性能"><a href="#性能" class="headerlink" title="性能"></a><strong>性能</strong></h1><h2 id="性能优化方法论"><a href="#性能优化方法论" class="headerlink" title="性能优化方法论"></a><strong>性能优化方法论</strong></h2><ul><li><a href="https://blog.csdn.net/huangwenyi1010/article/details/72673447?ref=myread" target="_blank" rel="noopener">《15天的性能优化工作，5方面的调优经验》</a><ul><li>代码层面、业务层面、数据库层面、服务器层面、前端优化。</li></ul></li><li><a href="https://blog.csdn.net/tenglizhe/article/details/44563135" target="_blank" rel="noopener">《系统性能优化的几个方面》</a></li></ul><h2 id="容量评估"><a href="#容量评估" class="headerlink" title="容量评估"></a><strong>容量评估</strong></h2><ul><li><a href="https://blog.csdn.net/u012528360/article/details/70054156" target="_blank" rel="noopener">《联网性能与容量评估的方法论和典型案例》</a></li></ul><h2 id="CDN-网络"><a href="#CDN-网络" class="headerlink" title="CDN 网络"></a><strong>CDN 网络</strong></h2><ul><li><a href="https://www.cnblogs.com/wxiaona/p/5867685.html" target="_blank" rel="noopener">《CDN加速原理》</a></li><li><a href="https://www.zhihu.com/question/20536932" target="_blank" rel="noopener">《国内有哪些比较好的 CDN？》</a></li></ul><h2 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a><strong>连接池</strong></h2><ul><li><a href="https://blog.csdn.net/fysuccess/article/details/66972554" target="_blank" rel="noopener">《主流Java数据库连接池比较与开发配置实战》</a></li></ul><h2 id="性能调优"><a href="#性能调优" class="headerlink" title="性能调优"></a><strong>性能调优</strong></h2><ul><li><a href="https://blog.csdn.net/yethyeth/article/details/73266455" target="_blank" rel="noopener">《九大Java性能调试工具，必备至少一款》</a></li></ul><h1 id="大数据"><a href="#大数据" class="headerlink" title="大数据"></a><strong>大数据</strong></h1><h2 id="流式计算"><a href="#流式计算" class="headerlink" title="流式计算"></a><strong>流式计算</strong></h2><h3 id="Storm"><a href="#Storm" class="headerlink" title="Storm"></a><strong>Storm</strong></h3><ul><li><a href="http://storm.apache.org/" target="_blank" rel="noopener">官方网站</a></li><li><a href="https://blog.csdn.net/uisoul/article/details/77989927" target="_blank" rel="noopener">《最详细的Storm入门教程》</a></li></ul><h3 id="Flink"><a href="#Flink" class="headerlink" title="Flink"></a><strong>Flink</strong></h3><ul><li><a href="https://blog.csdn.net/lisi1129/article/details/54844919" target="_blank" rel="noopener">《Flink之一 Flink基本原理介绍》</a></li></ul><h3 id="Kafka-Stream"><a href="#Kafka-Stream" class="headerlink" title="Kafka Stream"></a><strong>Kafka Stream</strong></h3><ul><li><a href="https://yq.aliyun.com/articles/58382" target="_blank" rel="noopener">《Kafka Stream调研：一种轻量级流计算模式》</a></li></ul><h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a><strong>应用场景</strong></h3><p>例如：</p><ul><li>广告相关实时统计；</li><li>推荐系统用户画像标签实时更新；</li><li>线上服务健康状况实时监测；</li><li>实时榜单；</li><li>实时数据统计。</li></ul><h2 id="Hadoop"><a href="#Hadoop" class="headerlink" title="Hadoop"></a><strong>Hadoop</strong></h2><ul><li><a href="https://blog.csdn.net/houbin0912/article/details/72967178" target="_blank" rel="noopener">《用通俗易懂的话说下hadoop是什么,能做什么》</a></li><li><a href="http://gitbook.cn/books/5954c9600326c7705af8a92a/index.html" target="_blank" rel="noopener">《史上最详细的Hadoop环境搭建》</a></li></ul><h3 id="HDFS"><a href="#HDFS" class="headerlink" title="HDFS"></a><strong>HDFS</strong></h3><ul><li><a href="https://segmentfault.com/a/1190000011575458" target="_blank" rel="noopener">《【Hadoop学习】HDFS基本原理》</a></li></ul><h3 id="MapReduce"><a href="#MapReduce" class="headerlink" title="MapReduce"></a><strong>MapReduce</strong></h3><ul><li><a href="https://blog.csdn.net/oppo62258801/article/details/72884633" target="_blank" rel="noopener">《用通俗易懂的大白话讲解Map/Reduce原理》</a></li><li><a href="https://blog.csdn.net/foye12/article/details/78358292" target="_blank" rel="noopener">《 简单的map-reduce的java例子》</a></li></ul><h3 id="Yarn"><a href="#Yarn" class="headerlink" title="Yarn"></a><strong>Yarn</strong></h3><ul><li><a href="http://www.cnblogs.com/codeOfLife/p/5492740.html" target="_blank" rel="noopener">《初步掌握Yarn的架构及原理》</a></li></ul><h2 id="Spark"><a href="#Spark" class="headerlink" title="Spark"></a><strong>Spark</strong></h2><ul><li><a href="http://www.cnblogs.com/tgzhu/p/5818374.html" target="_blank" rel="noopener">《Spark(一): 基本架构及原理》</a></li></ul><h1 id="安全"><a href="#安全" class="headerlink" title="安全"></a><strong>安全</strong></h1><h2 id="web-安全"><a href="#web-安全" class="headerlink" title="web 安全"></a><strong>web 安全</strong></h2><h3 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a><strong>XSS</strong></h3><ul><li><a href="https://blog.csdn.net/qq_21956483/article/details/54377947" target="_blank" rel="noopener">《xss攻击原理与解决方法》</a></li></ul><h3 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a><strong>CSRF</strong></h3><ul><li><a href="https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/641-web-an-quan-fang-fan/6412-csrf.html" target="_blank" rel="noopener">《CSRF原理及防范》</a></li></ul><h3 id="SQL-注入"><a href="#SQL-注入" class="headerlink" title="SQL 注入"></a><strong>SQL 注入</strong></h3><ul><li><a href="https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/641-web-an-quan-fang-fan/6413-sql-zhu-ru.html" target="_blank" rel="noopener">《SQL注入》</a></li></ul><h3 id="Hash-Dos"><a href="#Hash-Dos" class="headerlink" title="Hash Dos"></a><strong>Hash Dos</strong></h3><ul><li><a href="http://www.freebuf.com/articles/web/14199.html" target="_blank" rel="noopener">《邪恶的JAVA HASH DOS攻击》</a><ul><li>利用JsonObjet 上传大Json，JsonObject 底层使用HashMap；不同的数据产生相同的hash值，使得构建Hash速度变慢，耗尽CPU。</li></ul></li><li><a href="https://yq.aliyun.com/articles/92194?t=t1" target="_blank" rel="noopener">《一种高级的DoS攻击-Hash碰撞攻击》</a></li><li><a href="http://www.iteye.com/news/23939/" target="_blank" rel="noopener">《关于Hash Collision DoS漏洞：解析与解决方案》</a></li></ul><h3 id="脚本注入"><a href="#脚本注入" class="headerlink" title="脚本注入"></a><strong>脚本注入</strong></h3><ul><li><a href="https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/641-web-an-quan-fang-fan/6414-shang-chuan-wen-jian-guo-lv.html" target="_blank" rel="noopener">《上传文件漏洞原理及防范》</a></li></ul><h3 id="漏洞扫描工具"><a href="#漏洞扫描工具" class="headerlink" title="漏洞扫描工具"></a><strong>漏洞扫描工具</strong></h3><ul><li><a href="https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/6421-dvwa.html" target="_blank" rel="noopener">《DVWA》</a></li><li><a href="https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/w3af.html" target="_blank" rel="noopener">W3af</a></li><li><a href="https://blog.csdn.net/xygg0801/article/details/53610640" target="_blank" rel="noopener">OpenVAS详解</a></li></ul><h3 id="验证码"><a href="#验证码" class="headerlink" title="验证码"></a><strong>验证码</strong></h3><ul><li><a href="https://blog.csdn.net/niaonao/article/details/51112686" target="_blank" rel="noopener">《验证码原理分析及实现》</a></li><li><a href="https://my.oschina.net/jiangbianwanghai/blog/1031031" target="_blank" rel="noopener">《详解滑动验证码的实现原理》</a><ul><li>滑动验证码是根据人在滑动滑块的响应时间，拖拽速度，时间，位置，轨迹，重试次数等来评估风险。</li></ul></li><li><a href="https://www.cnblogs.com/xcj26/p/5242758.html" target="_blank" rel="noopener">《淘宝滑动验证码研究》</a></li></ul><h2 id="DDoS-防范"><a href="#DDoS-防范" class="headerlink" title="DDoS 防范"></a><strong>DDoS 防范</strong></h2><ul><li><a href="http://netsecurity.51cto.com/art/201601/503799.htm" target="_blank" rel="noopener">《学习手册：DDoS的攻击方式及防御手段》</a></li><li><a href="http://netsecurity.51cto.com/art/201406/442756.htm" target="_blank" rel="noopener">《免费DDoS攻击测试工具大合集》</a></li></ul><h2 id="用户隐私信息保护"><a href="#用户隐私信息保护" class="headerlink" title="用户隐私信息保护"></a><strong>用户隐私信息保护</strong></h2><ol><li>用户密码非明文保存，加动态slat。</li><li>身份证号，手机号如果要显示，用 “*” 替代部分字符。</li><li>联系方式在的显示与否由用户自己控制。</li><li>TODO</li></ol><ul><li><a href="https://zhidao.baidu.com/question/1988017976673661587.html" target="_blank" rel="noopener">《个人隐私包括哪些》</a></li><li><a href="https://www.zhihu.com/question/20137108" target="_blank" rel="noopener">《在互联网上，隐私的范围包括哪些？》</a></li><li><a href="https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/642-shu-ju-jia-mi/6425-jia-mi-chang-jing-ff1a-yong-hu-mi-ma-bao-cun.html" target="_blank" rel="noopener">《用户密码保存》</a></li></ul><h2 id="序列化漏洞"><a href="#序列化漏洞" class="headerlink" title="序列化漏洞"></a><strong>序列化漏洞</strong></h2><ul><li><a href="https://blog.chaitin.cn/2015-11-11_java_unserialize_rce/" target="_blank" rel="noopener">《Lib之过？Java反序列化漏洞通用利用分析》</a></li></ul><h2 id="加密解密"><a href="#加密解密" class="headerlink" title="加密解密"></a><strong>加密解密</strong></h2><h3 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a><strong>对称加密</strong></h3><ul><li><a href="https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/642-shu-ju-jia-mi/6421-chang-jian-dui-cheng-jia-mi-suan-fa.html" target="_blank" rel="noopener">《常见对称加密算法》</a><ul><li>DES、3DES、Blowfish、AES</li><li>DES 采用 56位秘钥，Blowfish 采用1到448位变长秘钥，AES 128，192和256位长度的秘钥。</li><li>DES 秘钥太短（只有56位）算法目前已经被 AES 取代，并且 AES 有硬件加速，性能很好。</li></ul></li></ul><h3 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a><strong>哈希算法</strong></h3><ul><li><a href="https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/642-shu-ju-jia-mi/6422-chang-jian-ha-xi-suan-fa-and-hmac.html" target="_blank" rel="noopener">《常用的哈希算法》</a><ul><li>MD5 和 SHA-1 已经不再安全，已被弃用。</li><li>目前 SHA-256 是比较安全的。</li></ul></li><li><a href="https://blog.csdn.net/zhangruhong168/article/details/78033202" target="_blank" rel="noopener">《基于Hash摘要签名的公网URL签名验证设计方案》</a></li></ul><h3 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a><strong>非对称加密</strong></h3><ul><li><a href="https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/642-shu-ju-jia-mi/6424-chang-yong-fei-dui-cheng-jia-mi-suan-fa.html" target="_blank" rel="noopener">《常见非对称加密算法》</a><ul><li>RSA、DSA、ECDSA(螺旋曲线加密算法)</li><li>和 RSA 不同的是 DSA 仅能用于数字签名，不能进行数据加密解密，其安全性和RSA相当，但其性能要比RSA快。</li><li>256位的ECC秘钥的安全性等同于3072位的RSA秘钥。<br><a href="http://baijiahao.baidu.com/s?id=1578348858092033763&wfr=spider&for=pc" target="_blank" rel="noopener">《区块链的加密技术》</a></li></ul></li></ul><h2 id="服务器安全"><a href="#服务器安全" class="headerlink" title="服务器安全"></a><strong>服务器安全</strong></h2><ul><li><a href="http://www.freebuf.com/articles/system/121540.html" target="_blank" rel="noopener">《Linux强化论：15步打造一个安全的Linux服务器》</a></li></ul><h2 id="数据安全"><a href="#数据安全" class="headerlink" title="数据安全"></a><strong>数据安全</strong></h2><h3 id="数据备份"><a href="#数据备份" class="headerlink" title="数据备份"></a><strong>数据备份</strong></h3><p>TODO</p><h2 id="网络隔离"><a href="#网络隔离" class="headerlink" title="网络隔离"></a><strong>网络隔离</strong></h2><h3 id="内外网分离"><a href="#内外网分离" class="headerlink" title="内外网分离"></a><strong>内外网分离</strong></h3><p>TODO</p><h3 id="登录跳板机"><a href="#登录跳板机" class="headerlink" title="登录跳板机"></a><strong>登录跳板机</strong></h3><p>在内外环境中通过跳板机登录到线上主机。</p><ul><li><a href="http://blog.51cto.com/zero01/2062618" target="_blank" rel="noopener">《搭建简易堡垒机》</a></li></ul><h2 id="授权、认证"><a href="#授权、认证" class="headerlink" title="授权、认证"></a><strong>授权、认证</strong></h2><h3 id="RBAC"><a href="#RBAC" class="headerlink" title="RBAC"></a><strong>RBAC</strong></h3><ul><li><a href="https://www.cnblogs.com/zq8024/p/5003050.html" target="_blank" rel="noopener">《基于组织角色的权限设计》</a></li><li><a href="https://www.cnblogs.com/shijiaqi1066/p/3793894.html" target="_blank" rel="noopener">《权限系统与RBAC模型概述》</a></li><li><a href="https://blog.csdn.net/he90227/article/details/38663553" target="_blank" rel="noopener">《Spring整合Shiro做权限控制模块详细案例分析》</a></li></ul><h3 id="OAuth2-0"><a href="#OAuth2-0" class="headerlink" title="OAuth2.0"></a><strong>OAuth2.0</strong></h3><ul><li><a href="http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html" target="_blank" rel="noopener">《理解OAuth 2.0》</a></li></ul><h3 id="双因素认证（2FA）"><a href="#双因素认证（2FA）" class="headerlink" title="双因素认证（2FA）"></a><strong>双因素认证（2FA）</strong></h3><p>2FA - Two-factor authentication，用于加强登录验证</p><p>常用做法是 登录密码 + 手机验证码（或者令牌Key，类似于与网银的 USB key）</p><ul><li>【《双因素认证（2FA）教程》】(<a href="http://www.ruanyifeng.com/blog/2017/11/2fa-tutorial.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2017/11/2fa-tutorial.html</a>)</li></ul><h3 id="单点登录-SSO"><a href="#单点登录-SSO" class="headerlink" title="单点登录(SSO)"></a><strong>单点登录(SSO)</strong></h3><ul><li><a href="https://www.cnblogs.com/ywlaker/p/6113927.html" target="_blank" rel="noopener">《单点登录原理与简单实现》</a></li><li><a href="https://github.com/apereo/cas" target="_blank" rel="noopener">CAS单点登录框架</a></li></ul><h1 id="常用开源框架"><a href="#常用开源框架" class="headerlink" title="常用开源框架"></a><strong>常用开源框架</strong></h1><h2 id="开源协议"><a href="#开源协议" class="headerlink" title="开源协议"></a><strong>开源协议</strong></h2><ul><li><a href="https://coderxing.gitbooks.io/architecture-evolution/chapter1/di-yi-zhang-ff1a-zhun-bei-qi-cheng/12-guan-yu-kai-yuan/123-kai-yuan-xie-yi-de-xuan-ze.html" target="_blank" rel="noopener">《开源协议的选择》</a></li></ul><h2 id="日志框架"><a href="#日志框架" class="headerlink" title="日志框架"></a><strong>日志框架</strong></h2><h3 id="Log4j、Log4j2"><a href="#Log4j、Log4j2" class="headerlink" title="Log4j、Log4j2"></a><strong>Log4j、Log4j2</strong></h3><ul><li><a href="https://blog.csdn.net/u012422446/article/details/51199724" target="_blank" rel="noopener">《log4j 详细讲解》</a></li><li><a href="https://blog.csdn.net/vbirdbest/article/details/71751835" target="_blank" rel="noopener">《log4j2 实际使用详解》</a></li><li><a href="https://my.oschina.net/OutOfMemory/blog/789267" target="_blank" rel="noopener">《Log4j1,Logback以及Log4j2性能测试对比》</a><ul><li>Log4J 异步日志性能优异。</li></ul></li></ul><h3 id="Logback"><a href="#Logback" class="headerlink" title="Logback"></a><strong>Logback</strong></h3><ul><li><a href="https://blog.csdn.net/rulon147/article/details/52620541" target="_blank" rel="noopener">《最全LogBack 详解、含java案例和配置说明》</a></li></ul><h2 id="ORM"><a href="#ORM" class="headerlink" title="ORM"></a><strong>ORM</strong></h2><ul><li><a href="https://blog.csdn.net/sinat_34093604/article/details/53082000" target="_blank" rel="noopener">《ORM框架使用优缺点》</a><ul><li>主要目的是为了提高开发效率。</li></ul></li></ul><p><strong>MyBatis：</strong></p><ul><li><a href="https://www.cnblogs.com/winclpt/articles/7511672.html" target="_blank" rel="noopener">《mybatis缓存机制详解》</a><ul><li>一级缓存是SqlSession级别的缓存，缓存的数据只在SqlSession内有效</li><li>二级缓存是mapper级别的缓存，同一个namespace公用这一个缓存，所以对SqlSession是共享的；使用 LRU 机制清理缓存，通过 cacheEnabled 参数开启。</li></ul></li><li><a href="https://blog.csdn.net/baidu_32877851/article/details/53959268" target="_blank" rel="noopener">《MyBatis学习之代码生成器Generator》</a></li></ul><h2 id="网络框架"><a href="#网络框架" class="headerlink" title="网络框架"></a><strong>网络框架</strong></h2><p>TODO</p><h2 id="Web-框架"><a href="#Web-框架" class="headerlink" title="Web 框架"></a><strong>Web 框架</strong></h2><h3 id="Spring-家族"><a href="#Spring-家族" class="headerlink" title="Spring 家族"></a><strong>Spring 家族</strong></h3><p><strong>Spring</strong></p><ul><li><a href="https://www.w3cschool.cn/wkspring/" target="_blank" rel="noopener">Spring 简明教程</a></li></ul><p><strong>Spring Boot</strong></p><ul><li><a href="http://projects.spring.io/spring-boot/" target="_blank" rel="noopener">官方网站</a></li><li><a href="http://blog.didispace.com/Spring-Boot%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/" target="_blank" rel="noopener">《Spring Boot基础教程》</a></li></ul><p><strong>Spring Cloud</strong></p><ul><li><a href="http://springboot.fun/" target="_blank" rel="noopener">Spring Boot 中文索引站</a></li><li><a href="https://springcloud.cc/" target="_blank" rel="noopener">Spring Cloud 中文文档</a></li><li><a href="http://blog.didispace.com/Spring-Cloud%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/" target="_blank" rel="noopener">《Spring Cloud基础教程》</a></li></ul><h2 id="工具框架"><a href="#工具框架" class="headerlink" title="工具框架"></a><strong>工具框架</strong></h2><ul><li><a href="https://www.cnblogs.com/crazylqy/p/4872236.html" target="_blank" rel="noopener">《Apache Commons 工具类介绍及简单使用》</a></li><li><a href="http://ifeve.com/google-guava/" target="_blank" rel="noopener">《Google guava 中文教程》</a></li></ul><h1 id="分布式设计"><a href="#分布式设计" class="headerlink" title="分布式设计"></a><strong>分布式设计</strong></h1><h2 id="扩展性设计"><a href="#扩展性设计" class="headerlink" title="扩展性设计"></a><strong>扩展性设计</strong></h2><ul><li><a href="https://blog.csdn.net/hemin1003/article/details/53633926" target="_blank" rel="noopener">《架构师不可不知的十大可扩展架构》</a><ul><li>总结下来，通用的套路就是分布、缓存及异步处理。</li></ul></li><li><a href="https://yq.aliyun.com/articles/38119" target="_blank" rel="noopener">《可扩展性设计之数据切分》</a><ul><li>水平切分+垂直切分</li><li>利用中间件进行分片如，MySQL Proxy。</li><li>利用分片策略进行切分，如按照ID取模。</li></ul></li><li><a href="https://blog.csdn.net/deniro_li/article/details/78458306" target="_blank" rel="noopener">《说说如何实现可扩展性的大型网站架构》</a><ul><li>分布式服务+消息队列。</li></ul></li><li><a href="https://blog.csdn.net/chaofanwei/article/details/29191073" target="_blank" rel="noopener">《大型网站技术架构（七）–网站的可扩展性架构》</a></li></ul><h2 id="稳定性-amp-高可用"><a href="#稳定性-amp-高可用" class="headerlink" title="稳定性 &amp; 高可用"></a><strong>稳定性 &amp; 高可用</strong></h2><ul><li><a href="https://blog.csdn.net/hustspy1990/article/details/78008324" target="_blank" rel="noopener">《系统设计：关于高可用系统的一些技术方案》</a><ul><li>可扩展：水平扩展、垂直扩展。 通过冗余部署，避免单点故障。</li><li>隔离：避免单一业务占用全部资源。避免业务之间的相互影响 机房隔离避免单点故障。</li><li>解耦：降低维护成本，降低耦合风险。减少依赖，减少相互间的影响。</li><li>限流：滑动窗口计数法、漏桶算法、令牌桶算法等算法。遇到突发流量时，保证系统稳定。</li><li>降级：紧急情况下释放非核心功能的资源。牺牲非核心业务，保证核心业务的高可用。</li><li>熔断：异常情况超出阈值进入熔断状态，快速失败。减少不稳定的外部依赖对核心服务的影响。</li><li>自动化测试：通过完善的测试，减少发布引起的故障。</li><li>灰度发布：灰度发布是速度与安全性作为妥协，能够有效减少发布故障。</li></ul></li><li><a href="https://coolshell.cn/articles/17459.html" target="_blank" rel="noopener">《关于高可用的系统》</a><ul><li>设计原则：数据不丢(持久化)；服务高可用(服务副本)；绝对的100%高可用很难，目标是做到尽可能多的9，如99.999%（全年累计只有5分钟）。</li></ul></li></ul><h3 id="硬件负载均衡"><a href="#硬件负载均衡" class="headerlink" title="硬件负载均衡"></a><strong>硬件负载均衡</strong></h3><ul><li><a href="https://www.cnblogs.com/wuyun-blog/p/6186198.html" target="_blank" rel="noopener">《转！！负载均衡器技术Nginx和F5的优缺点对比》</a><ul><li>主要是和F5对比。</li></ul></li><li><a href="https://www.cnblogs.com/lcword/p/5773296.html" target="_blank" rel="noopener">《软/硬件负载均衡产品 你知多少？》</a></li></ul><h3 id="软件负载均衡"><a href="#软件负载均衡" class="headerlink" title="软件负载均衡"></a><strong>软件负载均衡</strong></h3><ul><li><a href="https://www.cnblogs.com/tianzhiliang/articles/2317808.html" target="_blank" rel="noopener">《几种负载均衡算法》</a>轮寻、权重、负载、最少连接、QoS</li><li><a href="https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/611-dns-fang-shi.html" target="_blank" rel="noopener">《DNS负载均衡》</a><ul><li>配置简单，更新速度慢。</li></ul></li><li><a href="https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/613-nginx-fu-zai-jun-heng.html" target="_blank" rel="noopener">《Nginx负载均衡》</a><ul><li>简单轻量、学习成本低；主要适用于web应用。</li></ul></li><li><a href="https://www.cnblogs.com/edisonchou/p/4281978.html" target="_blank" rel="noopener">《借助LVS+Keepalived实现负载均衡 》</a><ul><li>配置比较负载、只支持到4层，性能较高。</li></ul></li><li><a href="http://www.ttlsa.com/linux/haproxy-study-tutorial/" target="_blank" rel="noopener">《HAProxy用法详解 全网最详细中文文档》</a><ul><li>支持到七层（比如HTTP）、功能比较全面，性能也不错。</li></ul></li><li><a href="http://blog.itpub.net/25704976/viewspace-1319781/" target="_blank" rel="noopener">《Haproxy+Keepalived+MySQL实现读均衡负载》</a><ul><li>主要是用户读请求的负载均衡。</li></ul></li><li><a href="https://www.cnblogs.com/lylife/p/5584019.html" target="_blank" rel="noopener">《rabbitmq+haproxy+keepalived实现高可用集群搭建》</a></li></ul><h3 id="限流"><a href="#限流" class="headerlink" title="限流"></a><strong>限流</strong></h3><ul><li><a href="https://www.cnblogs.com/haoxinyue/p/6792309.html" target="_blank" rel="noopener">《谈谈高并发系统的限流》</a><ul><li>计数器：通过滑动窗口计数器，控制单位时间内的请求次数，简单粗暴。</li><li>漏桶算法：固定容量的漏桶，漏桶满了就丢弃请求，比较常用。</li><li>令牌桶算法：固定容量的令牌桶，按照一定速率添加令牌，处理请求前需要拿到令牌，拿不到令牌则丢弃请求，或进入丢队列，可以通过控制添加令牌的速率，来控制整体速度。Guava 中的 RateLimiter 是令牌桶的实现。</li><li>Nginx 限流：通过 limit_req等模块限制并发连接数。</li></ul></li></ul><h3 id="应用层容灾"><a href="#应用层容灾" class="headerlink" title="应用层容灾"></a><strong>应用层容灾</strong></h3><ul><li><a href="https://segmentfault.com/a/1190000005988895" target="_blank" rel="noopener">《防雪崩利器：熔断器 Hystrix 的原理与使用》</a><ul><li>雪崩效应原因：硬件故障、硬件故障、程序Bug、重试加大流量、用户大量请求。</li><li>雪崩的对策：限流、改进缓存模式(缓存预加载、同步调用改异步)、自动扩容、降级。</li><li>Hystrix设计原则：<ul><li>资源隔离：Hystrix通过将每个依赖服务分配独立的线程池进行资源隔离, 从而避免服务雪崩。</li><li>熔断开关：服务的健康状况 = 请求失败数 / 请求总数，通过阈值设定和滑动窗口控制开关。</li><li>命令模式：通过继承 HystrixCommand 来包装服务调用逻辑。</li></ul></li><li><a href="https://blog.csdn.net/zeb_perfect/article/details/54135506" target="_blank" rel="noopener">《缓存穿透，缓存击穿，缓存雪崩解决方案分析》</a></li><li><a href="https://blog.csdn.net/zeb_perfect/article/details/54135506" target="_blank" rel="noopener">《缓存击穿、失效以及热点key问题》</a><ul><li>主要策略：失效瞬间：单机使用锁；使用分布式锁；不过期；</li><li>热点数据：热点数据单独存储；使用本地缓存；分成多个子key；</li></ul></li></ul></li></ul><h3 id="跨机房容灾"><a href="#跨机房容灾" class="headerlink" title="跨机房容灾"></a><strong>跨机房容灾</strong></h3><ul><li><a href="http://dc.idcquan.com/ywgl/71559.shtml" target="_blank" rel="noopener">《“异地多活”多机房部署经验谈》</a><ul><li>通过自研中间件进行数据同步。</li></ul></li><li><a href="https://blog.csdn.net/jeffreynicole/article/details/48135093" target="_blank" rel="noopener">《异地多活（异地双活）实践经验》</a><ul><li>注意延迟问题，多次跨机房调用会将延时放大数倍。</li><li>建房间专线很大概率会出现问题，做好运维和程序层面的容错。</li><li>不能依赖于程序端数据双写，要有自动同步方案。</li><li>数据永不在高延迟和较差网络质量下，考虑同步质量问题。</li><li>核心业务和次要业务分而治之，甚至只考虑核心业务。</li><li>异地多活监控部署、测试也要跟上。</li><li>业务允许的情况下考虑用户分区，尤其是游戏、邮箱业务。</li><li>控制跨机房消息体大小，越小越好。</li><li>考虑使用docker容器虚拟化技术，提高动态调度能力。</li></ul></li><li><a href="https://blog.csdn.net/yoara/article/details/38013751" target="_blank" rel="noopener">容灾技术及建设经验介绍</a></li></ul><h3 id="容灾演练流程"><a href="#容灾演练流程" class="headerlink" title="容灾演练流程"></a><strong>容灾演练流程</strong></h3><ul><li><a href="https://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&mid=2650996320&idx=1&sn=0ed3be190bbee4a9277886ef88cbb2e5" target="_blank" rel="noopener">《依赖治理、灰度发布、故障演练，阿里电商故障演练系统的设计与实战经验》</a><ul><li>常见故障画像</li><li>案例：预案有效性、预案有效性、故障复现、架构容灾测试、参数调优、参数调优、故障突袭、联合演练。</li></ul></li></ul><h3 id="平滑启动"><a href="#平滑启动" class="headerlink" title="平滑启动"></a><strong>平滑启动</strong></h3><ul><li>平滑重启应用思路端流量（如vip层）、2. flush 数据(如果有)、3, 重启应用</li><li><a href="https://blog.csdn.net/u011001084/article/details/73480432" target="_blank" rel="noopener">《JVM安全退出（如何优雅的关闭java服务）》</a>推荐推出方式：System.exit，Kill SIGTERM；不推荐 kill-9；用 Runtime.addShutdownHook 注册钩子。</li><li><a href="http://ju.outofmemory.cn/entry/337235" target="_blank" rel="noopener">《常见Java应用如何优雅关闭》</a>Java、Srping、Dubbo 优雅关闭方式。</li></ul><h2 id="数据库扩展"><a href="#数据库扩展" class="headerlink" title="数据库扩展"></a><strong>数据库扩展</strong></h2><h3 id="读写分离模式"><a href="#读写分离模式" class="headerlink" title="读写分离模式"></a><strong>读写分离模式</strong></h3><ul><li><a href="https://www.cnblogs.com/houdj/p/6563771.html" target="_blank" rel="noopener">《Mysql主从方案的实现》</a></li><li><a href="https://www.cnblogs.com/edisonchou/p/4133148.html" target="_blank" rel="noopener">《搭建MySQL主从复制经典架构》</a></li><li><a href="https://blog.csdn.net/nimasike/article/details/48048341" target="_blank" rel="noopener">《Haproxy+多台MySQL从服务器(Slave) 实现负载均衡》</a></li><li><a href="https://www.cnblogs.com/zhangsubai/p/6801764.html" target="_blank" rel="noopener">《DRBD+Heartbeat+Mysql高可用读写分离架构》</a><ul><li>DRDB 进行磁盘复制，避免单点问题。</li></ul></li><li><a href="https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/62-ke-kuo-zhan-de-shu-ju-ku-jia-gou/621-gao-ke-yong-mysql-de-ji-zhong-fang-an/6214-mysql-cluster-fang-an.html" target="_blank" rel="noopener">《MySQL Cluster 方式》</a></li></ul><h3 id="分片模式"><a href="#分片模式" class="headerlink" title="分片模式"></a><strong>分片模式</strong></h3><ul><li><a href="https://www.jianshu.com/p/32b3e91aa22c" target="_blank" rel="noopener">《分库分表需要考虑的问题及方案》</a><ul><li>中间件： 轻量级：sharding-jdbc、TSharding；重量级：Atlas、MyCAT、Vitess等。</li><li>问题：事务、Join、迁移、扩容、ID、分页等。</li><li>事务补偿：对数据进行对帐检查;基于日志进行比对;定期同标准数据来源进行同步等。</li><li>分库策略：数值范围；取模；日期等。</li><li>分库数量：通常 MySQL 单库 5千万条、Oracle 单库一亿条需要分库。</li></ul></li><li><a href="https://www.2cto.com/database/201503/380348.html" target="_blank" rel="noopener">《MySql分表和表分区详解》</a><ul><li>分区：是MySQL内部机制，对客户端透明，数据存储在不同文件中，表面上看是同一个表。</li><li>分表：物理上创建不同的表、客户端需要管理分表路由。</li></ul></li></ul><h2 id="服务治理"><a href="#服务治理" class="headerlink" title="服务治理"></a><strong>服务治理</strong></h2><h3 id="服务注册与发现"><a href="#服务注册与发现" class="headerlink" title="服务注册与发现"></a><strong>服务注册与发现</strong></h3><ul><li><a href="https://blog.csdn.net/jiaolongdy/article/details/51188798" target="_blank" rel="noopener">《永不失联！如何实现微服务架构中的服务发现？》</a><ul><li>客户端服务发现模式：客户端直接查询注册表，同时自己负责负载均衡。Eureka 采用这种方式。</li><li>服务器端服务发现模式：客户端通过负载均衡查询服务实例。</li></ul></li><li><a href="https://blog.csdn.net/u010963948/article/details/71730165" target="_blank" rel="noopener">《SpringCloud服务注册中心比较:Consul vs Zookeeper vs Etcd vs Eureka》</a><ul><li>CAP支持：Consul（CA）、zookeeper（cp）、etcd（cp） 、euerka（ap）</li><li>作者认为目前 Consul 对 Spring cloud 的支持比较好。</li></ul></li><li><a href="http://mobile.51cto.com/news-502394.htm" target="_blank" rel="noopener">《基于Zookeeper的服务注册与发现》</a><ul><li>优点：API简单、Pinterest，Airbnb 在用、多语言、通过watcher机制来实现配置PUSH，能快速响应配置变化。</li></ul></li></ul><h3 id="服务路由控制"><a href="#服务路由控制" class="headerlink" title="服务路由控制"></a><strong>服务路由控制</strong></h3><ul><li><a href="https://blog.csdn.net/xundh/article/details/59492750" target="_blank" rel="noopener">《分布式服务框架学习笔记4 服务路由》</a><ul><li>原则：透明化路由</li><li>负载均衡策略：随机、轮询、服务调用延迟、一致性哈希、粘滞连接</li><li>本地路由有限策略：injvm(优先调用jvm内部的服务)，innative(优先使用相同物理机的服务),原则上找距离最近的服务。</li><li>配置方式：统一注册表；本地配置；动态下发。</li></ul></li></ul><h2 id="分布式一致"><a href="#分布式一致" class="headerlink" title="分布式一致"></a><strong>分布式一致</strong></h2><h3 id="CAP-与-BASE-理论"><a href="#CAP-与-BASE-理论" class="headerlink" title="CAP 与 BASE 理论"></a><strong>CAP 与 BASE 理论</strong></h3><ul><li><a href="http://www.cnblogs.com/szlbm/p/5588543.html" target="_blank" rel="noopener">《从分布式一致性谈到CAP理论、BASE理论》</a><ul><li>一致性分类：强一致(立即一致)；弱一致(可在单位时间内实现一致，比如秒级)；最终一致(弱一致的一种，一定时间内最终一致)</li><li>CAP：一致性、可用性、分区容错性(网络故障引起)</li><li>BASE：Basically Available（基本可用）、Soft state（软状态）和Eventually consistent（最终一致性）</li><li>BASE理论的核心思想是：即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。</li></ul></li></ul><h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a><strong>分布式锁</strong></h3><ul><li><a href="http://www.hollischuang.com/archives/1716" target="_blank" rel="noopener">《分布式锁的几种实现方式》</a><ul><li>基于数据库的分布式锁：优点：操作简单、容易理解。缺点：存在单点问题、数据库性能够开销较大、不可重入；</li><li>基于缓存的分布式锁：优点：非阻塞、性能好。缺点：操作不好容易造成锁无法释放的情况。</li><li>Zookeeper 分布式锁：通过有序临时节点实现锁机制，自己对应的节点需要最小，则被认为是获得了锁。优点：集群可以透明解决单点问题，避免锁不被释放问题，同时锁可以重入。缺点：性能不如缓存方式，吞吐量会随着zk集群规模变大而下降。</li></ul></li><li><a href="https://www.tuicool.com/articles/VZJr6fY" target="_blank" rel="noopener">《基于Zookeeper的分布式锁》</a><ul><li>清楚的原理描述 + Java 代码示例。</li></ul></li><li><a href="https://www.cnblogs.com/0201zcr/p/5942748.html" target="_blank" rel="noopener">《jedisLock—redis分布式锁实现》</a><ul><li>基于 setnx(set if ont exists)，有则返回false，否则返回true。并支持过期时间。</li></ul></li><li><a href="https://blog.csdn.net/albertfly/article/details/77412333" target="_blank" rel="noopener">《Memcached 和 Redis 分布式锁方案》</a><ul><li>利用 memcached 的 add（有别于set）操作，当key存在时，返回false。</li></ul></li></ul><h3 id="分布式一致性算法"><a href="#分布式一致性算法" class="headerlink" title="分布式一致性算法"></a><strong>分布式一致性算法</strong></h3><h4 id="PAXOS"><a href="#PAXOS" class="headerlink" title="PAXOS"></a><strong>PAXOS</strong></h4><ul><li><a href="https://www.cnblogs.com/linbingdong/p/6253479.html" target="_blank" rel="noopener">《分布式系列文章——Paxos算法原理与推导》</a></li><li><a href="https://blog.csdn.net/u010039929/article/details/70171672" target="_blank" rel="noopener">《Paxos–&gt;Fast Paxos–&gt;Zookeeper分析》</a></li><li><a href="https://www.cnblogs.com/leesf456/p/6012777.html" target="_blank" rel="noopener">《【分布式】Zookeeper与Paxos》</a></li></ul><h4 id="Zab"><a href="#Zab" class="headerlink" title="Zab"></a><strong>Zab</strong></h4><ul><li><a href="https://www.jianshu.com/p/fb527a64deee" target="_blank" rel="noopener">《Zab：Zookeeper 中的分布式一致性协议介绍》</a></li></ul><h4 id="Raft"><a href="#Raft" class="headerlink" title="Raft"></a><strong>Raft</strong></h4><ul><li><a href="http://www.cnblogs.com/mindwind/p/5231986.html" target="_blank" rel="noopener">《Raft 为什么是更易理解的分布式一致性算法》</a><ul><li>三种角色：Leader（领袖）、Follower（群众）、Candidate（候选人）</li><li>通过随机等待的方式发出投票，得票多的获胜。</li></ul></li></ul><h4 id="Gossip"><a href="#Gossip" class="headerlink" title="Gossip"></a><strong>Gossip</strong></h4><ul><li><a href="http://blog.51cto.com/tianya23/530743" target="_blank" rel="noopener">《Gossip算法》</a></li></ul><h4 id="两阶段提交、多阶段提交"><a href="#两阶段提交、多阶段提交" class="headerlink" title="两阶段提交、多阶段提交"></a><strong>两阶段提交、多阶段提交</strong></h4><ul><li><a href="http://blog.jobbole.com/95632/" target="_blank" rel="noopener">《关于分布式事务、两阶段提交协议、三阶提交协议》</a></li></ul><h3 id="幂等"><a href="#幂等" class="headerlink" title="幂等"></a><strong>幂等</strong></h3><ul><li><a href="https://www.cnblogs.com/wxgblogs/p/6639272.html" target="_blank" rel="noopener">《分布式系统—幂等性设计》</a><ul><li>幂等特性的作用：该资源具备幂等性，请求方无需担心重复调用会产生错误。</li><li>常见保证幂等的手段：MVCC（类似于乐观锁）、去重表(唯一索引)、悲观锁、一次性token、序列号方式。</li></ul></li></ul><h3 id="分布式一致方案"><a href="#分布式一致方案" class="headerlink" title="分布式一致方案"></a><strong>分布式一致方案</strong></h3><ul><li><a href="http://www.infoq.com/cn/articles/solution-of-distributed-system-transaction-consistency" target="_blank" rel="noopener">《分布式系统事务一致性解决方案》</a></li><li><a href="https://weibo.com/ttarticle/p/show?id=2309403965965003062676" target="_blank" rel="noopener">《保证分布式系统数据一致性的6种方案》</a></li></ul><h3 id="分布式-Leader-节点选举"><a href="#分布式-Leader-节点选举" class="headerlink" title="分布式 Leader 节点选举"></a><strong>分布式 Leader 节点选举</strong></h3><ul><li><a href="https://blog.csdn.net/johnson_moon/article/details/78809995" target="_blank" rel="noopener">《利用zookeeper实现分布式leader节点选举》</a></li></ul><h3 id="TCC-Try-Confirm-Cancel-柔性事务"><a href="#TCC-Try-Confirm-Cancel-柔性事务" class="headerlink" title="TCC(Try/Confirm/Cancel) 柔性事务"></a><strong>TCC(Try/Confirm/Cancel) 柔性事务</strong></h3><ul><li><a href="https://www.jianshu.com/p/ab1a1c6b08a1" target="_blank" rel="noopener">《传统事务与柔性事务》</a><ul><li>基于BASE理论：基本可用、柔性状态、最终一致。</li><li>解决方案：记录日志+补偿（正向补充或者回滚）、消息重试(要求程序要幂等)；“无锁设计”、采用乐观锁机制。</li></ul></li></ul><h2 id="分布式文件系统"><a href="#分布式文件系统" class="headerlink" title="分布式文件系统"></a><strong>分布式文件系统</strong></h2><ul><li><a href="https://zhuanlan.zhihu.com/p/27666295" target="_blank" rel="noopener">说说分布式文件存储系统-基本架构</a>？</li><li><a href="https://blog.csdn.net/gatieme/article/details/44982961" target="_blank" rel="noopener">《各种分布式文件系统的比较》</a>？<ul><li>HDFS：大批量数据读写，用于高吞吐量的场景，不适合小文件。</li><li>FastDFS：轻量级、适合小文件。</li></ul></li></ul><h2 id="唯一ID-生成"><a href="#唯一ID-生成" class="headerlink" title="唯一ID 生成"></a><strong>唯一ID 生成</strong></h2><h3 id="全局唯一ID"><a href="#全局唯一ID" class="headerlink" title="全局唯一ID"></a><strong>全局唯一ID</strong></h3><ul><li><a href="https://www.cnblogs.com/baiwa/p/5318432.html" target="_blank" rel="noopener">《高并发分布式系统中生成全局唯一Id汇总》</a><ul><li>Twitter 方案（Snowflake 算法）：41位时间戳+10位机器标识（比如IP，服务器名称等）+12位序列号(本地计数器)</li><li>Flicker 方案：MySQL自增ID + “REPLACE INTO XXX:SELECT LAST_INSERT_ID();”</li><li>UUID：缺点，无序，字符串过长，占用空间，影响检索性能。</li><li>MongoDB 方案：利用 ObjectId。缺点：不能自增。</li></ul></li><li><a href="https://blog.csdn.net/hdu09075340/article/details/79103851" target="_blank" rel="noopener">《TDDL 在分布式下的SEQUENCE原理》</a><ul><li>在数据库中创建 sequence 表，用于记录，当前已被占用的id最大值。</li><li>每台客户端主机取一个id区间（比如 1000~2000）缓存在本地，并更新 sequence 表中的id最大值记录。</li><li>客户端主机之间取不同的id区间，用完再取，使用乐观锁机制控制并发。</li></ul></li></ul><h2 id="一致性Hash算法"><a href="#一致性Hash算法" class="headerlink" title="一致性Hash算法"></a><strong>一致性Hash算法</strong></h2><ul><li><a href="https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/631-yi-zhi-xing-ha-xi.html" target="_blank" rel="noopener">《一致性哈希算法》</a></li></ul><h1 id="设计思想-amp-开发模式"><a href="#设计思想-amp-开发模式" class="headerlink" title="设计思想 &amp; 开发模式"></a><strong>设计思想 &amp; 开发模式</strong></h1><h2 id="DDD-Domain-driven-Design-领域驱动设计"><a href="#DDD-Domain-driven-Design-领域驱动设计" class="headerlink" title="DDD(Domain-driven Design - 领域驱动设计)"></a><strong>DDD(Domain-driven Design - 领域驱动设计)</strong></h2><ul><li><a href="https://www.cnblogs.com/netfocus/p/5548025.html" target="_blank" rel="noopener">《浅谈我对DDD领域驱动设计的理解》</a><ul><li>概念：DDD 主要对传统软件开发流程(分析-设计-编码)中各阶段的割裂问题而提出，避免由于一开始分析不明或在软件开发过程中的信息流转不一致而造成软件无法交付（和需求方设想不一致）的问题。DDD 强调一切以领域（Domain）为中心，强调领域专家（Domain Expert）的作用，强调先定义好领域模型之后在进行开发，并且领域模型可以指导开发（所谓的驱动）。</li><li>过程：理解领域、拆分领域、细化领域，模型的准确性取决于模型的理解深度。</li><li>设计：DDD 中提出了建模工具，比如聚合、实体、值对象、工厂、仓储、领域服务、领域事件来帮助领域建模。</li></ul></li><li><a href="https://www.cnblogs.com/butterfly100/p/7827870.html" target="_blank" rel="noopener">《领域驱动设计的基础知识总结》</a><ul><li>领域（Doamin）本质上就是问题域，比如一个电商系统，一个论坛系统等。</li><li>界限上下文（Bounded Context）：阐述子域之间的关系，可以简单理解成一个子系统或组件模块。</li><li>领域模型（Domain Model）：DDD的核心是建立（用通用描述语言、工具—领域通用语言）正确的领域模型；反应业务需求的本质，包括实体和过程；其贯穿软件分析、设计、开发 的整个过程；常用表达领域模型的方式：图、代码或文字；</li><li>领域通用语言：领域专家、开发设计人员都能立即的语言或工具。</li><li>经典分层架构：用户界面/展示层、应用层、领域层、基础设施层，是四层架构模式。</li><li>使用的模式：<ul><li>关联尽量少，尽量单项，尽量降低整体复杂度。</li><li>实体（Entity）：领域中的唯一标示，一个实体的属性尽量少，少则清晰。</li><li>值对象（Value Object）：没有唯一标识，且属性值不可变，小二简单的对象，比如Date。</li><li>领域服务（Domain Service）： 协调多个领域对象，只有方法没有状态(不存数据)；可以分为应用层服务，领域层服务、基础层服务。</li><li>聚合及聚合根（Aggregate，Aggregate Root）：聚合定义了一组具有内聚关系的相关对象的集合；聚合根是对聚合引用的唯一元素；当修改一个聚合时，必须在事务级别；大部分领域模型中，有70%的聚合通常只有一个实体，30%只有2~3个实体；如果一个聚合只有一个实体，那么这个实体就是聚合根；如果有多个实体，那么我们可以思考聚合内哪个对象有独立存在的意义并且可以和外部直接进行交互；</li><li>工厂（Factory）：类似于设计模式中的工厂模式。</li><li>仓储（Repository）：持久化到DB，管理对象，且只对聚合设计仓储。</li></ul></li><li><a href="http://www.cnblogs.com/Leo_wl/p/3866629.html" target="_blank" rel="noopener">《领域驱动设计(DDD)实现之路》</a><ul><li>聚合：比如一辆汽车（Car）包含了引擎（Engine）、车轮（Wheel）和油箱（Tank）等组件，缺一不可。</li></ul></li><li><a href="http://www.hollischuang.com/archives/553" target="_blank" rel="noopener">《领域驱动设计系列（2）浅析VO、DTO、DO、PO的概念、区别和用处》</a></li></ul></li></ul><h3 id="命令查询职责分离-CQRS"><a href="#命令查询职责分离-CQRS" class="headerlink" title="命令查询职责分离(CQRS)"></a><strong>命令查询职责分离(CQRS)</strong></h3><p>CQRS — Command Query Responsibility Seperation</p><ul><li><a href="https://www.cnblogs.com/cnblogsfans/p/4551990.html" target="_blank" rel="noopener">《领域驱动设计系列 (六)：CQRS》</a><ul><li>核心思想：读写分离（查询和更新在不同的方法中），不同的流程只是不同的设计方式，CQ代码分离，分布式环境中会有明显体现（有冗余数据的情况下），目的是为了高性能。</li></ul></li><li><a href="http://www.techweb.com.cn/network/system/2017-07-07/2553563.shtml" target="_blank" rel="noopener">《DDD CQRS架构和传统架构的优缺点比较》</a><ul><li>最终一致的设计理念；依赖于高可用消息中间件。</li></ul></li><li><a href="http://www.cnblogs.com/netfocus/p/4055346.html" target="_blank" rel="noopener">《CQRS架构简介》</a><ul><li>一个实现 CQRS 的抽象案例。</li></ul></li><li><a href="http://www.uml.org.cn/zjjs/201609221.asp" target="_blank" rel="noopener">《深度长文：我对CQRS/EventSourcing架构的思考》</a><ul><li>CQRS 模式分析 + 12306 抢票案例</li></ul></li></ul><h3 id="贫血，充血模型"><a href="#贫血，充血模型" class="headerlink" title="贫血，充血模型"></a><strong>贫血，充血模型</strong></h3><ul><li><a href="https://kb.cnblogs.com/page/520743/" target="_blank" rel="noopener">《贫血，充血模型的解释以及一些经验》</a><ul><li>失血模型：老子和儿子分别定义，相互不知道，二者实体定义中完全没有业务逻辑，通过外部Service进行关联。</li><li>贫血模型：老子知道儿子，儿子也知道老子；部分业务逻辑放到实体中；优点：各层单项依赖，结构清楚，易于维护；缺点：不符合OO思想，相比于充血模式，Service层较为厚重；</li><li>充血模型：和贫血模型类似，区别在于如何划分业务逻辑。优点：Service层比较薄，只充当Facade的角色，不和DAO打交道、复合OO思想；缺点：非单项依赖，DO和DAO之间双向依赖、和Service层的逻辑划分容易造成混乱。</li><li>肿胀模式：是一种极端情况，取消Service层、全部业务逻辑放在DO中；优点：符合OO思想、简化了分层；缺点：暴露信息过多、很多非DO逻辑也会强行并入DO。这种模式应该避免。</li><li>作者主张使用贫血模式。</li></ul></li></ul><h2 id="Actor-模式"><a href="#Actor-模式" class="headerlink" title="Actor 模式"></a><strong>Actor 模式</strong></h2><p>TODO</p><h2 id="响应式编程"><a href="#响应式编程" class="headerlink" title="响应式编程"></a><strong>响应式编程</strong></h2><h3 id="Reactor"><a href="#Reactor" class="headerlink" title="Reactor"></a><strong>Reactor</strong></h3><p>TODO</p><h3 id="RxJava"><a href="#RxJava" class="headerlink" title="RxJava"></a><strong>RxJava</strong></h3><p>TODO</p><h3 id="Vert-x"><a href="#Vert-x" class="headerlink" title="Vert.x"></a><strong>Vert.x</strong></h3><p>TODO</p><h2 id="DODAF2-0"><a href="#DODAF2-0" class="headerlink" title="DODAF2.0"></a><strong>DODAF2.0</strong></h2><ul><li><a href="http://www.360doc.com/content/16/0627/19/33945750_571201779.shtml" target="_blank" rel="noopener">《0方法论》</a></li><li><a href="http://blog.51cto.com/xiaoyong/1553164" target="_blank" rel="noopener">《0之能力视角如何落地》</a></li></ul><h2 id="Serverless"><a href="#Serverless" class="headerlink" title="Serverless"></a><strong>Serverless</strong></h2><p>TODO</p><h2 id="Service-Mesh"><a href="#Service-Mesh" class="headerlink" title="Service Mesh"></a><strong>Service Mesh</strong></h2><p>TODO</p><ul><li><a href="https://time.geekbang.org/article/2355" target="_blank" rel="noopener">《什么是Service Mesh？》</a></li></ul><h1 id="项目管理"><a href="#项目管理" class="headerlink" title="项目管理"></a><strong>项目管理</strong></h1><h2 id="架构评审"><a href="#架构评审" class="headerlink" title="架构评审"></a><strong>架构评审</strong></h2><ul><li><a href="http://developer.51cto.com/art/201506/478486.htm" target="_blank" rel="noopener">《架构设计之如何评审架构设计说明书》</a></li><li><a href="https://blog.csdn.net/wireless_com/article/details/45935591" target="_blank" rel="noopener">《人人都是架构师：非功能性需求》</a></li></ul><h2 id="重构"><a href="#重构" class="headerlink" title="重构"></a><strong>重构</strong></h2><ul><li><a href="http://www.infoq.com/cn/articles/architect-12-rules-complete/" target="_blank" rel="noopener">《架构之重构的12条军规》</a></li></ul><h2 id="代码规范"><a href="#代码规范" class="headerlink" title="代码规范"></a><strong>代码规范</strong></h2><p>TODO</p><h2 id="代码-Review"><a href="#代码-Review" class="headerlink" title="代码 Review"></a><strong>代码 Review</strong></h2><p>制度还是制度! 另外，每个公司需要根据自己的需求和目标制定自己的 check list</p><ul><li><a href="http://www.sohu.com/a/229745352_181657" target="_blank" rel="noopener">《为什么你做不好 Code Review？》</a><ul><li>代码 review 做的好，在于制度建设。</li></ul></li><li><a href="https://blog.csdn.net/uxyheaven/article/details/49773619" target="_blank" rel="noopener">《从零开始Code Review》</a></li><li><a href="https://www.cnblogs.com/zuoping/p/5477047.html" target="_blank" rel="noopener">《Code Review Checklist》</a></li><li><a href="https://dzone.com/articles/java-code-review-checklist" target="_blank" rel="noopener">《Java Code Review Checklist》</a></li><li><a href="https://blog.csdn.net/legend0011/article/details/45585575" target="_blank" rel="noopener">《如何用 gitlab 做 code review》</a></li></ul><h2 id="RUP"><a href="#RUP" class="headerlink" title="RUP"></a><strong>RUP</strong></h2><ul><li><a href="https://blog.csdn.net/apanious/article/details/51011946" target="_blank" rel="noopener">《运用RUP 4+1视图方法进行软件架构设计》</a></li></ul><h2 id="看板管理"><a href="#看板管理" class="headerlink" title="看板管理"></a><strong>看板管理</strong></h2><ul><li><a href="https://blog.csdn.net/tkchen/article/details/51637643" target="_blank" rel="noopener">《说说看板在项目中的应用》</a></li></ul><h2 id="SCRUM"><a href="#SCRUM" class="headerlink" title="SCRUM"></a><strong>SCRUM</strong></h2><p>SCRUM - 争球</p><ul><li>3个角色:Product Owner(PO) 产品负责人;Scrum Master（SM），推动Scrum执行;Team 开发团队。</li><li>3个工件：Product Backlog 产品TODOLIST，含优先级;Sprint Backlog 功能开发 TODO LIST；燃尽图；</li><li>五个价值观：专注、勇气、公开、承诺、尊重。</li><li><a href="https://blog.csdn.net/inny100_100/article/details/54633757" target="_blank" rel="noopener">《敏捷项目管理流程-Scrum框架最全总结！》</a></li><li><a href="https://blog.csdn.net/superkunkun/article/details/52951142" target="_blank" rel="noopener">《敏捷其实很简单3—敏捷方法之scrum》</a></li></ul><h2 id="敏捷开发"><a href="#敏捷开发" class="headerlink" title="敏捷开发"></a><strong>敏捷开发</strong></h2><p>TODO</p><h2 id="极限编程（XP）"><a href="#极限编程（XP）" class="headerlink" title="极限编程（XP）"></a><strong>极限编程（XP）</strong></h2><p>XP - eXtreme Programming</p><ul><li><a href="http://www.woshipm.com/pmd/406917.html" target="_blank" rel="noopener">《主流敏捷开发方法：极限编程XP》</a><ul><li>是一种指导开发人员的方法论。</li><li>4大价值：<ul><li>沟通：鼓励口头沟通，提高效率。</li><li>简单：够用就好。</li><li>反馈：及时反馈、通知相关人。</li><li>勇气：提倡拥抱变化，敢于重构。</li></ul></li><li>5个原则：快速反馈、简单性假设、逐步修改、提倡更改（小步快跑）、优质工作（保证质量的前提下保证小步快跑）。</li><li>5个工作：阶段性冲刺；冲刺计划会议；每日站立会议；冲刺后review；回顾会议。</li></ul></li></ul><h2 id="结对编程"><a href="#结对编程" class="headerlink" title="结对编程"></a><strong>结对编程</strong></h2><p>边写码，边review。能够增强代码质量、减少bug。</p><ul><li><a href="http://www.baike.com/wiki/%E7%BB%93%E5%AF%B9%E7%BC%96%E7%A8%8B" target="_blank" rel="noopener">《结对编程》</a></li></ul><h2 id="FMEA管理模式"><a href="#FMEA管理模式" class="headerlink" title="FMEA管理模式"></a><strong>FMEA管理模式</strong></h2><p>TODO</p><h1 id="通用业务术语"><a href="#通用业务术语" class="headerlink" title="通用业务术语"></a><strong>通用业务术语</strong></h1><p>TODO</p><h1 id="技术趋势"><a href="#技术趋势" class="headerlink" title="技术趋势"></a><strong>技术趋势</strong></h1><p>TODO</p><h1 id="政策、法规"><a href="#政策、法规" class="headerlink" title="政策、法规"></a><strong>政策、法规</strong></h1><p>TODO</p><h2 id="法律"><a href="#法律" class="headerlink" title="法律"></a><strong>法律</strong></h2><h3 id="严格遵守刑法253法条"><a href="#严格遵守刑法253法条" class="headerlink" title="严格遵守刑法253法条"></a><strong>严格遵守刑法253法条</strong></h3><p>我国刑法第253条之一规定：</p><ul><li>国家机关或者金融、电信、交通、教育、医疗等单位的工作人员，违反国家规定，将本单位在履行职责或者提供服务过程中获得的公民个人信息，出售或者非法提供给他人，情节严重的，处3年以下有期徒刑或者拘役，并处或者单处罚金。</li><li>窃取或者以其他方法非法获取上述信息，情节严重的，依照前款的规定处罚。</li><li>单位犯前两款罪的，对单位判处罚金，并对其直接负责的主管人员和其他直接责任人员，依照各该款的规定处罚。</li></ul><p>最高人民法院、最高人民检察院关于执行《中华人民共和国刑法》确定罪名的补充规定（四）规定：触犯刑法第253条之一第1款之规定，构成“出售、非法提供公民个人信息罪”；触犯刑法第253条之一第2款之规定，构成“非法获取公民个人信息罪”</p><ul><li><a href="https://baike.baidu.com/item/%E9%9D%9E%E6%B3%95%E8%8E%B7%E5%8F%96%E5%85%AC%E6%B0%91%E4%B8%AA%E4%BA%BA%E4%BF%A1%E6%81%AF%E7%BD%AA" target="_blank" rel="noopener">《非法获取公民个人信息罪》</a></li></ul><h1 id="架构师素质"><a href="#架构师素质" class="headerlink" title="架构师素质"></a><strong>架构师素质</strong></h1><ul><li><a href="http://hellojava.info/?p=430" target="_blank" rel="noopener">《架构师画像》</a><ul><li>业务理解和抽象能力</li><li>NB的代码能力</li><li>全面： 在面对业务问题上，架构师脑海里是否会浮现出多种技术方案；2. 在做系统设计时是否考虑到了足够多的方方面面；3. 在做系统设计时是否考虑到了足够多的方方面面；</li><li>全局：是否考虑到了对上下游的系统的影响。</li><li>权衡：权衡投入产出比；优先级和节奏控制；</li></ul></li><li><a href="http://www.infoq.com/cn/articles/architecture-optimization-and-design-the-architect-must-know" target="_blank" rel="noopener">《关于架构优化和设计，架构师必须知道的事情》</a><ul><li>要去考虑的细节：模块化、轻耦合、无共享架构；减少各个组件之前的依懒、注意服务之间依懒所有造成的链式失败及影响等。</li><li>基础设施、配置、测试、开发、运维综合考虑。</li><li>考虑人、团队、和组织的影响。</li></ul></li><li><a href="https://www.zhihu.com/question/19841397" target="_blank" rel="noopener">《如何才能真正的提高自己，成为一名出色的架构师？》</a></li><li><a href="https://blog.csdn.net/sanbingyutuoniao123/article/details/54144129" target="_blank" rel="noopener">《架构师的必备素质和成长途径》</a><ul><li>素质：业务理解、技术广度、技术深度、丰富经验、沟通能力、动手能力、美学素养。</li><li>成长路径：2年积累知识、4年积累技能和祖内影响力、7年积累部门内影响力、7年以上积累跨部门影响力。</li></ul></li><li><a href="http://blog.51cto.com/frankfan/1248401" target="_blank" rel="noopener">《架构设计师—你在哪层楼？》</a><ul><li>第一层的架构师看到的只是产品本身</li><li>第二层的架构师不仅看到自己的产品，还看到了整体的方案</li><li>第三层的架构师看到的是商业价值</li></ul></li></ul><h1 id="团队管理"><a href="#团队管理" class="headerlink" title="团队管理"></a><strong>团队管理</strong></h1><p>TODO</p><h2 id="招聘"><a href="#招聘" class="headerlink" title="招聘"></a><strong>招聘</strong></h2><h1 id="资讯"><a href="#资讯" class="headerlink" title="资讯"></a><strong>资讯</strong></h1><h2 id="行业资讯"><a href="#行业资讯" class="headerlink" title="行业资讯"></a><strong>行业资讯</strong></h2><ul><li><a href="http://36kr.com/" target="_blank" rel="noopener">36kr</a></li><li><a href="http://www.techweb.com.cn/" target="_blank" rel="noopener">Techweb</a></li></ul><h2 id="公众号列表"><a href="#公众号列表" class="headerlink" title="公众号列表"></a><strong>公众号列表</strong></h2><p>TODO</p><h2 id="博客"><a href="#博客" class="headerlink" title="博客"></a><strong>博客</strong></h2><h3 id="团队博客"><a href="#团队博客" class="headerlink" title="团队博客"></a><strong>团队博客</strong></h3><ul><li><a href="http://jm.taobao.org/" target="_blank" rel="noopener">阿里中间件博客</a></li><li><a href="https://tech.meituan.com/" target="_blank" rel="noopener">美团点评技术团队博客</a></li></ul><h3 id="个人博客"><a href="#个人博客" class="headerlink" title="个人博客"></a><strong>个人博客</strong></h3><ul><li><a href="http://www.ruanyifeng.com/" target="_blank" rel="noopener">阮一峰的网络日志</a></li><li><a href="https://coolshell.cn/" target="_blank" rel="noopener">酷壳 - COOLSHELL-陈皓</a></li><li><a href="http://hellojava.info/" target="_blank" rel="noopener">hellojava-阿里毕玄</a></li><li><a href="http://cmsblogs.com/" target="_blank" rel="noopener">Cm’s Blog</a></li><li><a href="http://blog.didispace.com/" target="_blank" rel="noopener">程序猿DD-翟永超-《Spring Cloud微服务实战》作者</a></li></ul><h2 id="综合门户、社区"><a href="#综合门户、社区" class="headerlink" title="综合门户、社区"></a><strong>综合门户、社区</strong></h2><p><strong>国内：</strong></p><ul><li><a href="http://csdn.net/" target="_blank" rel="noopener">CSDN</a>老牌技术社区、不必解释。</li><li><a href="http://www.51cto.com/" target="_blank" rel="noopener">com</a></li><li><a href="http://www.iteye.com/" target="_blank" rel="noopener">ITeye</a><ul><li>偏 Java 方向</li></ul></li><li><a href="https://www.cnblogs.com/" target="_blank" rel="noopener">博客园</a></li><li><a href="http://www.tom.net/" target="_blank" rel="noopener">ChinaUnix</a><ul><li>偏 Linux 方向</li></ul></li><li><a href="https://www.oschina.net/" target="_blank" rel="noopener">开源中国社区</a></li><li><a href="http://www.open-open.com/" target="_blank" rel="noopener">深度开源</a></li><li><a href="http://www.jobbole.com/" target="_blank" rel="noopener">伯乐在线</a><ul><li>涵盖 IT职场、Web前端、后端、移动端、数据库等方面内容，偏技术端。</li></ul></li><li><a href="http://www.itpub.net/" target="_blank" rel="noopener">ITPUB</a></li><li><a href="https://cloud.tencent.com/developer/column" target="_blank" rel="noopener">腾讯云— 云+社区</a></li><li><a href="https://yq.aliyun.com/" target="_blank" rel="noopener">阿里云— 云栖社区</a></li><li><a href="https://www.ibm.com/developerworks/cn/" target="_blank" rel="noopener">IBM DeveloperWorks</a></li><li><a href="https://toutiao.io/" target="_blank" rel="noopener">开发者头条</a></li><li><a href="http://www.linkedkeeper.com/" target="_blank" rel="noopener">LinkedKeeper</a></li></ul><p><strong>国外：</strong></p><ul><li><a href="https://dzone.com/" target="_blank" rel="noopener">DZone</a></li><li><a href="https://www.reddit.com/" target="_blank" rel="noopener">Reddit</a></li></ul><h2 id="问答、讨论类社区"><a href="#问答、讨论类社区" class="headerlink" title="问答、讨论类社区"></a><strong>问答、讨论类社区</strong></h2><ul><li><a href="https://segmentfault.com/" target="_blank" rel="noopener">segmentfault</a><ul><li>问答+专栏</li></ul></li><li><a href="https://www.zhihu.com/" target="_blank" rel="noopener">知乎</a></li><li><a href="https://stackoverflow.com/" target="_blank" rel="noopener">stackoverflow</a></li></ul><h2 id="行业数据分析"><a href="#行业数据分析" class="headerlink" title="行业数据分析"></a><strong>行业数据分析</strong></h2><ul><li><a href="http://report.iresearch.cn/" target="_blank" rel="noopener">艾瑞网</a></li><li><a href="https://www.questmobile.com.cn/" target="_blank" rel="noopener">QUEST MOBILE</a></li></ul><h2 id="专项网站"><a href="#专项网站" class="headerlink" title="专项网站"></a><strong>专项网站</strong></h2><ul><li>测试:<ul><li><a href="http://www.ltesting.net/" target="_blank" rel="noopener">领测国际</a></li><li><a href="https://www.testwo.com/" target="_blank" rel="noopener">测试窝</a></li><li><a href="https://testerhome.com/" target="_blank" rel="noopener">TesterHome</a></li></ul></li><li>运维:<ul><li><a href="http://www.yunweipai.com/" target="_blank" rel="noopener">运维派</a></li><li><a href="https://www.abcdocker.com/" target="_blank" rel="noopener">Abcdocker</a></li></ul></li><li>Java:<ul><li><a href="http://www.importnew.com/" target="_blank" rel="noopener">ImportNew</a><ul><li>专注于 Java 技术分享</li></ul></li><li><a href="https://howtodoinjava.com/" target="_blank" rel="noopener">HowToDoInJava</a><ul><li>英文博客</li></ul></li><li>安全<ul><li><a href="https://www.2cto.com/" target="_blank" rel="noopener">红黑联盟</a></li><li><a href="http://www.freebuf.com/" target="_blank" rel="noopener">FreeBuf</a></li></ul></li><li>大数据<ul><li><a href="http://www.thebigdata.cn/" target="_blank" rel="noopener">中国大数据</a></li></ul></li><li>其他专题网站：<ul><li><a href="http://www.dockerinfo.net/" target="_blank" rel="noopener">DockerInfo</a><ul><li>专注于 Docker 应用及咨询、教程的网站。</li></ul></li><li><a href="https://www.linuxidc.com/" target="_blank" rel="noopener">Linux公社</a><ul><li>Linux 主题社区</li></ul></li></ul></li></ul></li></ul><h2 id="其他类"><a href="#其他类" class="headerlink" title="其他类"></a><strong>其他类</strong></h2><ul><li><a href="https://github.com/TeamStuQ/skill-map" target="_blank" rel="noopener">程序员技能图谱</a></li></ul><h2 id="推荐参考书"><a href="#推荐参考书" class="headerlink" title="推荐参考书"></a><strong>推荐参考书</strong></h2><h3 id="在线电子书"><a href="#在线电子书" class="headerlink" title="在线电子书"></a><strong>在线电子书</strong></h3><ul><li><a href="https://github.com/forezp/SpringCloudLearning" target="_blank" rel="noopener">《深入理解Spring Cloud与微服务构建》</a></li><li><a href="http://techforum-img.cn-hangzhou.oss-pub.aliyun-inc.com/1523849261680/AliTech101_RD.pdf" target="_blank" rel="noopener">《阿里技术参考图册-研发篇》</a></li><li><a href="http://techforum-img.cn-hangzhou.oss-pub.aliyun-inc.com/1523848064814/AliTech101_Algorithms.pdf" target="_blank" rel="noopener">《阿里技术参考图册-算法篇》</a></li><li><a href="http://dpurl.cn/n/1lqcX" target="_blank" rel="noopener">《2018美团点评技术年货（合辑）》70M</a></li><li><a href="http://www.infoq.com/cn/architect/" target="_blank" rel="noopener">InfoQ《架构师》月刊</a></li></ul><h3 id="纸质书"><a href="#纸质书" class="headerlink" title="纸质书"></a><strong>纸质书</strong></h3><h4 id="开发方面"><a href="#开发方面" class="headerlink" title="开发方面"></a><strong>开发方面</strong></h4><ul><li>《阿里巴巴Java开发手册》<a href="https://union-click.jd.com/jdc?d=bVKwZQ" target="_blank" rel="noopener">京东</a><a href="https://s.taobao.com/search?q=%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4Java%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C" target="_blank" rel="noopener">淘宝</a></li></ul><h4 id="架构方面"><a href="#架构方面" class="headerlink" title="架构方面"></a><strong>架构方面</strong></h4><ul><li>《软件架构师的12项修炼：技术技能篇》<a href="https://union-click.jd.com/jdc?d=gXvRd8" target="_blank" rel="noopener">京东</a><a href="https://s.taobao.com/search?q=%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E5%B8%88%E7%9A%8412%E9%A1%B9%E4%BF%AE%E7%82%BC%EF%BC%9A%E6%8A%80%E6%9C%AF%E6%8A%80%E8%83%BD%E7%AF%87" target="_blank" rel="noopener">淘宝</a></li><li>《架构之美》<a href="https://union-click.jd.com/jdc?d=xJit5I" target="_blank" rel="noopener">京东</a><a href="https://s.taobao.com/search?q=%E6%9E%B6%E6%9E%84%E4%B9%8B%E7%BE%8E" target="_blank" rel="noopener">淘宝</a></li><li>《分布式服务架构》<a href="https://union-click.jd.com/jdc?d=JS5Od9" target="_blank" rel="noopener">京东</a><a href="https://s.taobao.com/search?q=%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84" target="_blank" rel="noopener">淘宝</a></li><li>《聊聊架构》<a href="https://union-click.jd.com/jdc?d=FHooH4" target="_blank" rel="noopener">京东</a> <a href="https://s.taobao.com/search?q=%E8%81%8A%E8%81%8A%E6%9E%B6%E6%9E%84" target="_blank" rel="noopener">淘宝</a></li><li>《云原生应用架构实践》<a href="https://union-click.jd.com/jdc?d=orkJSj" target="_blank" rel="noopener">京东</a><a href="https://s.taobao.com/search?q=%E4%BA%91%E5%8E%9F%E7%94%9F%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84%E5%AE%9E%E8%B7%B5" target="_blank" rel="noopener">淘宝</a></li><li>《亿级流量网站架构核心技术》<a href="https://union-click.jd.com/jdc?d=RnOSP5" target="_blank" rel="noopener">京东</a><a href="https://s.taobao.com/search?q=%E4%BA%BF%E7%BA%A7%E6%B5%81%E9%87%8F%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF" target="_blank" rel="noopener">淘宝</a></li><li>《淘宝技术这十年》<a href="https://union-click.jd.com/jdc?d=LwrDfD" target="_blank" rel="noopener">京东</a><a href="https://s.taobao.com/search?q=%E6%B7%98%E5%AE%9D%E6%8A%80%E6%9C%AF%E8%BF%99%E5%8D%81%E5%B9%B4" target="_blank" rel="noopener">淘宝</a></li><li>《企业IT架构转型之道-中台战略思想与架构实战》 <a href="https://union-click.jd.com/jdc?d=89pAEm" target="_blank" rel="noopener">京东</a><a href="https://s.taobao.com/search?q=%E4%BC%81%E4%B8%9AIT%E6%9E%B6%E6%9E%84%E8%BD%AC%E5%9E%8B%E4%B9%8B%E9%81%93" target="_blank" rel="noopener">淘宝</a></li></ul><h4 id="技术管理方面"><a href="#技术管理方面" class="headerlink" title="技术管理方面"></a><strong>技术管理方面</strong></h4><ul><li>《CTO说》<a href="https://union-click.jd.com/jdc?d=zhTZyr" target="_blank" rel="noopener">京东</a><a href="https://s.taobao.com/search?q=CTO%E8%AF%B4" target="_blank" rel="noopener">淘宝</a></li><li>《技术管理之巅》<a href="https://union-click.jd.com/jdc?d=LgRBUW" target="_blank" rel="noopener">京东</a><a href="https://s.taobao.com/search?q=%E6%8A%80%E6%9C%AF%E7%AE%A1%E7%90%86%E4%B9%8B%E5%B7%85" target="_blank" rel="noopener">淘宝</a></li><li>《网易一千零一夜：互联网产品项目管理实战》<a href="https://union-click.jd.com/jdc?d=jcRz2r" target="_blank" rel="noopener">京东</a><a href="https://s.taobao.com/search?q=%E7%BD%91%E6%98%93%E4%B8%80%E5%8D%83%E9%9B%B6%E4%B8%80%E5%A4%9C%EF%BC%9A%E4%BA%92%E8%81%94%E7%BD%91%E4%BA%A7%E5%93%81%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E5%AE%9E%E6%88%98" target="_blank" rel="noopener">淘宝</a></li></ul><h4 id="基础理论-1"><a href="#基础理论-1" class="headerlink" title="基础理论"></a><strong>基础理论</strong></h4><ul><li>《数学之美》<a href="https://union-click.jd.com/jdc?d=ghIES2" target="_blank" rel="noopener">京东</a><a href="https://s.taobao.com/search?q=%E6%95%B0%E5%AD%A6%E4%B9%8B%E7%BE%8E" target="_blank" rel="noopener">淘宝</a></li><li>《编程珠玑》<a href="https://union-click.jd.com/jdc?d=YmhdEu" target="_blank" rel="noopener">京东</a><a href="https://s.taobao.com/search?q=%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91" target="_blank" rel="noopener">淘宝</a></li></ul><h4 id="工具方面"><a href="#工具方面" class="headerlink" title="工具方面"></a><strong>工具方面</strong></h4><p>TODO</p><h4 id="大数据方面"><a href="#大数据方面" class="headerlink" title="大数据方面"></a><strong>大数据方面</strong></h4><h1 id="技术资源"><a href="#技术资源" class="headerlink" title="技术资源"></a><strong>技术资源</strong></h1><h2 id="开源资源"><a href="#开源资源" class="headerlink" title="开源资源"></a><strong>开源资源</strong></h2><ul><li><a href="https://github.com/" target="_blank" rel="noopener">github</a></li><li><a href="https://www.apache.org/index.html" target="_blank" rel="noopener">Apache 软件基金会</a></li></ul><h2 id="手册、文档、教程"><a href="#手册、文档、教程" class="headerlink" title="手册、文档、教程"></a><strong>手册、文档、教程</strong></h2><p><strong>国内：</strong></p><ul><li><a href="http://w3cschool.cn/" target="_blank" rel="noopener">W3Cschool</a></li><li><a href="http://www.runoob.com/" target="_blank" rel="noopener">com</a><ul><li>HTML 、 CSS、XML、Java、Python、PHP、设计模式等入门手册。</li></ul></li><li><a href="https://love2.io/" target="_blank" rel="noopener">io</a><ul><li>很多很多中文在线电子书，是一个全新的开源技术文档分享平台。</li></ul></li><li><a href="http://gitbook.cn/" target="_blank" rel="noopener">cn</a><ul><li>付费电子书。</li></ul></li><li><a href="http://www.apachecn.org/" target="_blank" rel="noopener">ApacheCN</a><ul><li>AI、大数据方面系列中文文档。</li></ul></li></ul><p><strong>国外：</strong></p><ul><li><a href="http://www.quickcode.co/" target="_blank" rel="noopener">Quick Code</a><ul><li>免费在线技术教程。</li></ul></li><li><a href="http://gitbook.com/" target="_blank" rel="noopener">com</a><ul><li>有部分中文电子书。</li></ul></li><li><a href="https://www.cheatography.com/" target="_blank" rel="noopener">Cheatography</a><ul><li>Cheat Sheets 大全，单页文档网站。</li></ul></li></ul><h2 id="在线课堂"><a href="#在线课堂" class="headerlink" title="在线课堂"></a><strong>在线课堂</strong></h2><ul><li><a href="http://www.xuetuwuyou.com/" target="_blank" rel="noopener">学徒无忧</a></li><li><a href="https://time.geekbang.org/" target="_blank" rel="noopener">极客时间</a></li><li><a href="https://segmentfault.com/lives" target="_blank" rel="noopener">segmentfault</a></li><li><a href="https://new.stuq.org/course/explore" target="_blank" rel="noopener">斯达克学院</a></li><li><a href="http://nowcoder.com/" target="_blank" rel="noopener">牛客网</a></li><li><a href="https://www.jikexueyuan.com/" target="_blank" rel="noopener">极客学院</a></li><li><a href="http://edu.51cto.com/" target="_blank" rel="noopener">51CTO学院</a></li></ul><h2 id="会议、活动"><a href="#会议、活动" class="headerlink" title="会议、活动"></a><strong>会议、活动</strong></h2><ul><li><a href="http://www.infoq.com/cn/qcon/" target="_blank" rel="noopener">QCon</a></li><li><a href="https://archsummit.com/" target="_blank" rel="noopener">ArchSummit</a></li><li><a href="http://www.thegitc.com/" target="_blank" rel="noopener">GITC全球互联网技术大会</a></li></ul><p><strong>活动发布平台:</strong></p><ul><li><a href="http://www.huodongxing.com/" target="_blank" rel="noopener">活动行</a></li></ul><h2 id="常用APP"><a href="#常用APP" class="headerlink" title="常用APP"></a><strong>常用APP</strong></h2><ul><li><a href="https://time.geekbang.org/" target="_blank" rel="noopener">极客时间</a></li><li><a href="https://www.igetget.com/" target="_blank" rel="noopener">得到</a></li></ul><h2 id="找工作"><a href="#找工作" class="headerlink" title="找工作"></a><strong>找工作</strong></h2><ul><li><a href="https://www.zhipin.com/" target="_blank" rel="noopener">Boss直聘</a></li><li><a href="https://www.lagou.com/" target="_blank" rel="noopener">拉勾网</a></li><li><a href="https://www.liepin.com/" target="_blank" rel="noopener">猎聘</a></li><li><a href="https://cn.100offer.com/" target="_blank" rel="noopener">100Offer</a></li></ul><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a><strong>工具</strong></h2><ul><li><a href="https://s.geekbang.org/" target="_blank" rel="noopener">极客搜索</a><ul><li>技术文章搜索引擎。</li></ul></li></ul><h2 id="代码托管"><a href="#代码托管" class="headerlink" title="代码托管"></a><strong>代码托管</strong></h2><ul><li><a href="https://coding.net/" target="_blank" rel="noopener">Coding</a></li><li><a href="https://gitee.com/" target="_blank" rel="noopener">码云</a></li></ul><h2 id="文件服务"><a href="#文件服务" class="headerlink" title="文件服务"></a><strong>文件服务</strong></h2><ul><li>七牛</li><li>又拍云</li></ul><h2 id="综合云服务商"><a href="#综合云服务商" class="headerlink" title="综合云服务商"></a><strong>综合云服务商</strong></h2><ul><li>阿里云</li><li>腾讯云</li><li>百度云</li><li>新浪云</li><li>金山云</li></ul>]]></content>
      
      
      <categories>
          
          <category> 架构技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 架构技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx的概义和环境配置安装</title>
      <link href="/2020/01/04/Nginx%E7%9A%84%E6%A6%82%E4%B9%89%E5%92%8C%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%AE%89%E8%A3%85/"/>
      <url>/2020/01/04/Nginx%E7%9A%84%E6%A6%82%E4%B9%89%E5%92%8C%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Nginx是lgor Sysoev为俄罗斯访问量第二的rambler.ru站点设计开发的。从2004年发布至今，凭借开源的力量，已经接近成熟与完善。</p><h2 id="Nginx常用功能"><a href="#Nginx常用功能" class="headerlink" title="Nginx常用功能"></a>Nginx常用功能</h2><h3 id="Http代理，反向代理：作为web服务器最常用的功能之一"><a href="#Http代理，反向代理：作为web服务器最常用的功能之一" class="headerlink" title="Http代理，反向代理：作为web服务器最常用的功能之一;"></a><strong>Http代理，反向代理：作为web服务器最常用的功能之一;</strong></h3><p><a href="/images/dfasdfasd.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/dfasdfasd.png" class="lazyload"></a></p><p>Nginx在做反向代理时，提供性能稳定，并且能够提供配置灵活的转发功能。Nginx可以根据不同的正则匹配，采取不同的转发策略，比如图片文件结尾的走文件服务器，动态页面走web服务器，只要你正则写的没问题，又有相对应的服务器解决方案，你就可以随心所欲的玩。并且Nginx对返回结果进行错误页跳转，异常判断等。如果被分发的服务器存在异常，他可以将请求重新转发给另外一台服务器，然后自动去除异常服务器。</p><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a><strong>负载均衡</strong></h3><p>Nginx提供的负载均衡策略有2种：<strong>内置策略和扩展策略。内置策略为轮询</strong>，<strong>加权轮询</strong>，<strong>Ip hash</strong>。扩展策略就天马行空，只有你想不到的没有他做不到的啦，你可以参照所有的负载均衡算法，给他一一找出来做下实现。<br>上个图，理解这三种负载均衡算法的实现</p><p><a href="/images/sdfasdfc.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/sdfasdfc.png" class="lazyload"></a></p><p>Ip hash算法，对客户端请求的ip进行hash操作，然后根据hash结果将同一个客户端ip的请求分发给同一台服务器进行处理，可以解决session不共享的问题。</p><p><a href="/images/adfasdfa.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/adfasdfa.png" class="lazyload"></a></p><h3 id="web缓存"><a href="#web缓存" class="headerlink" title="web缓存"></a><strong>web缓存</strong></h3><p>ginx可以对不同的文件做不同的缓存处理，配置灵活，并且支持FastCGI_Cache，主要用于对FastCGI的动态程序进行缓存。配合着第三方的ngx_cache_purge，对制定的URL缓存内容可以的进行增删管理。</p><h3 id="Nginx相关地址"><a href="#Nginx相关地址" class="headerlink" title="Nginx相关地址"></a><strong>Nginx相关地址</strong></h3><blockquote><p>源码：<a href="https://trac.nginx.org/nginx/browser" target="_blank" rel="noopener">https://trac.nginx.org/nginx/browser</a><br>官网：<a href="http://www.nginx.org/" target="_blank" rel="noopener">http://www.nginx.org/</a></p></blockquote><h2 id="Nginx环境配置"><a href="#Nginx环境配置" class="headerlink" title="Nginx环境配置"></a>Nginx环境配置</h2><p>反向代理（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器。  </p><blockquote><p>Nginx 下载地址：<a href="http://nginx.org/en/download.html" target="_blank" rel="noopener">http://nginx.org/en/download.html</a><br>根据自己的需求选择下载的Nginx包；</p></blockquote><p><strong>可以通过DOS命令启动服务：也可以直接双击nginx.exe 启动服务；</strong></p><blockquote><p>启动服务：start nginx<br>退出服务：nginx -s quit<br>强制关闭服务：nginx -s stop<br>重载服务：nginx -s reload　　（重载服务配置文件，类似于重启，服务不会中止）<br>验证配置文件：nginx -t<br>使用配置文件：nginx -c “配置文件路径”<br>使用帮助：nginx –h</p></blockquote><p><a href="/images/dasfasdf.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/dasfasdf.png" class="lazyload"></a></p><p>服务启动之后：</p><p><a href="/images/1324sdfds1.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/1324sdfds1.png" class="lazyload"></a></p><p>开浏览器，输入地址：<a href="http://localhost:88" target="_blank" rel="noopener">http://localhost:88</a>，访问页面，出现如下页面表示访问成功。</p><p><a href="/images/32dscasdf1.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/32dscasdf1.png" class="lazyload"></a></p><h2 id="Nginx配置负载均衡"><a href="#Nginx配置负载均衡" class="headerlink" title="Nginx配置负载均衡"></a>Nginx配置负载均衡</h2><p>我们可以看到nginx文件夹内有一个conf文件夹，其中有好几个文件，其他先不管，我们打开nginx.conf，可以看到一段：</p><p><a href="/images/243rfdasa1.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/243rfdasa1.png" class="lazyload"></a></p><p>这段代码在server里面，相当于一个代理服务器，当然可以配置多个。</p><p><strong>下面我们仔细来分析一下：</strong></p><ul><li><strong>listen：</strong>表示当前的代理服务器监听的端口，默认的是监听80端口。注意，如果我们配置了多个server，这个listen要配置不一样，不然就不能确定转到哪里去了。</li><li><strong>server_name：</strong>表示监听到之后需要转到哪里去，这时我们直接转到本地，这时是直接到nginx文件夹内。</li><li><strong>location：</strong>表示匹配的路径，这时配置了/表示所有请求都被匹配到这里。</li><li><strong>root：</strong>里面配置了root这时表示当匹配这个请求的路径时，将会在这个文件夹内寻找相应的文件，这里对我们之后的静态文件伺服很有用。</li><li><strong>index：</strong>当没有指定主页时，默认会选择这个指定的文件，它可以有多个，并按顺序来加载，如果第一个不存在，则找第二个，依此类推。</li></ul><h2 id="Nginx负载均衡"><a href="#Nginx负载均衡" class="headerlink" title="Nginx负载均衡"></a>Nginx负载均衡</h2><h3 id="负载均衡的作用"><a href="#负载均衡的作用" class="headerlink" title="负载均衡的作用"></a>负载均衡的作用</h3><h4 id="转发功能"><a href="#转发功能" class="headerlink" title="转发功能"></a>转发功能</h4><p>按照一定的算法【权重、轮询】，将客户端请求转发到不同应用服务器上，减轻单个服务器压力，提高系统并发量。</p><h4 id="故障移除"><a href="#故障移除" class="headerlink" title="故障移除"></a>故障移除</h4><p>通过心跳检测的方式，判断应用服务器当前是否可以正常工作，如果服务器期宕掉，自动将请求发送到其他应用服务器。</p><h4 id="恢复添加"><a href="#恢复添加" class="headerlink" title="恢复添加"></a>恢复添加</h4><p>如检测到发生故障的应用服务器恢复工作，自动将其添加到处理用户请求队伍中。</p><p><a href="/images/f43fcsda.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/f43fcsda.png" class="lazyload"></a></p><h3 id="Nginx实现负载均衡"><a href="#Nginx实现负载均衡" class="headerlink" title="Nginx实现负载均衡"></a>Nginx实现负载均衡</h3><p>同样部署多台应用服务器，端口号分别为10086 和10087。。。。。</p><h4 id="Nginx的负载分发策略"><a href="#Nginx的负载分发策略" class="headerlink" title="Nginx的负载分发策略"></a>Nginx的负载分发策略</h4><p>Nginx 的 upstream目前支持的分配算法：</p><h5 id="轮询-——1：1-轮流处理请求（默认）"><a href="#轮询-——1：1-轮流处理请求（默认）" class="headerlink" title="轮询 ——1：1 轮流处理请求（默认）"></a>轮询 ——1：1 轮流处理请求（默认）</h5><p>每个请求按时间顺序逐一分配到不同的应用服务器，如果应用服务器down掉，自动剔除，剩下的继续轮询。</p><h5 id="权重-——you-can-you-up"><a href="#权重-——you-can-you-up" class="headerlink" title="权重 ——you can you up"></a>权重 ——you can you up</h5><p>通过配置权重，指定轮询几率，权重和访问比率成正比，用于应用服务器性能不均的情况。</p><h5 id="ip-哈希算法"><a href="#ip-哈希算法" class="headerlink" title="ip_哈希算法"></a>ip_哈希算法</h5><p>每个请求按访问ip的hash结果分配，这样每个访客固定访问一个应用服务器，可以解决session共享的问题。</p><h4 id="配置Nginx的负载均衡与分发策略"><a href="#配置Nginx的负载均衡与分发策略" class="headerlink" title="配置Nginx的负载均衡与分发策略"></a>配置Nginx的负载均衡与分发策略</h4><p>通过在upstream参数中添加的应用服务器IP后添加指定参数即可实现，如：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">upstream webApi &#123;  </span><br><span class="line">server localhost:10088 weight&#x3D;6;  </span><br><span class="line">server localhost:10087;   </span><br><span class="line">server localhost:10086;</span><br><span class="line">    &#125;    </span><br><span class="line"> server &#123;  </span><br><span class="line">        listen       8080;  </span><br><span class="line">        server_name  8080.max.com;  </span><br><span class="line">        #charset koi8-r;  </span><br><span class="line">        #access_log  logs&#x2F;host.access.log  main;  </span><br><span class="line">        location &#x2F; &#123;  </span><br><span class="line">             proxy_pass http:&#x2F;&#x2F;webApi;  </span><br><span class="line">            index  index.html index.htm;  </span><br><span class="line">        &#125;  </span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></div><p>通过以上配置，便可以实现，在访问8080.max.com这个网站时，由于配置了proxy_pass地址，所有请求都会先通过nginx反向代理服务器，在服务器将请求转发给目的主机时，读取upstream为 webApi的地址，读取分发策略，配置server1权重为3，所以nginx会将大部分请求发送给49服务器上的server2，也就是8080端口；较少部分给tomcat2来实现有条件的负载均衡，当然这个条件就是服务器1、2的硬件指数处理请求能力。</p><h4 id="nginx其他配置"><a href="#nginx其他配置" class="headerlink" title="nginx其他配置"></a>nginx其他配置</h4><ul><li><strong>down：</strong> 表示单前的server暂时不参与负载</li><li><strong>Weight：</strong> 默认为1. weight越大，负载的权重就越大。</li><li><strong>max_fails：</strong> 允许请求失败的次数默认为1.当超过最大次数时，返回proxy_next_upstream 模块定义的错误</li><li><strong>fail_timeout：</strong> max_fails 次失败后，暂停的时间。</li><li><strong>Backup：</strong> 其它所有的非backup机器down或者忙的时候，请求backup机器。所以这台机器压力会最轻。</li></ul><h3 id="使用Nginx的高可用"><a href="#使用Nginx的高可用" class="headerlink" title="使用Nginx的高可用"></a>使用Nginx的高可用</h3><p>除了要实现网站的高可用，也就是提供n多台服务器用于发布相同的服务，添加负载均衡服务器分发请求以保证在高并发下各台服务器能相对饱和的处理请求。同样，负载均衡服务器也需要高可用，以防如果负载均衡服务器挂掉了，后面的应用服务器也紊乱无法工作。</p><p><strong>实现高可用的方案：</strong> 添加冗余。添加n台nginx服务器以避免发生上述单点故障。具体方案详见下文：keepalive+nginx实现负载均衡高可用</p><h2 id="解决nginx负载均衡的session共享问题"><a href="#解决nginx负载均衡的session共享问题" class="headerlink" title="解决nginx负载均衡的session共享问题"></a>解决nginx负载均衡的session共享问题</h2><p>服务器有多台，用nginx做负载均衡，这样同一个IP访问同一个页面会被分配到不同的服务器上，如果session不同步的话，就会出现很多问题，比如说登录</p><h3 id="不使用session，换用cookie"><a href="#不使用session，换用cookie" class="headerlink" title="不使用session，换用cookie"></a>不使用session，换用cookie</h3><p>session是存放在服务器端的，cookie是存放在客户端的，可以把用户访问页面产生的session放到cookie里面，就是以cookie为中转站。</p><p>访问web服务器A，产生了session然后把它放到cookie里面，当你的请求被分配到B服务器时，服务器B先判断服务器有没有这个session，如果没有，再去看看客户端的cookie里面有没有这个session，如果也没有，说明session真的不存，如果cookie里面有，就把cookie里面的sessoin同步到服务器B，这样就可以实现session的同步了。</p><p><strong>说明：</strong></p><p>这种方法实现起来简单，方便，也不会加大数据库的负担，但是如果客户端把cookie禁掉了的话，那么session就无从同步了，这样会给网站带来损失；cookie的安全性不高，虽然它已经加了密，但是还是可以伪造的。</p><blockquote><p>在集群系统中不能用session，否则惹出祸端来就不好办。如果系统不复杂，就优先考虑能否将session去掉</p></blockquote><h3 id="session存在数据库中"><a href="#session存在数据库中" class="headerlink" title="session存在数据库中"></a>session存在数据库中</h3><p>可以配置将session保存在数据库中，这种方法是把存放session的表和其他数据库表放在一起，如果mysql也做了集群了话，每个mysql节点都要有这张表，并且这张session表的数据表要实时同步。</p><p><strong>说明：</strong></p><p>用数据库来同步session，会加大数据库的IO，增加数据库的负担。而且数据库读写速度较慢，不利于session的适时同步。</p><blockquote><p>适用于较为严格但请求量不高的场合</p></blockquote><h3 id="session存在memcache或者redis中"><a href="#session存在memcache或者redis中" class="headerlink" title="session存在memcache或者redis中"></a>session存在memcache或者redis中</h3><p>memcache可以做分布式，php配置文件中设置存储方式为memcache，这样php自己会建立一个session集群，将session数据存储在memcache中。</p><p><strong>说明：</strong></p><p>以这种方式来同步session，不会加大数据库的负担，并且安全性比用cookie大大的提高，把session放到内存里面，比从文件中读取要快很多。</p><p>但是memcache把内存分成很多种规格的存储块，有块就有大小，这种方式也就决定了，memcache不能完全利用内存，会产生内存碎片，如果存储块不足，还会产生内存溢出。</p><h3 id="nginx中的ip-hash技术"><a href="#nginx中的ip-hash技术" class="headerlink" title="nginx中的ip_hash技术"></a>nginx中的ip_hash技术</h3><p>该技术能够将某个ip的请求定向到同一台后端，这样一来这个ip下的某个客户端和某个后端就能建立起稳固的session</p><p><strong>ip_hash是在upstream配置中定义</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">upstream nginx.example.com  </span><br><span class="line">    &#123;   </span><br><span class="line">             server 192.168.74.235:80;   </span><br><span class="line">             server 192.168.74.236:80;  </span><br><span class="line">             ip_hash;  </span><br><span class="line">    &#125;  </span><br><span class="line">    server  </span><br><span class="line">    &#123;  </span><br><span class="line">             listen 80;  </span><br><span class="line">             location &#x2F;  </span><br><span class="line">             &#123;  </span><br><span class="line">                    proxy_pass   http:&#x2F;&#x2F;nginx.example.com;  </span><br><span class="line">             &#125;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></div><p>因为仅能用ip这个因子来分配后端，因此ip_hash不能在下列情况下使用：</p><ul><li><p><strong>nginx不是最前端的服务器。</strong></p><blockquote><p>ip_hash要求nginx一定是最前端的服务器，否则nginx得不到正确ip，就不能根据ip作hash<br>譬如使用的是squid为最前端，那么nginx取ip时只能得到squid的服务器ip地址，用这个地址来作分流是肯定错乱的。</p></blockquote></li><li><p><strong>nginx的后端还有其它方式的负载均衡</strong></p><blockquote><p>如果nginx后端又有其它负载均衡，将请求又通过另外的方式分流了，那么某个客户端的请求肯定不能定位到同一台session应用服务器上。<br>nginx后端只能直接指向应用服务器，或者再搭一个squid，然后指向应用服务器。</p></blockquote></li></ul><p><em>最好的办法是用 location作一次分流，将需要session的部分请求通过ip_hash分流，剩下的走其它后端去。</em></p><h3 id="upstream-hash"><a href="#upstream-hash" class="headerlink" title="upstream_hash"></a>upstream_hash</h3><p>使用upstream_hash这个第三方模块，这个模块多数情况下是用作url_hash的，可以它用来做session共享</p>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>详解三种集群策略（三）</title>
      <link href="/2020/01/04/Redis%E7%9A%84%E4%B8%89%E7%A7%8D%E9%9B%86%E7%BE%A4%E7%AD%96%E7%95%A5%EF%BC%88%E4%B8%89%EF%BC%89/"/>
      <url>/2020/01/04/Redis%E7%9A%84%E4%B8%89%E7%A7%8D%E9%9B%86%E7%BE%A4%E7%AD%96%E7%95%A5%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>redis包含三种集群策略</strong></p><blockquote><ol><li>主从复制</li><li>哨兵</li><li>集群</li></ol></blockquote><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><p>在主从复制中，数据库分为俩类，主数据库(master)和从数据库(slave)。其中主从复制有如下特点：</p><ul><li>主数据库可以进行读写操作，当读写操作导致数据变化时会自动将数据同步给从数据库</li><li>从数据库一般都是只读的，并且接收主数据库同步过来的数据</li><li>一个master可以拥有多个slave，但是一个slave只能对应一个master</li></ul><h3 id="主从复制工作机制"><a href="#主从复制工作机制" class="headerlink" title="主从复制工作机制"></a>主从复制工作机制</h3><p>当slave启动后，主动向master发送SYNC命令。master接收到SYNC命令后在后台保存快照（RDB持久化）和缓存保存快照这段时间的命令，然后将保存的快照文件和缓存的命令发送给slave。slave接收到快照文件和命令后加载快照文件和缓存的执行命令。</p><p>复制初始化后，master每次接收到的写命令都会同步发送给slave，保证主从数据一致性。</p><h3 id="主从配置"><a href="#主从配置" class="headerlink" title="主从配置"></a>主从配置</h3><p>redis默认是主数据，所以master无需配置，我们只需要修改slave的配置即可。</p><p><strong>设置需要连接的master的ip端口:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slaveof 192.168.0.107 6379</span><br></pre></td></tr></table></figure></div><p><strong>如果master设置了密码。需要配置：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">masterauth</span><br></pre></td></tr></table></figure></div><p><strong>连接成功进入命令行后，可以通过以下命令行查看连接该数据库的其他库信息:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info replication</span><br></pre></td></tr></table></figure></div><h2 id="哨兵"><a href="#哨兵" class="headerlink" title="哨兵"></a>哨兵</h2><p>哨兵的作用是监控 redis系统的运行状况，他的功能如下：</p><ul><li>监控主从数据库是否正常运行</li><li>master出现故障时，自动将slave转化为master</li><li>多哨兵配置的时候，哨兵之间也会自动监控</li><li>多个哨兵可以监控同一个redis</li></ul><h3 id="哨兵工作机制"><a href="#哨兵工作机制" class="headerlink" title="哨兵工作机制"></a>哨兵工作机制</h3><p>哨兵进程启动时会读取配置文件的内容，通过<strong>sentinel monitor master-name ip port quorum</strong>查找到master的ip端口。一个哨兵可以监控多个master数据库，只需要提供多个该配置项即可。</p><p>同时配置文件还定义了与监控相关的参数，比如master多长时间无响应即即判定位为下线。</p><p>哨兵启动后，会与要监控的master建立俩条连接：</p><ol><li>一条连接用来订阅master的<em>sentinel</em>:hello频道与获取其他监控该master的哨兵节点信息</li><li>另一条连接定期向master发送INFO等命令获取master本身的信息</li></ol><p>与master建立连接后，哨兵会执行三个操作，这三个操作的发送频率都可以在配置文件中配置：</p><ol><li>定期向master和slave发送INFO命令</li><li>定期向master个slave的<em>sentinel</em>:hello频道发送自己的信息</li><li>定期向master、slave和其他哨兵发送PING命令</li></ol><p>这三个操作的意义非常重大，发送INFO命令可以获取当前数据库的相关信息从而实现新节点的自动发现。所以说哨兵只需要配置master数据库信息就可以自动发现其slave信息。获取到slave信息后，哨兵也会与slave建立俩条连接执行监控。通过INFO命令，哨兵可以获取主从数据库的最新信息，并进行相应的操作，比如角色变更等。</p><p>接下来哨兵向主从数据库的<em>sentinel</em>:hello频道发送信息与同样监控这些数据库的哨兵共享自己的信息，发送内容为哨兵的ip端口、运行id、配置版本、master名字、master的ip端口还有master的配置版本。这些信息有以下用处：</p><ul><li>其他哨兵可以通过该信息判断发送者是否是新发现的哨兵，如果是的话会创建一个到该哨兵的连接用于发送PIN命令。</li><li>其他哨兵通过该信息可以判断master的版本，如果该版本高于直接记录的版本，将会更新</li></ul><p>当实现了自动发现slave和其他哨兵节点后，哨兵就可以通过定期发送PING命令定时监控这些数据库和节点有没有停止服务。发送频率可以配置，但是最长间隔时间为1s，可以通过<strong>sentinel down-after-milliseconds mymaster 600</strong> 设置。</p><p>如果被ping的数据库或者节点超时未回复，哨兵任务其主观下线。如果下线的是master，哨兵会向其他哨兵点发送命令询问他们是否也认为该master主观下线，如果达到一定数目（即配置文件中的<strong>quorum</strong>）投票，哨兵会认为该master已经客观下线，并选举领头的哨兵节点对主从系统发起故障恢复。</p><p>如上文所说，哨兵认为master客观下线后，故障恢复的操作需要由选举的领头哨兵执行，选举采用Raft算法：</p><ol><li>发现master下线的哨兵节点（我们称他为A）向每个哨兵发送命令，要求对方选自己为领头哨兵</li><li>如果目标哨兵节点没有选过其他人，则会同意选举A为领头哨兵</li><li>如果有超过一半的哨兵同意选举A为领头，则A当选</li><li>如果有多个哨兵节点同时参选领头，此时有可能存在一轮投票无竞选者胜出，此时每个参选的节点等待一个随机时间后再次发起参选请求，进行下一轮投票精选，直至选举出领头哨兵</li></ol><p>选出领头哨兵后，领头者开始对进行故障恢复，从出现故障的master的从数据库中挑选一个来当选新的master,选择规则如下：</p><ol><li>所有在线的slave中选择优先级最高的，优先级可以通过<strong>slave-priority</strong>配置</li><li>如果有多个最高优先级的slave，则选取复制偏移量最大（即复制越完整）的当选</li><li>如果以上条件都一样，选取id最小的slave</li></ol><p>挑选出需要继任的slaver后，领头哨兵向该数据库发送命令使其升格为master，然后再向其他slave发送命令接受新的master，最后更新数据。将已经停止的旧的master更新为新的master的从数据库，使其恢复服务后以slave的身份继续运行。</p><h3 id="哨兵配置"><a href="#哨兵配置" class="headerlink" title="哨兵配置"></a>哨兵配置</h3><p>哨兵配置的配置文件为<strong>sentinel.conf</strong>，设置主机名称，地址，端口，以及选举票数即恢复时最少需要几个哨兵节点同意。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sentinel monitor mymaster 192.168.0.107 6379 1</span><br></pre></td></tr></table></figure></div><p>只要配置需要监控的master就可以了，哨兵会监控连接该master的slave。</p><p>启动哨兵节点：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server sentinel.conf --sentinel &amp;</span><br></pre></td></tr></table></figure></div><p>出现如下内容表示启动成功</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[root@buke110 redis]# bin&#x2F;redis-server etc&#x2F;sentinel.conf --sentinel &amp;</span><br><span class="line">[1] 3072</span><br><span class="line">[root@buke110 redis]# 3072:X 12 Apr 22:40:02.503 * Increased maximum number of open files to 10032 (it was originally set to 1024).</span><br><span class="line">                _._                                                  </span><br><span class="line">           _.-&#96;&#96;__ &#39;&#39;-._                                             </span><br><span class="line">      _.-&#96;&#96;    &#96;.  &#96;_.  &#39;&#39;-._           Redis 2.9.102 (00000000&#x2F;0) 64 bit</span><br><span class="line">  .-&#96;&#96; .-&#96;&#96;&#96;.  &#96;&#96;&#96;\&#x2F;    _.,_ &#39;&#39;-._                                   </span><br><span class="line"> (    &#39;      ,       .-&#96;  | &#96;,    )     Running in sentinel mode</span><br><span class="line"> |&#96;-._&#96;-...-&#96; __...-.&#96;&#96;-._|&#39;&#96; _.-&#39;|     Port: 26379</span><br><span class="line"> |    &#96;-._   &#96;._    &#x2F;     _.-&#39;    |     PID: 3072</span><br><span class="line">  &#96;-._    &#96;-._  &#96;-.&#x2F;  _.-&#39;    _.-&#39;                                   </span><br><span class="line"> |&#96;-._&#96;-._    &#96;-.__.-&#39;    _.-&#39;_.-&#39;|                                  </span><br><span class="line"> |    &#96;-._&#96;-._        _.-&#39;_.-&#39;    |           http:&#x2F;&#x2F;redis.io        </span><br><span class="line">  &#96;-._    &#96;-._&#96;-.__.-&#39;_.-&#39;    _.-&#39;                                   </span><br><span class="line"> |&#96;-._&#96;-._    &#96;-.__.-&#39;    _.-&#39;_.-&#39;|                                  </span><br><span class="line"> |    &#96;-._&#96;-._        _.-&#39;_.-&#39;    |                                  </span><br><span class="line">  &#96;-._    &#96;-._&#96;-.__.-&#39;_.-&#39;    _.-&#39;                                   </span><br><span class="line">      &#96;-._    &#96;-.__.-&#39;    _.-&#39;                                       </span><br><span class="line">          &#96;-._        _.-&#39;                                           </span><br><span class="line">              &#96;-.__.-&#39;                                               </span><br><span class="line"></span><br><span class="line">3072:X 12 Apr 22:40:02.554 # Sentinel runid is e510bd95d4deba3261de72272130322b2ba650e7</span><br><span class="line">3072:X 12 Apr 22:40:02.554 # +monitor master mymaster 192.168.0.107 6379 quorum 1</span><br><span class="line">3072:X 12 Apr 22:40:03.516 * +slave slave 192.168.0.108:6379 192.168.0.108 6379 @ mymaster 192.168.0.107 6379</span><br><span class="line">3072:X 12 Apr 22:40:03.516 * +slave slave 192.168.0.109:6379 192.168.0.109 6379 @ mymaster 192.168.0.107 6379</span><br></pre></td></tr></table></figure></div><p>可以在任何一台服务器上查看指定哨兵节点信息：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin&#x2F;redis-cli -h 192.168.0.110 -p 26379 info Sentinel</span><br></pre></td></tr></table></figure></div><p>控制台输出哨兵信息：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@buke107 redis]# bin&#x2F;redis-cli -h 192.168.0.110  -p 26379  info Sentinel</span><br><span class="line"># Sentinel</span><br><span class="line">sentinel_masters:1</span><br><span class="line">sentinel_tilt:0</span><br><span class="line">sentinel_running_scripts:0</span><br><span class="line">sentinel_scripts_queue_length:0</span><br><span class="line">master0:name&#x3D;mymaster,status&#x3D;ok,address&#x3D;192.168.0.107:6379,slaves&#x3D;2,sentinels&#x3D;1</span><br></pre></td></tr></table></figure></div><h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><p>使用集群，只需要将每个数据库节点的cluster-enable配置打开即可。每个集群中至少需要三个主数据库才能正常运行。</p><h3 id="集群配置"><a href="#集群配置" class="headerlink" title="集群配置"></a>集群配置</h3><p>安装依赖环境ruby，注意ruby版本必须高于2.2</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum install ruby</span><br><span class="line">yum install rubygems</span><br><span class="line">gem install redis</span><br></pre></td></tr></table></figure></div><p>修改配置文件:</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bind 192.168.0.107</span><br></pre></td></tr></table></figure></div><h3 id="配置端口"><a href="#配置端口" class="headerlink" title="配置端口"></a>配置端口</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">port 6380</span><br></pre></td></tr></table></figure></div><h3 id="配置快照保存路径"><a href="#配置快照保存路径" class="headerlink" title="配置快照保存路径"></a>配置快照保存路径</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dir &#x2F;usr&#x2F;local&#x2F;redis-cluster&#x2F;6380&#x2F;</span><br></pre></td></tr></table></figure></div><h3 id="开启集群"><a href="#开启集群" class="headerlink" title="开启集群"></a>开启集群</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cluster-enabled yes</span><br></pre></td></tr></table></figure></div><h3 id="为节点设置不同的工作目录"><a href="#为节点设置不同的工作目录" class="headerlink" title="为节点设置不同的工作目录"></a>为节点设置不同的工作目录</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cluster-config-file nodes-6380.conf</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 集群失效时间</span><br><span class="line">cluster-node-timeout 15000</span><br></pre></td></tr></table></figure></div><h3 id="开启集群中的节点"><a href="#开启集群中的节点" class="headerlink" title="开启集群中的节点:"></a>开启集群中的节点:</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reids-service …&#x2F;6380&#x2F;redis.conf</span><br></pre></td></tr></table></figure></div><h3 id="将节点加入集群中"><a href="#将节点加入集群中" class="headerlink" title="将节点加入集群中"></a>将节点加入集群中</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-trib.rb create --replicas 1 192.168.0.107:6380 192.168.0.107:6381 192.168.0.107:6382 192.168.0.107:6383 192.168.0.107:6384 192.168.0.107:6385</span><br></pre></td></tr></table></figure></div><p>中途需要输入yes确定创建集群:</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">[root@buke107 src]# redis-trib.rb create --replicas 1 192.168.0.107:6380 192.168.0.107:6381 192.168.0.107:6382 192.168.0.107:6383 192.168.0.107:6384 192.168.0.107:6385 </span><br><span class="line">&gt;&gt;&gt; Creating cluster</span><br><span class="line">Connecting to node 192.168.0.107:6380: OK</span><br><span class="line">Connecting to node 192.168.0.107:6381: OK</span><br><span class="line">Connecting to node 192.168.0.107:6382: OK</span><br><span class="line">Connecting to node 192.168.0.107:6383: OK</span><br><span class="line">Connecting to node 192.168.0.107:6384: OK</span><br><span class="line">Connecting to node 192.168.0.107:6385: OK</span><br><span class="line">&gt;&gt;&gt; Performing hash slots allocation on 6 nodes...</span><br><span class="line">Using 3 masters:</span><br><span class="line">192.168.0.107:6380</span><br><span class="line">192.168.0.107:6381</span><br><span class="line">192.168.0.107:6382</span><br><span class="line">Adding replica 192.168.0.107:6383 to 192.168.0.107:6380</span><br><span class="line">Adding replica 192.168.0.107:6384 to 192.168.0.107:6381</span><br><span class="line">Adding replica 192.168.0.107:6385 to 192.168.0.107:6382</span><br><span class="line">M: 5cd3ed3a84ead41a765abd3781b98950d452c958 192.168.0.107:6380</span><br><span class="line">   slots:0-5460 (5461 slots) master</span><br><span class="line">M: 90b4b326d579f9b5e181e3df95578bceba29b204 192.168.0.107:6381</span><br><span class="line">   slots:5461-10922 (5462 slots) master</span><br><span class="line">M: 868456121fa4e6c8e7abe235a88b51d354a944b5 192.168.0.107:6382</span><br><span class="line">   slots:10923-16383 (5461 slots) master</span><br><span class="line">S: b8e047aeacb9398c3f58f96d0602efbbea2078e2 192.168.0.107:6383</span><br><span class="line">   replicates 5cd3ed3a84ead41a765abd3781b98950d452c958</span><br><span class="line">S: 68cf66359318b26df16ebf95ba0c00d9f6b2c63e 192.168.0.107:6384</span><br><span class="line">   replicates 90b4b326d579f9b5e181e3df95578bceba29b204</span><br><span class="line">S: d6d01fd8f1e5b9f8fc0c748e08248a358da3638d 192.168.0.107:6385</span><br><span class="line">   replicates 868456121fa4e6c8e7abe235a88b51d354a944b5</span><br><span class="line">Can I set the above configuration? (type &#39;yes&#39; to accept): yes</span><br><span class="line">&gt;&gt;&gt; Nodes configuration updated</span><br><span class="line">&gt;&gt;&gt; Assign a different config epoch to each node</span><br><span class="line">&gt;&gt;&gt; Sending CLUSTER MEET messages to join the cluster</span><br><span class="line">Waiting for the cluster to join....</span><br><span class="line">&gt;&gt;&gt; Performing Cluster Check (using node 192.168.0.107:6380)</span><br><span class="line">M: 5cd3ed3a84ead41a765abd3781b98950d452c958 192.168.0.107:6380</span><br><span class="line">   slots:0-5460 (5461 slots) master</span><br><span class="line">M: 90b4b326d579f9b5e181e3df95578bceba29b204 192.168.0.107:6381</span><br><span class="line">   slots:5461-10922 (5462 slots) master</span><br><span class="line">M: 868456121fa4e6c8e7abe235a88b51d354a944b5 192.168.0.107:6382</span><br><span class="line">   slots:10923-16383 (5461 slots) master</span><br><span class="line">M: b8e047aeacb9398c3f58f96d0602efbbea2078e2 192.168.0.107:6383</span><br><span class="line">   slots: (0 slots) master</span><br><span class="line">   replicates 5cd3ed3a84ead41a765abd3781b98950d452c958</span><br><span class="line">M: 68cf66359318b26df16ebf95ba0c00d9f6b2c63e 192.168.0.107:6384</span><br><span class="line">   slots: (0 slots) master</span><br><span class="line">   replicates 90b4b326d579f9b5e181e3df95578bceba29b204</span><br><span class="line">M: d6d01fd8f1e5b9f8fc0c748e08248a358da3638d 192.168.0.107:6385</span><br><span class="line">   slots: (0 slots) master</span><br><span class="line">   replicates 868456121fa4e6c8e7abe235a88b51d354a944b5</span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br><span class="line">&gt;&gt;&gt; Check for open slots...</span><br><span class="line">&gt;&gt;&gt; Check slots coverage...</span><br><span class="line">[OK] All 16384 slots covered.</span><br></pre></td></tr></table></figure></div><p>进入任何一个集群中的节点:</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -c -h 192.168.0.107 -p 6381</span><br></pre></td></tr></table></figure></div><p>查看集群中的节点:</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@buke107 src]# redis-cli -c -h 192.168.0.107 -p 6381</span><br><span class="line">192.168.0.107:6381&gt; cluster nodes</span><br><span class="line">868456121fa4e6c8e7abe235a88b51d354a944b5 192.168.0.107:6382 master - 0 1523609792598 3 connected 10923-16383</span><br><span class="line">d6d01fd8f1e5b9f8fc0c748e08248a358da3638d 192.168.0.107:6385 slave 868456121fa4e6c8e7abe235a88b51d354a944b5 0 1523609795616 6 connected</span><br><span class="line">5cd3ed3a84ead41a765abd3781b98950d452c958 192.168.0.107:6380 master - 0 1523609794610 1 connected 0-5460</span><br><span class="line">b8e047aeacb9398c3f58f96d0602efbbea2078e2 192.168.0.107:6383 slave 5cd3ed3a84ead41a765abd3781b98950d452c958 0 1523609797629 1 connected</span><br><span class="line">68cf66359318b26df16ebf95ba0c00d9f6b2c63e 192.168.0.107:6384 slave 90b4b326d579f9b5e181e3df95578bceba29b204 0 1523609796622 5 connected</span><br><span class="line">90b4b326d579f9b5e181e3df95578bceba29b204 192.168.0.107:6381 myself,master - 0 0 2 connected 5461-10922</span><br></pre></td></tr></table></figure></div><p>如上图所示，已经建立起三主三从的集群。</p><h3 id="增加集群节点"><a href="#增加集群节点" class="headerlink" title="增加集群节点"></a>增加集群节点</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cluster meet ip port</span><br></pre></td></tr></table></figure></div><blockquote><p>出处地址：<a href="https://blog.csdn.net/q649381130/article/details/79931791" target="_blank" rel="noopener">https://blog.csdn.net/q649381130/article/details/79931791</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis的基本配置（二）</title>
      <link href="/2020/01/04/Redis%E7%9A%84%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2020/01/04/Redis%E7%9A%84%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>redis是用c编写的开源内存型键值数据库，其会周期性将内存中数据同步到硬盘达到持久化目的。memcachedb也是开源内存型键值数据库，速度比redis快，但不支持硬盘存储，且数据类型没有redis丰富。内存型数据库可用于缓存、消息队列等非持久性短暂存储数据或实时性为主，频繁插入删除操作的应用。redis自带的一个简易命令接口redis-cli，可使用开源可视化的redis客户端工具RDM。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 启动指定配置文件的redis服务</span><br><span class="line">src&#x2F;redis-server ..&#x2F;redis_6379.conf</span><br><span class="line">&#x2F;&#x2F; 开启客户端连接redis服务</span><br><span class="line">src&#x2F;redis-cli</span><br><span class="line">&#x2F;&#x2F; 客户端关闭redis服务实例</span><br><span class="line">shutdown</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使redis服务实例随着linux的启动而开机自启</span><br><span class="line">vi &#x2F;etc&#x2F;rc.local</span><br><span class="line">添加&#x2F;export&#x2F;servers&#x2F;redis-3.2.3&#x2F;src&#x2F;redis-server ..&#x2F;redis_port.conf</span><br></pre></td></tr></table></figure></div><p>redis服务启动时默认会加载安装根目录下的redis.conf文件来完成redis服务实例的相关配置，通常一个reids服务实例对应一个配置文件，若要在同一台服务器上启动多个redis服务实例，就必须在安装根目录下创建多个配置文件。由于每个redis服务实例都必须对应唯一的端口号，通常将对应的配置文件命名为redis_port.conf。</p><ul><li><strong>daemonize：</strong>配置服务是否为后台运行，默认no非后台运行，如需后台运行改为yes。</li><li><strong>pidfile：</strong>配置pid文件地址，默认/var/run/redis_6379.pid，其存储了当前服务的进程号，同一服务器上多个服务必须创建对应的多个pid文件，文件名以端口号区分。</li><li><strong>port：</strong>配置服务的端口号，默认6379，同一服务器上启动多个服务必须在对应配置文件内指定不同端口号。</li><li><strong>bind：</strong>配置服务只接受来自指定ip的请求，默认127.0.0.1只接收本机请求。</li><li><strong>timeout：</strong>配置客户端连接超时时间，单位秒，若客户端在规定时间内没发请求会关闭该连接，默认0无限制。</li><li><strong>loglevel：</strong>配置数据库日志级别，共四个级别，默认notice正常记录，debug记录全部信息，varbose仅记录有用信息，waring记录非常重要的信息。</li><li><strong>logfile：</strong>配置数据库日志文件地址，stdout标准输出到终端显示，后台模式输出到/dev/null，null是一串口设备的文件，/export/Logs/redis/redis_6379.log输出到文件，前提必须先建立此目录及文件。</li><li><strong>databases：</strong>配置可用数据库个数，默认16。redis没有表概念，其数据库用一个从0开始的整数索引来标识，使用select dbid来指定数据库，默认0数据库，不同数据库内key可重复。flushdb清除当前数据库内容，flushall清除当前服务所有数据库内容，dbsize返回当前数据库内k个数。</li><li><strong>save：</strong>配置内存数据与硬盘数据库同步频率，如save 900 1，表示900秒内有一个及以上的key发生变化，就将内存数据同步到硬盘。redis有rdb和aof两种实现内存数据持久化的方式，其中rdb速度快，但会缺失数据；aof速度慢，但会完全恢复。</li><li><strong>rdbcompression：</strong>配置内存数据同步到rdb时是否压缩数据，默认yes。</li><li><strong>dbfilename：</strong>配置rdb数据库文件名，默认为dump.rdb，仅指出文件名。</li><li><strong>dir：</strong>配置rdb数据库文件存放目录，默认redis安装根目录。只能指定目录，不能指定rdb文件名。</li><li><strong>slaveof：</strong>配置当前服务的主redis服务，redis的多个服务可实现主从同步，若当前服务为从库，要在此指定主库的ip和端口，如slaveof ip port，当从库开启时，会自动从主库同步数据。</li><li><strong>masterauth：</strong>配置从库访问主库的密码，若当前服务为从库，且要同步的主库设置了密码，要在此指定连接到主库的密码。</li><li><strong>appendonly：</strong>配置是否开启aof持久化功能，默认no，若开启会创建xxx.aof文件，其会记录服务的每一次写操作。</li><li><strong>appendfilename：</strong>配置aof文件的名称，默认为appendonly.aof。</li><li><strong>appendfsync：</strong>配置服务对aof文件的同步频率，always表示一有写操作就同步，everysec表示每秒进行一次同步。</li><li><strong>requirepass：</strong>配置客户端连接到服务的密码，默认注释掉不设置密码，此时redis进入保护模式，除了本地客户端外，远程客户端均无法连接服务。在此设置密码后可实现远程连接，但远程登录后必须执行auth password命令输入密码才可操作。</li><li><strong>maxclients：</strong>配置服务的最大客户端连接数，默认注释掉，不加限制。</li><li><strong>maxmemory：</strong>配置服务的最大内存，默认注释掉，不加限制。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis的介绍和安装（一）</title>
      <link href="/2020/01/04/Redis%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%92%8C%E5%AE%89%E8%A3%85%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2020/01/04/Redis%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%92%8C%E5%AE%89%E8%A3%85%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-Redis简介"><a href="#1-Redis简介" class="headerlink" title="1.Redis简介"></a><strong>1.Redis简介</strong></h2><p><a href="http://code.google.com/p/redis/" target="_blank" rel="noopener">Redis</a>是一个key-value存储系统。和Memcached类似，但是解决了断电后数据完全丢失的情况，而且她支持更多无化的value类型，除了和string外，还支持lists（链表）、sets（集合）和zsets（有序集合）几种数据类型。这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。</p><h2 id="2-Redis的性能"><a href="#2-Redis的性能" class="headerlink" title="2.Redis的性能"></a><strong>2.Redis的性能</strong></h2><p>下面是官方的bench-mark数据：</p><p>The test was done with 50 simultaneous clients performing 100000 requests.</p><p>The value SET and GET is a 256 bytes string.</p><p>The Linux box is running <strong>Linux 2.6</strong>, it’s <strong>Xeon X3320 2.5Ghz</strong>.</p><p>Text executed using the loopback interface (127.0.0.1).</p><p>Results: <strong>about 110000 SETs per second, about 81000 GETs per second.</strong></p><p>更多详细数据请见官方bench-mark page（<a href="http://code.google.com/p/redis/wiki/Benchmarks" target="_blank" rel="noopener">http://code.google.com/p/redis/wiki/Benchmarks</a>）</p><h2 id="3-安装Redis"><a href="#3-安装Redis" class="headerlink" title="3.安装Redis"></a><strong>3.安装Redis</strong></h2><p>Redis的代码遵循ANSI-C编写，可以在所有POSIX系统（如Linux, *BSD, Mac OS X, Solaris等）上安装运行。而且Redis并不依赖任何非标准库，也没有编译参数必需添加。redis的安装出奇的简单，这可能也是他风靡的一个原因，让人很容易上手，不像某些东西，编译阶段就能让人完全绝望。</p><p>先去官网下载源码：</p><p>wget <a href="http://redis.googlecode.com/files/redis-2.4.6.tar.gz" target="_blank" rel="noopener">http://redis.googlecode.com/files/redis-2.4.6.tar.gz</a></p><p>解压：</p><p>tar –zxvf redis-2.4.6.tar.gz</p><p>编译</p><p>需要说明的事，redis的安装非常简单，已经有现成的Makefile文件，直接运行make命令即可。</p><p>make</p><p>make install</p><p>Redis 由四个可执行文件：<strong>redis-benchmark</strong>、<strong>redis-cli</strong>、<strong>redis-server</strong>、<strong>redis-stat</strong> 这四个文件，加上一个<strong>redis.conf</strong>就构成了整个redis的最终可用包。它们的作用如下：</p><p>redis-server：Redis服务器的daemon启动程序</p><p>redis-cli：Redis命令行操作工具。当然，你也可以用telnet根据其纯文本协议来操作</p><p>redis-benchmark：Redis性能测试工具，测试Redis在你的系统及你的配置下的读写性能</p><p>redis-stat：Redis状态检测工具，可以检测Redis当前状态参数及延迟状况</p><p>现在就可以启动redis了，redis只有一个启动参数，就是他的配置文件路径。</p><p>redis-server /etc/redis.conf</p><p>注意，默认复制过去的<strong>redis.conf</strong>文件的<strong>daemonize</strong>参数为<strong>no</strong>，所以redis不会在后台运行，这时要测试，我们需要重新开一个终端。修改为<strong>yes</strong>则为后台运行redis。另外配置文件中规定了pid文件，log文件和数据文件的地址，如果有需要先修改，默认log信息定向到stdout.</p><p>下面是redis.conf的主要配置参数的意义：</p><p>daemonize：是否以后台daemon方式运行</p><p>pidfile：pid文件位置</p><p>port：监听的端口号</p><p>timeout：请求超时时间</p><p>loglevel：log信息级别</p><p>logfile：log文件位置</p><p>databases：开启数据库的数量</p><p>save * <em>：保存快照的频率，第一个</em>表示多长时间，第三个*表示执行多少次写操作。在一定时间内执行一定数量的写操作时，自动保存快照。可设置多个条件。</p><p>rdbcompression：是否使用压缩</p><p>dbfilename：数据快照文件名（只是文件名，不包括目录）</p><p>dir：数据快照的保存目录（这个是目录）</p><p>appendonly：是否开启appendonlylog，开启的话每次写操作会记一条log，这会提高数据抗风险能力，但影响效率。</p><p>appendfsync：appendonlylog如何同步到磁盘（三个选项，分别是每次写都强制调用fsync、每秒启用一次fsync、不调用fsync等待系统自己同步）</p><p>这时你可以打开一个终端进行测试了，配置文件中默认的监听端口是<strong>6379</strong></p><p>我们可以开启一个Redis客户端进行测试</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">\[root@SNDA-192-168-1-114 ~\]# redis-cli   </span><br><span class="line">Could not connect to Redis at 127.0.0.1:6379: Connection refused   </span><br><span class="line">not connected&gt; exit   </span><br><span class="line">\[root@SNDA-192-168-1-114 ~\]# redis-server &#x2F;etc&#x2F;redis.conf   </span><br><span class="line">\[root@SNDA-192-168-1-114 ~\]# redis-cli   </span><br><span class="line">redis 127.0.0.1:6379&gt; quit</span><br></pre></td></tr></table></figure></div><h2 id="4-redis数据结构"><a href="#4-redis数据结构" class="headerlink" title="4.redis数据结构"></a><strong>4.redis数据结构</strong></h2><p>redis 的作者antirez曾称其为一个数据结构服务器（<strong>data structures server</strong>），这是一个非常准确的表述，redis的所有功能就是将数据以其固有的几种结构保存，并提供给用户操作这几种结构的接口。我们可以想象我们在各种语言中的那些固有数据类型及其操作。</p><p>redis目前提供四种数据类型：<strong>string</strong>,<strong>list</strong>,<strong>set</strong>及<strong>zset</strong>(sorted set)和<strong>Hash</strong>。</p><p><strong>string</strong>是最简单的类型，你可以理解成与Memcached一模一个的类型，一个key对应一个value，其上支持的操作与Memcached的操作类似。但它的功能更丰富。</p><p><strong>list</strong>是一个链表结构，主要功能是push、pop、获取一个范围的所有值等等。操作中key理解为链表的名字。</p><p><strong>set</strong>是集合，和我们数学中的集合概念相似，对集合的操作有添加删除元素，有对多个集合求交并差等操作。操作中key理解为集合的名字。</p><p><strong>zset</strong>是set的一个升级版本，他在set的基础上增加了一个顺序属性，这一属性在添加修改元素的时候可以指定，每次指定后，zset会自动重新按新的值调整顺序。可以理解了有两列的mysql表，一列存value，一列存顺序。操作中key理解为zset的名字。</p><p><strong>Hash</strong>数据类型允许用户用Redis存储对象类型,Hash数据类型的一个重要优点是,当你存储的数据对象只有很少几个key值时,数据存储的内存消耗会很小.更多关于Hash数据类型的说明请见: <a href="http://code.google.com/p/redis/wiki/Hashes" target="_blank" rel="noopener">http://code.google.com/p/redis/wiki/Hashes</a></p><p>在官网上给出了所有支持的接口列表，并副副附有详细的介绍，地址：</p><p><a href="http://code.google.com/p/redis/wiki/CommandReference" target="_blank" rel="noopener">http://code.google.com/p/redis/wiki/CommandReference</a></p><p>另外，作者还提供了一个非常贴心的web命令行模拟页面，供初学者试用redis，地址：</p><p><a href="http://try.redis-db.com/" target="_blank" rel="noopener">http://try.redis-db.com/</a></p><h2 id="5-redis数据存储"><a href="#5-redis数据存储" class="headerlink" title="5.redis数据存储"></a><strong>5.redis数据存储</strong></h2><p>redis的存储分为内存存储、磁盘存储和log文件三部分，配置文件中有三个参数对其进行配置。</p><p><strong>save seconds updates</strong>，<strong>save</strong>配置，指出在多长时间内，有多少次更新操作，就将数据同步到数据文件。这个可以多个条件配合，比如默认配置文件中的设置，就设置了三个条件。</p><p><strong>appendonly yes</strong>/<strong>no</strong> ，<strong>appendonly</strong>配置，指出是否在每次更新操作后进行日志记录，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为redis本身同步数据文件是按上面的save条件来同步的，所以有的数据会在一段时间内只存在于内存中。</p><p><strong>appendfsync no</strong>/<strong>always</strong>/<strong>everysec</strong> ，<strong>appendfsync</strong>配置，<strong>no</strong>表示等操作系统进行数据缓存同步到磁盘，<strong>always</strong>表示每次更新操作后手动调用<strong>fsync</strong>()将数据写到磁盘，<strong>everysec</strong>表示每秒同步一次。</p><h2 id="6-redis主从配置"><a href="#6-redis主从配置" class="headerlink" title="6.redis主从配置"></a><strong>6.redis主从配置</strong></h2><p>redis支持<strong>master-slave</strong>的主从配置，配置方法是在从机的配置文件中指定<strong>slaveof</strong>参数为主机的ip和port即可</p><h2 id="7-redis起步-链接整理"><a href="#7-redis起步-链接整理" class="headerlink" title="7.redis起步(链接整理)"></a><strong>7.redis起步(链接整理)</strong></h2><p>项目首页，下方是各种语言支持列表：</p><p><a href="http://code.google.com/p/redis/" target="_blank" rel="noopener">http://code.google.com/p/redis/</a></p><p>作者在wiki中给出了一个非常好的例子，以使我们可以快速上手，地址：</p><p><a href="http://code.google.com/p/redis/wiki/TwitterAlikeExample" target="_blank" rel="noopener">http://code.google.com/p/redis/wiki/TwitterAlikeExample</a></p><p>同时作者推荐的另一个教程，地址：</p><p><a href="http://labs.alcacoop.it/doku.php?id=articles:redis_land" target="_blank" rel="noopener">http://labs.alcacoop.it/doku.php?id=articles:redis_land</a></p><p>一个redis爱好者创建的相关问题讨论网站：</p><p><a href="http://www.rediscookbook.org/" target="_blank" rel="noopener">http://www.rediscookbook.org/</a></p><p>为什么使用 Redis及其产品定位</p><p><a href="http://www.infoq.com/cn/articles/tq-why-choose-redis" target="_blank" rel="noopener">http://www.infoq.com/cn/articles/tq-why-choose-redis</a></p><p>Redis内存使用优化与存储</p><p><a href="http://www.infoq.com/cn/articles/tq-redis-memory-usage-optimization-storage" target="_blank" rel="noopener">http://www.infoq.com/cn/articles/tq-redis-memory-usage-optimization-storage</a></p><p>前几天微博发生了一起大的系统故障，很多技术的朋友都比较关心，其中的原因不会超出James Hamilton在On Designing and Deploying Internet-Scale Service(1)概括的那几个范围，James第一条经验“Design for failure”是所有互联网架构成功的一个关键。互联网系统的工程理论其实非常简单，James paper中内容几乎称不上理论，而是多条实践经验分享，每个公司对这些经验的理解及执行力决定了架构成败。</p><p>题外话说完，最近又研究了Redis。去年曾做过一个MemcacheDB, Tokyo Tyrant, Redis performance test，到目前为止，这个benchmark结果依然有效。这1年我们经历了很多眼花缭乱的key value存储产品的诱惑，从Cassandra的淡出(Twitter暂停在主业务使用)到HBase的兴起(Facebook新的邮箱业务选用HBase(2))，当再回头再去看Redis，发现这个只有1万多行源代码的程序充满了神奇及大量未经挖掘的特性。Redis性能惊人，国内前十大网站的子产品估计用1台Redis就可以满足存储及Cache的需求。除了性能印象之外，业界其实普遍对Redis的认识存在一定误区。本文提出一些观点供大家探讨。</p><h3 id="Redis是什么"><a href="#Redis是什么" class="headerlink" title="Redis是什么"></a>Redis是什么</h3><p>这个问题的结果影响了我们怎么用Redis。如果你认为Redis是一个key value store, 那可能会用它来代替MySQL；如果认为它是一个可以持久化的cache, 可能只是它保存一些频繁访问的临时数据。Redis是REmote DIctionary Server的缩写，在Redis在官方网站的的副标题是A persistent key-value database with built-in net interface written in ANSI-C for Posix systems，这个定义偏向key value store。还有一些看法则认为Redis是一个memory database，因为它的高性能都是基于内存操作的基础。另外一些人则认为Redis是一个data structure server，因为Redis支持复杂的数据特性，比如List, Set等。对Redis的作用的不同解读决定了你对Redis的使用方式。</p><p>互联网数据目前基本使用两种方式来存储，关系数据库或者key value。但是这些互联网业务本身并不属于这两种数据类型，比如用户在社会化平台中的关系，它是一个list，如果要用关系数据库存储就需要转换成一种多行记录的形式，这种形式存在很多冗余数据，每一行需要存储一些重复信息。如果用key value存储则修改和删除比较麻烦，需要将全部数据读出再写入。Redis在内存中设计了各种数据类型，让业务能够高速原子的访问这些数据结构，并且不需要关心持久存储的问题，从架构上解决了前面两种存储需要走一些弯路的问题。</p><h3 id="Redis不可能比Memcache快"><a href="#Redis不可能比Memcache快" class="headerlink" title="Redis不可能比Memcache快"></a>Redis不可能比Memcache快</h3><p>很多开发者都认为Redis不可能比Memcached快，Memcached完全基于内存，而Redis具有持久化保存特性，即使是异步的，Redis也不可能比Memcached快。但是测试结果基本是Redis占绝对优势。一直在思考这个原因，目前想到的原因有这几方面。</p><p>Libevent。和Memcached不同，Redis并没有选择libevent。Libevent为了迎合通用性造成代码庞大(目前Redis代码还不到libevent的1/3)及牺牲了在特定平台的不少性能。Redis用libevent中两个文件修改实现了自己的epoll event loop(4)。业界不少开发者也建议Redis使用另外一个libevent高性能替代libev，但是作者还是坚持Redis应该小巧并去依赖的思路。一个印象深刻的细节是编译Redis之前并不需要执行./configure。</p><p>CAS问题。CAS是Memcached中比较方便的一种防止竞争修改资源的方法。CAS实现需要为每个cache key设置一个隐藏的cas token，cas相当value版本号，每次set会token需要递增，因此带来CPU和内存的双重开销，虽然这些开销很小，但是到单机10G+ cache以及QPS上万之后这些开销就会给双方相对带来一些细微性能差别(5)。</p><h3 id="单台Redis的存放数据必须比物理内存小"><a href="#单台Redis的存放数据必须比物理内存小" class="headerlink" title="单台Redis的存放数据必须比物理内存小"></a>单台Redis的存放数据必须比物理内存小</h3><p>Redis的数据全部放在内存带来了高速的性能，但是也带来一些不合理之处。比如一个中型网站有100万注册用户，如果这些资料要用Redis来存储，内存的容量必须能够容纳这100万用户。但是业务实际情况是100万用户只有5万活跃用户，1周来访问过1次的也只有15万用户，因此全部100万用户的数据都放在内存有不合理之处，RAM需要为冷数据买单。</p><p>这跟操作系统非常相似，操作系统所有应用访问的数据都在内存，但是如果物理内存容纳不下新的数据，操作系统会智能将部分长期没有访问的数据交换到磁盘，为新的应用留出空间。现代操作系统给应用提供的并不是物理内存，而是虚拟内存(Virtual Memory)的概念。</p><p>基于相同的考虑，Redis 2.0也增加了VM特性。让Redis数据容量突破了物理内存的限制。并实现了数据冷热分离。</p><h3 id="Redis的VM实现是重复造轮子"><a href="#Redis的VM实现是重复造轮子" class="headerlink" title="Redis的VM实现是重复造轮子"></a>Redis的VM实现是重复造轮子</h3><p>Redis的VM依照之前的epoll实现思路依旧是自己实现。但是在前面操作系统的介绍提到OS也可以自动帮程序实现冷热数据分离，Redis只需要OS申请一块大内存，OS会自动将热数据放入物理内存，冷数据交换到硬盘，另外一个知名的“理解了现代操作系统(3)”的Varnish就是这样实现，也取得了非常成功的效果。</p><p>作者antirez在解释为什么要自己实现VM中提到几个原因(6)。主要OS的VM换入换出是基于Page概念，比如OS VM1个Page是4K, 4K中只要还有一个元素即使只有1个字节被访问，这个页也不会被SWAP, 换入也同样道理，读到一个字节可能会换入4K无用的内存。而Redis自己实现则可以达到控制换入的粒度。另外访问操作系统SWAP内存区域时block进程，也是导致Redis要自己实现VM原因之一。</p><h3 id="用get-set方式使用Redis"><a href="#用get-set方式使用Redis" class="headerlink" title="用get/set方式使用Redis"></a>用get/set方式使用Redis</h3><p>作为一个key value存在，很多开发者自然的使用set/get方式来使用Redis，实际上这并不是最优化的使用方法。尤其在未启用VM情况下，Redis全部数据需要放入内存，节约内存尤其重要。</p><p>假如一个key-value单元需要最小占用512字节，即使只存一个字节也占了512字节。这时候就有一个设计模式，可以把key复用，几个key-value放入一个key中，value再作为一个set存入，这样同样512字节就会存放10-100倍的容量。</p><p>这就是为了节约内存，建议使用hashset而不是set/get的方式来使用Redis，详细方法见参考文献(7)。</p><h3 id="使用aof代替snapshot"><a href="#使用aof代替snapshot" class="headerlink" title="使用aof代替snapshot"></a>使用aof代替snapshot</h3><p>Redis有两种存储方式，默认是snapshot方式，实现方法是定时将内存的快照(snapshot)持久化到硬盘，这种方法缺点是持久化之后如果出现crash则会丢失一段数据。因此在完美主义者的推动下作者增加了aof方式。aof即append only mode，在写入内存数据的同时将操作命令保存到日志文件，在一个并发更改上万的系统中，命令日志是一个非常庞大的数据，管理维护成本非常高，恢复重建时间会非常长，这样导致失去aof高可用性本意。另外更重要的是Redis是一个内存数据结构模型，所有的优势都是建立在对内存复杂数据结构高效的原子操作上，这样就看出aof是一个非常不协调的部分。</p><p>其实aof目的主要是数据可靠性及高可用性，在Redis中有另外一种方法来达到目的：Replication。由于Redis的高性能，复制基本没有延迟。这样达到了防止单点故障及实现了高可用。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>要想成功使用一种产品，我们需要深入了解它的特性。Redis性能突出，如果能够熟练的驾驭，对国内很多大型应用具有很大帮助。希望更多同行加入到Redis使用及代码研究行列。</p><blockquote><p><a href="http://www.linuxidc.com/Linux/2011-02/32700.htm" target="_blank" rel="noopener">http://www.linuxidc.com/Linux/2011-02/32700.htm</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NoSQL的基本概义</title>
      <link href="/2020/01/04/NoSQL%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
      <url>/2020/01/04/NoSQL%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- START doctoc generated TOC please keep comment here to allow auto update --><!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE --><ul><li><a href="#nosql%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E4%B9%89">NoSQL的基本概义</a><ul><li><a href="#%E5%89%8D%E8%A8%80">前言</a></li><li><a href="#%E5%9F%BA%E6%9C%AC%E5%90%AB%E4%B9%89">基本含义</a></li><li><a href="#nosql%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%9B%9B%E5%A4%A7%E5%88%86%E7%B1%BB">NoSQL数据库的四大分类</a><ul><li><a href="#%E9%94%AE%E5%80%BCkey-value%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE%E5%BA%93">键值(Key-Value)存储数据库</a></li><li><a href="#%E5%88%97%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE%E5%BA%93">列存储数据库</a></li><li><a href="#%E6%96%87%E6%A1%A3%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93">文档型数据库</a></li><li><a href="#%E5%9B%BE%E5%BD%A2graph%E6%95%B0%E6%8D%AE%E5%BA%93">图形(Graph)数据库</a></li><li><a href="#nosql%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%9B%9B%E5%A4%A7%E5%88%86%E7%B1%BB%E8%A1%A8%E6%A0%BC%E5%88%86%E6%9E%90">NoSQL数据库的四大分类表格分析</a></li><li><a href="#%E5%85%B1%E5%90%8C%E7%89%B9%E5%BE%81">共同特征</a></li><li><a href="#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF">适用场景</a></li><li><a href="#%E5%8F%91%E5%B1%95%E7%8E%B0%E7%8A%B6">发展现状</a></li><li><a href="#%E6%8C%91%E6%88%98">挑战</a></li></ul></li></ul></li></ul><!-- END doctoc generated TOC please keep comment here to allow auto update --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>NoSQL，泛指非关系型的数据库。随着互联网web2.0网站的兴起，传统的关系数据库在应付web2.0网站，特别是超大规模和高并发的SNS类型的web2.0纯动态网站已经显得力不从心，暴露了很多难以克服的问题，而非关系型的数据库则由于其本身的特点得到了非常迅速的发展。NoSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，尤其是大数据应用难题。</p><p>虽然NoSQL流行语火起来才短短一年的时间，但是不可否认，现在已经开始了第二代运动。尽管早期的堆栈代码只能算是一种实验，然而现在的系统已经更加的成熟、稳定。不过现在也面临着一个严酷的事实：技术越来越成熟——以至于原来很好的NoSQL数据存储不得不进行重写，也有少数人认为这就是所谓的2.0版本。这里列出一些比较知名的工具，可以为大数据建立快速、可扩展的存储库。</p><p><strong>中文名</strong></p><blockquote><p>非关系型数据库</p></blockquote><p><strong>外文名</strong></p><blockquote><p>NoSQL=Not Only SQL</p></blockquote><p><strong>类别</strong></p><blockquote><p>非关系型的数据库</p></blockquote><p><strong>应用领域</strong></p><blockquote><p>计算机、软件、数据库</p></blockquote><h2 id="基本含义"><a href="#基本含义" class="headerlink" title="基本含义"></a>基本含义</h2><p>NoSQL(NoSQL = Not Only SQL )，意即“不仅仅是SQL”，是一项全新的数据库革命性运动，早期就有人提出，发展至2009年趋势越发高涨。NoSQL的拥护者们提倡运用非关系型的数据存储，相对于铺天盖地的关系型数据库运用，这一概念无疑是一种全新的思维的注入。</p><h2 id="NoSQL数据库的四大分类"><a href="#NoSQL数据库的四大分类" class="headerlink" title="NoSQL数据库的四大分类"></a>NoSQL数据库的四大分类</h2><h3 id="键值-Key-Value-存储数据库"><a href="#键值-Key-Value-存储数据库" class="headerlink" title="键值(Key-Value)存储数据库"></a>键值(Key-Value)存储数据库</h3><p>这一类数据库主要会使用到一个哈希表，这个表中有一个特定的键和一个指针指向特定的数据。Key/value模型对于IT系统来说的优势在于简单、易部署。但是如果DBA只对部分值进行查询或更新的时候，Key/value就显得效率低下了。 </p><p>例如：</p><ul><li>Tokyo Cabinet/Tyrant</li><li>Redis</li><li>Voldemort</li><li>Oracle BDB</li></ul><h3 id="列存储数据库"><a href="#列存储数据库" class="headerlink" title="列存储数据库"></a>列存储数据库</h3><p>这部分数据库通常是用来应对分布式存储的海量数据。键仍然存在，但是它们的特点是指向了多个列。这些列是由列家族来安排的。</p><p>例如：</p><ul><li>Cassandra</li><li>HBase</li><li>Riak</li></ul><h3 id="文档型数据库"><a href="#文档型数据库" class="headerlink" title="文档型数据库"></a>文档型数据库</h3><p>文档型数据库的灵感是来自于Lotus Notes办公软件的，而且它同第一种键值存储相类似。该类型的数据模型是版本化的文档，半结构化的文档以特定的格式存储，比如JSON。文档型数据库可 以看作是键值数据库的升级版，允许之间嵌套键值。而且文档型数据库比键值数据库的查询效率更高。</p><p>例如：</p><ul><li>CouchDB</li><li>MongoDb</li><li>SequoiaDB //国内的文档型数据库，已经开源</li></ul><h3 id="图形-Graph-数据库"><a href="#图形-Graph-数据库" class="headerlink" title="图形(Graph)数据库"></a>图形(Graph)数据库</h3><p>图形结构的数据库同其他行列以及刚性结构的SQL数据库不同，它是使用灵活的图形模型，并且能够扩展到多个服务器上。NoSQL数据库没有标准的查询语言(SQL)，因此进行数据库查询需要制定数据模型。许多NoSQL数据库都有REST式的数据接口或者查询API。</p><pre><code>例如：* Neo4J* InfoGrid* SequoiaDB Infinite Graph</code></pre><blockquote><p>因此，我们总结NoSQL数据库在以下的这几种情况下比较适用：</p><ol><li>数据模型比较简单；</li><li>需要灵活性更强的IT系统；</li><li>对数据库性能要求较高；</li><li>不需要高度的数据一致性；</li><li>对于给定key，比较容易映射复杂值的环境；</li></ol></blockquote><h3 id="NoSQL数据库的四大分类表格分析"><a href="#NoSQL数据库的四大分类表格分析" class="headerlink" title="NoSQL数据库的四大分类表格分析"></a>NoSQL数据库的四大分类表格分析</h3><table><thead><tr><th align="left">分类</th><th align="left">Examples举例</th><th align="left">典型应用场景</th><th align="left">数据模型</th><th align="left">优点</th><th>缺点</th></tr></thead><tbody><tr><td align="left">键值（key-value）</td><td align="left">Tokyo Cabinet/Tyrant, Redis, Voldemort, Oracle BDB</td><td align="left">内容缓存，主要用于处理大量数据的高访问负载，也用于一些日志系统等等。</td><td align="left">Key 指向 Value 的键值对，通常用hash table来实现</td><td align="left">查找速度快</td><td>数据无结构化，通常只被当作字符串或者二进制数据</td></tr><tr><td align="left">列存储数据库</td><td align="left">Cassandra, HBase, Riak</td><td align="left">分布式的文件系统</td><td align="left">以列簇式存储，将同一列数据存在一起</td><td align="left">查找速度快，可扩展性强，更容易进行分布式扩展</td><td>功能相对局限</td></tr><tr><td align="left">文档型数据库</td><td align="left">CouchDB, MongoDb</td><td align="left">Web应用（与Key-Value类似，Value是结构化的，不同的是数据库能够了解Value的内容）</td><td align="left">Key-Value对应的键值对，Value为结构化数据</td><td align="left">数据结构要求不严格，表结构可变，不需要像关系型数据库一样需要预先定义表结构</td><td>查询性能不高，而且缺乏统一的查询语法。</td></tr><tr><td align="left">图形(Graph)数据库</td><td align="left">Neo4J, InfoGrid, Infinite Graph</td><td align="left">社交网络，推荐系统等。专注于构建关系图谱</td><td align="left">图结构</td><td align="left">利用图结构相关算法。比如最短路径寻址，N度关系查找等</td><td>很多时候需要对整个图做计算才能得出需要的信息，而且这种结构不太好做分布式的集群方案。</td></tr></tbody></table><h3 id="共同特征"><a href="#共同特征" class="headerlink" title="共同特征"></a>共同特征</h3><p><strong>对于NoSQL并没有一个明确的范围和定义，但是他们都普遍存在下面一些共同特征：</strong></p><ul><li><strong>不需要预定义模式：</strong> 不需要事先定义数据模式，预定义表结构。数据中的每条记录都可能有不同的属性和格式。当插入数据时，并不需要预先定义它们的模式。</li><li><strong>无共享架构</strong> 相对于将所有数据存储的存储区域网络中的全共享架构。NoSQL往往将数据划分后存储在各个本地服务器上。因为从本地磁盘读取数据的性能往往好于通过网络传输读取数据的性能，从而提高了系统的性能。</li><li><strong>弹性可扩展</strong> 可以在系统运行的时候，动态增加或者删除结点。不需要停机维护，数据可以自动迁移。</li><li><strong>分区</strong> 相对于将数据存放于同一个节点，NoSQL数据库需要将数据进行分区，将记录分散在多个节点上面。并且通常分区的同时还要做复制。这样既提高了并行性能，又能保证没有单点失效的问题。</li><li><strong>异步复制</strong> 和RAID存储系统不同的是，NoSQL中的复制，往往是基于日志的异步复制。这样，数据就可以尽快地写入一个节点，而不会被网络传输引起迟延。缺点是并不总是能保证一致性，这样的方式在出现故障的时候，可能会丢失少量的数据。</li><li><strong>BASE</strong> 相对于事务严格的ACID特性，NoSQL数据库保证的是BASE特性。BASE是最终一致性和软事务。</li></ul><blockquote><p>NoSQL数据库并没有一个统一的架构，两种NoSQL数据库之间的不同，甚至远远超过两种关系型数据库的不同。可以说，NoSQL各有所长，成功的NoSQL必然特别适用于某些场合或者某些应用，在这些场合中会远远胜过关系型数据库和其他的NoSQL。</p></blockquote><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><blockquote><p>NoSQL数据库在以下的这几种情况下比较适用：</p><ol><li>数据模型比较简单；</li><li>需要灵活性更强的IT系统；</li><li>对数据库性能要求较高；</li><li>不需要高度的数据一致性；</li><li>对于给定key，比较容易映射复杂值的环境。</li></ol></blockquote><h3 id="发展现状"><a href="#发展现状" class="headerlink" title="发展现状"></a>发展现状</h3><p><strong>计算机体系结构</strong>在数据存储方面要求具备庞大的水平扩展性，而NoSQL致力于改变这一现状。Google的 BigTable 和Amazon 的Dynamo使用的就是NoSQL型数据库。</p><p>NoSQL项目的名字上看不出什么相同之处，但是，它们通常在某些方面相同：它们可以处理超大量的数据。</p><p>这场革命仍然需要等待。的确，NoSQL对大型企业来说还不是主流，但是，一两年之后很可能就会变个样子。在NoSQL运动的最新一次聚会中，来自世界各地的150人挤满了CBS Interactive的一间会议室。分享他们如何推翻缓慢而昂贵的关系数据库的暴政的经验，怎样使用更有效和更便宜的方法来管理数据。</p><p><em>关系型数据库给你强加了太多东西。它们要你强行修改对象数据，以满足RDBMS （relational database management system，关系型数据库管理系统）的需要，”在NoSQL拥护者们看来，基于NoSQL的替代方案“只是给你所需要的。</em></p><p>水平扩展性(horizontal scalability)指能够连接多个软硬件的特性,这样可以将多个服务器从逻辑上看成一个实体。</p><h3 id="挑战"><a href="#挑战" class="headerlink" title="挑战"></a>挑战</h3><p>尽管大多数NoSQL数据存储系统都已被部署于实际应用中，但归纳其研究现状，还有许多挑战性问题。</p><ul><li>已有key-value数据库产品大多是面向特定应用自治构建的，缺乏通用性；</li><li>已有产品支持的功能有限（不支持事务特性），导致其应用具有一定的局限性；</li><li>已有一些研究成果和改进的NoSQL数据存储系统，但它们都是针对不同应用需求而提出的相应解决方案，如支持组内事务特性、弹性事务等，很少从全局考虑系统的通用性，也没有形成系列化的研究成果；</li><li>缺乏类似关系数据库所具有的强有力的理论(如armstrong公理系统)、技术（如成熟的基于启发式的优化策略、两段封锁协议等）、标准规范（如SQL语言）的支持。</li><li>目前，HBase数据库时安全特性最完善的NoSQL数据库产品之一，而其他的NoSQL数据库多数没有提供内建的安全机制，但随着NoSQL的发展，越来越多的人开始意识到安全的重要，部分NoSQL产品逐渐开始提供一些安全方面的支持。</li></ul><p>随着云计算、互联网等技术的发展，大数据广泛存在，同时也呈现出了许多云环境下的新型应用，如社交网络网、移动服务、协作编辑等。这些新型应用对海量数据管理或称云数据管理系统也提出了新的需求，如事务的支持、系统的弹性等。同时云计算时代海量数据管理系统的设计目标为可扩展性、弹性、容错性、自管理性和“强一致性”。目前，已有系统通过支持可随意增减节点来满足可扩展性；通过副本策略保证系统的容错性；基于监测的状态消息协调实现系统的自管理性。“弹性”的目标是满足Pay-per-use 模型，以提高系统资源的利用率。该特性是已有典型NoSQL数据库系统所不完善的，但却是云系统应具有的典型特点；“强一致性”主要是新应用的需求。</p>]]></content>
      
      
      <categories>
          
          <category> NoSQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NoSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VS2017+MSSQL的下载及安装说明</title>
      <link href="/2020/01/04/VS2017-MSSQL%E7%9A%84%E4%B8%8B%E8%BD%BD%E5%8F%8A%E5%AE%89%E8%A3%85%E8%AF%B4%E6%98%8E/"/>
      <url>/2020/01/04/VS2017-MSSQL%E7%9A%84%E4%B8%8B%E8%BD%BD%E5%8F%8A%E5%AE%89%E8%A3%85%E8%AF%B4%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="VS2017-MSSQL的下载及安装说明"><a href="#VS2017-MSSQL的下载及安装说明" class="headerlink" title="VS2017+MSSQL的下载及安装说明"></a>VS2017+MSSQL的下载及安装说明</h1><h2 id="VS2017"><a href="#VS2017" class="headerlink" title="VS2017"></a>VS2017</h2><blockquote><p><font color="red">.net core开发环境vs必须用2017，电脑可以同时安装多个版本的</font></p></blockquote><p><strong>VS2017下载地址：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">VS2017企业版下载地址：</span><br><span class="line">https:&#x2F;&#x2F;www.visualstudio.com&#x2F;zh-hans&#x2F;thank-you-downloading-visual-studio&#x2F;?sku&#x3D;Enterprise&amp;rel&#x3D;15</span><br><span class="line">VS2017专业版下载地址：</span><br><span class="line">https:&#x2F;&#x2F;www.visualstudio.com&#x2F;zh-hans&#x2F;thank-you-downloading-visual-studio&#x2F;?sku&#x3D;Professional&amp;rel&#x3D;15</span><br></pre></td></tr></table></figure></div><p><strong>VS2017CDK：</strong></p><blockquote><p>Enterprise: NJVYC-BMHX2-G77MM-4XJMR-6Q8QF<br>Professional: KBJFW-NXHK6-W4WJM-CRMQB-G3CDH</p></blockquote><p>安装选择下面2个包即可<br><font color="red"><strong>通用windows平台开发可以不要</strong></font></p><p><a href="/images/vsinstall.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/vsinstall.png" class="lazyload"></a></p><h2 id="MSSQL-SqlServer"><a href="#MSSQL-SqlServer" class="headerlink" title="MSSQL(SqlServer)"></a>MSSQL(SqlServer)</h2><p><strong>SQL Server下载地址：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Sqlserver 百度云下载地址:</span><br><span class="line">链接: http:&#x2F;&#x2F;pan.baidu.com&#x2F;s&#x2F;1jI6iVcU 密码: 7tay</span><br><span class="line"></span><br><span class="line">SqlServer2012下载地址</span><br><span class="line">http:&#x2F;&#x2F;www.microsoft.com&#x2F;zh-cn&#x2F;download&#x2F;details.aspx?id&#x3D;29066</span><br></pre></td></tr></table></figure></div><p><a href="/images/sqldownload.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/sqldownload.png" class="lazyload"></a></p><p><strong>安装说明地址</strong></p><p><a href="http://www.jb51.net/article/42685.htm" target="_blank" rel="noopener">http://www.jb51.net/article/42685.htm</a></p><p><strong>SQL CDK</strong></p><blockquote><p>SQLserver  激活码<br>MICROSOFT SQL SERVER 2012 企业核心版激活码序列号: FH666-Y346V-7XFQ3-V69JM-RHW28</p><p>MICROSOFT SQL SERVER 2012 商业智能版激活码序列号: HRV7T-DVTM4-V6XG8-P36T4-MRYT6</p><p>MICROSOFT SQL SERVER 2012 开发版激活码序列号: YQWTX-G8T4R-QW4XX-BVH62-GP68Y</p><p>MICROSOFT SQL SERVER 2012 企业服务器版/CAL版激活码序列号: 748RB-X4T6B-MRM7V-RTVFF-CHC8H</p><p>MICROSOFT SQL SERVER 2012 标准版激活码序列号: YFC4R-BRRWB-TVP9Y-6WJQ9-MCJQ7</p><p>MICROSOFT SQL SERVER 2012 WEB版激活码序列号: FB3W8-YRXDP-G8F8F-C46KG-Q998F</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 安装包 </category>
          
          <category> VS2017 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安装包 </tag>
            
            <tag> VS2017+MSSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker入门介绍</title>
      <link href="/2019/12/31/2019-12-31-Docker%E5%85%A5%E9%97%A8%E4%BB%8B%E7%BB%8D/"/>
      <url>/2019/12/31/2019-12-31-Docker%E5%85%A5%E9%97%A8%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Docker是什么？"><a href="#Docker是什么？" class="headerlink" title="Docker是什么？"></a>Docker是什么？</h2><p>我们在理解 docker 之前，首先我们得先区分清楚两个概念，<strong>容器和虚拟机</strong>。</p><p>可能很多读者朋友都用过虚拟机，而对容器这个概念比较的陌生。</p><p>我们用的传统虚拟机如 VMware ， VisualBox 之类的需要模拟整台机器包括硬件，每台虚拟机都需要有自己的操作系统，虚拟机一旦被开启，预分配给它的资源将全部被占用。每一台虚拟机包括应用，必要的二进制和库，以及一个完整的用户操作系统。</p><p>而容器技术是和我们的宿主机共享硬件资源及操作系统，可以实现资源的动态分配。容器包含应用和其所有的依赖包，但是与其他容器共享内核。容器在宿主机操作系统中，在用户空间以分离的进程运行。</p><p>容器技术是实现操作系统虚拟化的一种途径，可以让您在资源受到隔离的进程中运行应用程序及其依赖关系。通过使用容器，我们可以轻松打包应用程序的代码、配置和依赖关系，将其变成容易使用的构建块，从而实现环境一致性、运营效率、开发人员生产力和版本控制等诸多目标。容器可以帮助保证应用程序快速、可靠、一致地部署，其间不受部署环境的影响。容器还赋予我们对资源更多的精细化控制能力，让我们的基础设施效率更高。通过下面这幅图我们可以很直观的反映出这两者的区别所在。</p><p><a href="/images/1100338-20181010205426157-1788702025.png" data-fancybox="group" data-caption="image" class="fancybox"><img alt="image" title="image" data-src="/images/1100338-20181010205426157-1788702025.png" class="lazyload"></a></p><p><strong>Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。</strong>它是目前最流行的 Linux 容器解决方案。</p><p>而 Linux 容器是 Linux 发展出了另一种虚拟化技术，简单来讲， Linux 容器不是模拟一个完整的操作系统，而是对进程进行隔离，相当于是在正常进程的外面套了一个保护层。对于容器里面的进程来说，它接触到的各种资源都是虚拟的，从而实现与底层系统的隔离。</p><p>Docker 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 Docker ，就不用担心环境问题。</p><p>总体来说， Docker 的接口相当简单，用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。</p><h2 id="Docker的优势"><a href="#Docker的优势" class="headerlink" title="Docker的优势"></a>Docker的优势</h2><h3 id="Docker相比于传统虚拟化方式具有更多的优势："><a href="#Docker相比于传统虚拟化方式具有更多的优势：" class="headerlink" title="Docker相比于传统虚拟化方式具有更多的优势："></a>Docker相比于传统虚拟化方式具有更多的优势：</h3><ul><li>docker 启动快速属于秒级别。虚拟机通常需要几分钟去启动</li><li>docker 需要的资源更少， docker 在操作系统级别进行虚拟化， docker 容器和内核交互，几乎没有性能损耗，性能优于通过 Hypervisor 层与内核层的虚拟化</li><li>docker 更轻量， docker 的架构可以共用一个内核与共享应用程序库，所占内存极小。同样的硬件环境， Docker 运行的镜像数远多于虚拟机数量，对系统的利用率非常高</li><li>与虚拟机相比， docker 隔离性更弱， docker 属于进程之间的隔离，虚拟机可实现系统级别隔离</li><li>安全性： docker 的安全性也更弱。 Docker 的租户 root 和宿主机 root 等同，一旦容器内的用户从普通用户权限提升为root权限，它就直接具备了宿主机的root权限，进而可进行无限制的操作。虚拟机租户 root 权限和宿主机的 root 虚拟机权限是分离的，并且虚拟机利用如 Intel 的 VT-d 和 VT-x 的 ring-1 硬件隔离技术，这种隔离技术可以防止虚拟机突破和彼此交互，而容器至今还没有任何形式的硬件隔离，这使得容器容易受到攻击</li><li>可管理性： docker 的集中化管理工具还不算成熟。各种虚拟化技术都有成熟的管理工具，例如 VMware vCenter 提供完备的虚拟机管理能力</li><li>高可用和可恢复性： docker 对业务的高可用支持是通过快速重新部署实现的。虚拟化具备负载均衡，高可用，容错，迁移和数据保护等经过生产实践检验的成熟保障机制， VMware 可承诺虚拟机 99.999% 高可用，保证业务连续性</li><li>快速创建、删除：虚拟化创建是分钟级别的， Docker 容器创建是秒级别的， Docker 的快速迭代性，决定了无论是开发、测试、部署都可以节约大量时间</li><li>交付、部署：虚拟机可以通过镜像实现环境交付的一致性，但镜像分发无法体系化。 Docker 在 Dockerfile 中记录了容器构建过程，可在集群中实现快速分发和快速部署</li></ul><p>我们可以从下面这张表格很清楚地看到容器相比于传统虚拟机的特性的优势所在：</p><table><thead><tr><th>特性</th><th>容器</th><th>虚拟机</th></tr></thead><tbody><tr><td>启动</td><td>秒级</td><td>分钟级</td></tr><tr><td>硬盘使用</td><td>一般为MB</td><td>一般为GB</td></tr><tr><td>性能</td><td>接近原生</td><td>弱于</td></tr><tr><td>系统支持量</td><td>单机支持上千个容器</td><td>一般是几十个</td></tr></tbody></table><h2 id="Docker的三个基本概念"><a href="#Docker的三个基本概念" class="headerlink" title="Docker的三个基本概念"></a>Docker的三个基本概念</h2><p><a href="/images/1100338-20181010205425908-509725301.jpg" data-fancybox="group" data-caption="image" class="fancybox"><img alt="image" title="image" data-src="/images/1100338-20181010205425908-509725301.jpg" class="lazyload"></a></p><p>从上图我们可以看到，Docker 中包括三个基本的概念：</p><ul><li>Image(镜像)</li><li>Container(容器)</li><li>Repository(仓库)</li></ul><p>镜像是 Docker 运行容器的前提，仓库是存放镜像的场所，可见镜像更是 Docker 的核心。</p><h3 id="Image-镜像"><a href="#Image-镜像" class="headerlink" title="Image (镜像)"></a>Image (镜像)</h3><p>那么镜像到底是什么呢？</p><p>Docker 镜像可以看作是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p><p>镜像（Image）就是一堆只读层（read-only layer）的统一视角，也许这个定义有些难以理解，下面的这张图能够帮助读者理解镜像的定义。</p><p><a href="/images/1100338-20181010205425698-1711765011.png" data-fancybox="group" data-caption="image" class="fancybox"><img alt="image" title="image" data-src="/images/1100338-20181010205425698-1711765011.png" class="lazyload"></a></p><p>从左边我们看到了多个只读层，它们重叠在一起。除了最下面一层，其它层都会有一个指针指向下一层。这些层是Docker 内部的实现细节，并且能够在主机的文件系统上访问到。统一文件系统 (union file system)技术能够将不同的层整合成一个文件系统，为这些层提供了一个统一的视角，这样就隐藏了多层的存在，在用户的角度看来，只存在一个文件系统。我们可以在图片的右边看到这个视角的形式。</p><h3 id="Container-容器"><a href="#Container-容器" class="headerlink" title="Container (容器)"></a>Container (容器)</h3><p>容器 (container) 的定义和镜像 (image) 几乎一模一样，也是一堆层的统一视角，唯一区别在于容器的最上面那一层是可读可写的。</p><p><a href="/images/1100338-20181010205425262-960721404.png" data-fancybox="group" data-caption="image" class="fancybox"><img alt="image" title="image" data-src="/images/1100338-20181010205425262-960721404.png" class="lazyload"></a></p><p>由于容器的定义并没有提及是否要运行容器，所以实际上，容器 = 镜像 + 读写层。</p><h3 id="Repository-仓库"><a href="#Repository-仓库" class="headerlink" title="Repository (仓库)"></a>Repository (仓库)</h3><p>Docker 仓库是集中存放镜像文件的场所。镜像构建完成后，可以很容易的在当前宿主上运行，但是， 如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker Registry (仓库注册服务器)就是这样的服务。有时候会把仓库 (Repository) 和仓库注册服务器 (Registry) 混为一谈，并不严格区分。Docker 仓库的概念跟 Git 类似，注册服务器可以理解为 GitHub 这样的托管服务。实际上，一个 Docker Registry 中可以包含多个仓库 (Repository) ，每个仓库可以包含多个标签 (Tag)，每个标签对应着一个镜像。所以说，镜像仓库是 Docker 用来集中存放镜像文件的地方类似于我们之前常用的代码仓库。</p><p>通常，<strong>一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本 。</strong> 我们可以通过&lt;仓库名&gt;:&lt;标签&gt;的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 latest 作为默认标签。</p><p><strong>仓库又可以分为两种形式：</strong></p><ul><li>public(公有仓库)</li><li>private(私有仓库)</li></ul><p>Docker Registry 公有仓库是开放给用户使用、允许用户管理镜像的 Registry 服务。一般这类公开服务允许用户免费上传、下载公开的镜像，并可能提供收费服务供用户管理私有镜像。</p><p>除了使用公开服务外，用户还可以在本地搭建私有 Docker Registry 。Docker 官方提供了 Docker Registry镜像，可以直接使用做为私有 Registry 服务。当用户创建了自己的镜像之后就可以使用 push 命令将它上传到公有或者私有仓库，这样下次在另外一台机器上使用这个镜像时候，只需要从仓库上 pull 下来就可以了。</p><p>我们主要把 Docker 的一些常见概念如 Image ， Container ， Repository 做了详细的阐述，也从传统虚拟化方式的角度阐述了 docker 的优势，我们从下图可以直观地看到 Docker 的架构：</p><p><a href="/images/1100338-20181011200344086-1510826338.png" data-fancybox="group" data-caption="image" class="fancybox"><img alt="image" title="image" data-src="/images/1100338-20181011200344086-1510826338.png" class="lazyload"></a></p><p>Docker 使用 C/S 结构，即 <strong>客户端/服务器</strong>体系结构。 Docker 客户端与 Docker 服务器进行交互，Docker服务端负责构建、运行和分发 Docker 镜像。 Docker 客户端和服务端可以运行在一台机器上，也可以通过 RESTful 、 stock 或网络接口与远程 Docker 服务端进行通信。</p><p><a href="/images/1100338-20181011200343656-1972949758.png" data-fancybox="group" data-caption="image" class="fancybox"><img alt="image" title="image" data-src="/images/1100338-20181011200343656-1972949758.png" class="lazyload"></a></p><p>这张图展示了 Docker 客户端、服务端和 Docker 仓库（即 Docker Hub 和 Docker Cloud ），默认情况下Docker 会在 Docker 中央仓库寻找镜像文件，这种利用仓库管理镜像的设计理念类似于 Git ，当然这个仓库是可以通过修改配置来指定的，甚至我们可以创建我们自己的私有仓库。</p><h2 id="Docker的安装和使用"><a href="#Docker的安装和使用" class="headerlink" title="Docker的安装和使用"></a>Docker的安装和使用</h2><p>Docker 的安装和使用有一些前提条件，主要体现在体系架构和内核的支持上。对于体系架构，除了 Docker 一开始就支持的 X86-64 ，其他体系架构的支持则一直在不断地完善和推进中。</p><p>Docker 分为 CE 和 EE 两大版本。 CE 即社区版（免费，支持周期 7 个月）， EE 即企业版，强调安全，付费使用，支持周期 24 个月。</p><p>我们在安装前可以参看官方文档获取最新的 Docker 支持情况，官方文档在这里：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;docs.docker.com&#x2F;install&#x2F;</span><br></pre></td></tr></table></figure></div><p>Docker 对于内核支持的功能，即内核的配置选项也有一定的要求(比如必须开启 Cgroup 和 Namespace 相关选项，以及其他的网络和存储驱动等)， Docker 源码中提供了一个检测脚本来检测和指导内核的配置，脚本链接在这里：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;docker&#x2F;docker&#x2F;master&#x2F;contrib&#x2F;check-config.sh</span><br></pre></td></tr></table></figure></div><p>在满足前提条件后，安装就变得非常的简单了。</p><p>Docker CE 的安装请参考官方文档：</p><ul><li>MacOS：<a href="https://docs.docker.com/docker-for-mac/install/" target="_blank" rel="noopener">https://docs.docker.com/docker-for-mac/install/</a></li><li>Windows：<a href="https://docs.docker.com/docker-for-windows/install/" target="_blank" rel="noopener">https://docs.docker.com/docker-for-windows/install/</a></li><li>Ubuntu：<a href="https://docs.docker.com/install/linux/docker-ce/ubuntu/" target="_blank" rel="noopener">https://docs.docker.com/install/linux/docker-ce/ubuntu/</a></li><li>Debian：<a href="https://docs.docker.com/install/linux/docker-ce/debian/" target="_blank" rel="noopener">https://docs.docker.com/install/linux/docker-ce/debian/</a></li><li>CentOS：<a href="https://docs.docker.com/install/linux/docker-ce/centos/" target="_blank" rel="noopener">https://docs.docker.com/install/linux/docker-ce/centos/</a></li><li>Fedora：<a href="https://docs.docker.com/install/linux/docker-ce/fedora/" target="_blank" rel="noopener">https://docs.docker.com/install/linux/docker-ce/fedora/</a></li><li>其他 Linux 发行版：<a href="https://docs.docker.com/install/linux/docker-ce/binaries/" target="_blank" rel="noopener">https://docs.docker.com/install/linux/docker-ce/binaries/</a></li></ul><p>这里我们以 CentOS7 作为本文的演示。</p><p>环境准备</p><ul><li><strong>阿里云服务器(1核2G，1M带宽)</strong></li><li><strong>CentOS 7.4 64位</strong></li></ul><p>由于 Docker-CE 支持 64 位版本的 CentOS7 ，并且要求内核版本不低于 3.10</p><p>首先我们需要卸载掉旧版本的 Docker</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ sudo yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-selinux \</span><br><span class="line">                  docker-engine-selinux \</span><br><span class="line">                  docker-engine</span><br></pre></td></tr></table></figure></div><p><a href="/images/1100338-20181011200343338-1510604822.png" data-fancybox="group" data-caption="image" class="fancybox"><img alt="image" title="image" data-src="/images/1100338-20181011200343338-1510604822.png" class="lazyload"></a></p><p>我们执行以下安装命令去安装依赖包：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum install -y yum-utils \</span><br><span class="line">           device-mapper-persistent-data \</span><br><span class="line">           lvm2</span><br></pre></td></tr></table></figure></div><p>这里我事先已经安装过了，所以提示我已经安装了最新版本</p><p><a href="/images/1100338-20181011200343082-1053047604.png" data-fancybox="group" data-caption="image" class="fancybox"><img alt="image" title="image" data-src="/images/1100338-20181011200343082-1053047604.png" class="lazyload"></a></p><h3 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h3><p>Docker 软件包已经包括在默认的 CentOS-Extras 软件源里。因此想要安装 docker，只需要运行下面的 yum 命令</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install docker</span><br></pre></td></tr></table></figure></div><p>当然在测试或开发环境中 Docker 官方为了简化安装流程，提供了一套便捷的安装脚本，CentOS 系统上可以使用这套脚本安装：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL get.docker.com -o get-docker.sh</span><br><span class="line">sh get-docker.sh</span><br></pre></td></tr></table></figure></div><p>具体可以参看 docker-install 的脚本：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;docker&#x2F;docker-install</span><br></pre></td></tr></table></figure></div><p>执行这个命令后，脚本就会自动的将一切准备工作做好，并且把 Docker CE 的 Edge 版本安装在系统中。</p><p>安装完成后，运行下面的命令，验证是否安装成功：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker version</span><br><span class="line">or</span><br><span class="line">docker info</span><br></pre></td></tr></table></figure></div><p>返回docker的版本相关信息，证明 docker 安装成功</p><p><a href="/images/1100338-20181011200342486-1791743202.png" data-fancybox="group" data-caption="image" class="fancybox"><img alt="image" title="image" data-src="/images/1100338-20181011200342486-1791743202.png" class="lazyload"></a></p><p>启动Docker-CE</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl enable docker</span><br><span class="line">$ sudo systemctl start docker</span><br></pre></td></tr></table></figure></div><p>Docker的简单运用—Hello World</p><p>由于服务器日常崩溃了， docker 出了点问题，所以以下案例的演示是基于 Kali Linux 环境下进行的。</p><p>我们通过最简单的 image 文件 hello world，感受一下 Docker 的魅力吧！</p><p>我们直接运行下面的命令，将名为 hello-world 的 image 文件从仓库抓取到本地。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull library&#x2F;hello-world</span><br></pre></td></tr></table></figure></div><p>docker pull images 是抓取 image 文件， library/hello-world 是 image 文件在仓库里面的位置，其中 library 是 image 文件所在的组， hello-world 是 image 文件的名字。</p><p><a href="/images/1100338-20181011200342100-457982713.png" data-fancybox="group" data-caption="image" class="fancybox"><img alt="image" title="image" data-src="/images/1100338-20181011200342100-457982713.png" class="lazyload"></a></p><p>抓取成功以后，就可以在本机看到这个 image 文件了。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure></div><p>我们可以看到如下结果：</p><p><a href="/images/1100338-20181011200341767-414070160.png" data-fancybox="group" data-caption="image" class="fancybox"><img alt="image" title="image" data-src="/images/1100338-20181011200341767-414070160.png" class="lazyload"></a></p><p>输出这段提示以后，hello world 就会停止运行，容器自动终止。有些容器不会自动终止，因为提供的是服务，比如Mysql镜像等。</p><p>是不是很 easy 呢？我们从上面可以看出， docker 的功能是十分强大的，除此之外，我们还可以拉去一些 Ubuntu ， Apache 等镜像，在未来的教程中我们将会一一提到。</p><p>Docker 提供了一套简单实用的命令来创建和更新镜像，我们可以通过网络直接下载一个已经创建好了的应用镜像，并通过 Docker RUN 命令就可以直接使用。当镜像通过 RUN 命令运行成功后，这个运行的镜像就是一个 Docker 容器啦，容器可以理解为一个轻量级的沙箱， Docker 利用容器来运行和隔离应用，容器是可以被启动、停止、删除的，这并不会影响 Docker 镜像。</p><p>我们可以看看下面这幅图：</p><p><a href="/images/1100338-20181011200340694-1202370283.png" data-fancybox="group" data-caption="image" class="fancybox"><img alt="image" title="image" data-src="/images/1100338-20181011200340694-1202370283.png" class="lazyload"></a></p><p>Docker 客户端是 Docker 用户与 Docker 交互的主要方式。当您使用 docker 命令行运行命令时， Docker 客户端将这些命令发送给服务器端，服务端将执行这些命令。 docker 命令使用 docker API 。 Docker 客户端可以与多个服务端进行通信。</p><p>我们将剖析一下 Docker 容器是如何工作的，学习好Docker容器工作的原理，我们就可以自己去管理我们的容器了。</p><h2 id="Docker架构"><a href="#Docker架构" class="headerlink" title="Docker架构"></a>Docker架构</h2><p>在上面的学习中，我们简单地讲解了Docker的基本架构。了解到了Docker 使用的是 C/S 结构，即<strong>客户端/服务器</strong>体系结构。明白了 Docker 客户端与 Docker 服务器进行交互时， Docker 服务端负责构建、运行和分发 Docker 镜像。 也知道了Docker 客户端和服务端可以运行在一台机器上，可以通过 RESTful 、 stock 或网络接口与远程 Docker 服务端进行通信。</p><p>我们从下图可以很直观的了解到Docker的架构：</p><p><a href="/images/1100338-20181012214103608-969706945.png" data-fancybox="group" data-caption="image" class="fancybox"><img alt="image" title="image" data-src="/images/1100338-20181012214103608-969706945.png" class="lazyload"></a></p><p>Docker 的核心组件包括：</p><ol><li><strong>Docker Client</strong></li><li><strong>Docker daemon</strong></li><li><strong>Docker Image</strong></li><li><strong>Docker Registry</strong></li><li><strong>Docker Container</strong></li></ol><p>Docker 采用的是 Client/Server 架构。客户端向服务器发送请求，服务器负责构建、运行和分发容器。客户端和服务器可以运行在同一个 Host 上，客户端也可以通过 socket 或 REST API 与远程的服务器通信。可能很多朋友暂时不太理解一些东西，比如 REST API 是什么东西等，不过没关系，在后面的文章中会一一给大家讲解清楚。</p><h3 id="Docker-Client"><a href="#Docker-Client" class="headerlink" title="Docker Client"></a>Docker Client</h3><p>Docker Client ，也称 Docker 客户端。它其实就是 Docker 提供命令行界面 (CLI) 工具，是许多 Docker 用户与 Docker 进行交互的主要方式。客户端可以构建，运行和停止应用程序，还可以远程与Docker_Host进行交互。最常用的 Docker 客户端就是 docker 命令，我们可以通过 docker 命令很方便地在 host 上构建和运行 docker 容器。</p><p><a href="/images/1100338-20181012214102869-1003920118.png" data-fancybox="group" data-caption="image" class="fancybox"><img alt="image" title="image" data-src="/images/1100338-20181012214102869-1003920118.png" class="lazyload"></a></p><h3 id="Docker-daemon"><a href="#Docker-daemon" class="headerlink" title="Docker daemon"></a>Docker daemon</h3><p>Docker daemon 是服务器组件，以 Linux 后台服务的方式运行，是 Docker 最核心的后台进程，我们也把它称为守护进程。它负责响应来自 Docker Client 的请求，然后将这些请求翻译成系统调用完成容器管理操作。该进程会在后台启动一个 API Server ，负责接收由 Docker Client 发送的请求，接收到的请求将通过Docker daemon 内部的一个路由分发调度，由具体的函数来执行请求。</p><p><a href="/images/1100338-20181012214101750-1118997362.png" data-fancybox="group" data-caption="image" class="fancybox"><img alt="image" title="image" data-src="/images/1100338-20181012214101750-1118997362.png" class="lazyload"></a></p><p>我们大致可以将其分为以下三部分：</p><ul><li><strong>Docker Server</strong></li><li><strong>Engine</strong></li><li><strong>Job</strong></li></ul><h4 id="Docker-Daemon的架构如下所示："><a href="#Docker-Daemon的架构如下所示：" class="headerlink" title="Docker Daemon的架构如下所示："></a>Docker Daemon的架构如下所示：</h4><p><a href="/images/1100338-20181012214101184-1339527466.jpg" data-fancybox="group" data-caption="image" class="fancybox"><img alt="image" title="image" data-src="/images/1100338-20181012214101184-1339527466.jpg" class="lazyload"></a></p><p>Docker Daemon 可以认为是通过 Docker Server 模块接受 Docker Client 的请求，并在 Engine 中处理请求，然后根据请求类型，创建出指定的 Job 并运行。 Docker Daemon 运行在 Docker host 上，负责创建、运行、监控容器，构建、存储镜像。</p><p>运行过程的作用有以下几种可能：</p><ul><li>向 Docker Registry 获取镜像</li><li>通过 graphdriver 执行容器镜像的本地化操作</li><li>通过 networkdriver 执行容器网络环境的配置</li><li>通过 execdriver 执行容器内部运行的执行工作</li></ul><p>由于 Docker Daemon 和 Docker Client 的启动都是通过可执行文件 docker 来完成的，因此两者的启动流程非常相似。 Docker 可执行文件运行时，运行代码通过不同的命令行 flag 参数，区分两者，并最终运行两者各自相应的部分。</p><p>启动 Docker Daemon 时，一般可以使用以下命令来完成</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker --daemon &#x3D; true</span><br><span class="line">docker –d</span><br><span class="line">docker –d &#x3D; true</span><br></pre></td></tr></table></figure></div><p>再由 docker 的 main() 函数来解析以上命令的相应 flag 参数，并最终完成 Docker Daemon 的启动。</p><p>下图可以很直观地看到 Docker Daemon 的启动流程：</p><p><a href="/images/1100338-20181012214100787-426925315.jpg" data-fancybox="group" data-caption="image" class="fancybox"><img alt="image" title="image" data-src="/images/1100338-20181012214100787-426925315.jpg" class="lazyload"></a></p><p>默认配置下， Docker daemon 只能响应来自本地 Host 的客户端请求。如果要允许远程客户端请求，需要在配置文件中打开 TCP 监听。我们可以照着如下步骤进行配置：</p><h5 id="编辑配置文件-etc-systemd-system-multi-user-target-wants-docker-service-，在环境变量-ExecStart后面添加-H-tcp-0-0-0-0，允许来自任意-IP-的客户端连接。"><a href="#编辑配置文件-etc-systemd-system-multi-user-target-wants-docker-service-，在环境变量-ExecStart后面添加-H-tcp-0-0-0-0，允许来自任意-IP-的客户端连接。" class="headerlink" title="编辑配置文件 /etc/systemd/system/multi-user.target.wants/docker.service ，在环境变量 ExecStart后面添加 -H tcp://0.0.0.0，允许来自任意 IP 的客户端连接。"></a>编辑配置文件 /etc/systemd/system/multi-user.target.wants/docker.service ，在环境变量 ExecStart后面添加 -H tcp://0.0.0.0，允许来自任意 IP 的客户端连接。</h5><p><a href="/images/1100338-20181012214100440-905260954.jpg" data-fancybox="group" data-caption="image" class="fancybox"><img alt="image" title="image" data-src="/images/1100338-20181012214100440-905260954.jpg" class="lazyload"></a></p><h5 id="重启-Docker-daemon"><a href="#重启-Docker-daemon" class="headerlink" title="重启 Docker daemon"></a>重启 Docker daemon</h5><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker.service</span><br></pre></td></tr></table></figure></div><h5 id="我们通过以下命令即可实现与远程服务器通信"><a href="#我们通过以下命令即可实现与远程服务器通信" class="headerlink" title="我们通过以下命令即可实现与远程服务器通信"></a>我们通过以下命令即可实现与远程服务器通信</h5><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker -H 服务器IP地址 info</span><br></pre></td></tr></table></figure></div><p><em>-H 是用来指定服务器主机， info 子命令用于查看 Docker 服务器的信息</em></p><h3 id="Docker-Image"><a href="#Docker-Image" class="headerlink" title="Docker Image"></a>Docker Image</h3><p>Docker 镜像可以看作是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。我们可将 Docker 镜像看成只读模板，通过它可以创建 Docker 容器。</p><p>镜像有多种生成方法：</p><ol><li>从无到有开始创建镜像</li><li>下载并使用别人创建好的现成的镜像</li><li>在现有镜像上创建新的镜像</li></ol><p>我们可以将镜像的内容和创建步骤描述在一个文本文件中，这个文件被称作 Dockerfile ，通过执行 docker build <docker-file> 命令可以构建出 Docker 镜像，在后续的教程中，我们会用一篇专门讨论这个问题。</docker-file></p><h3 id="Docker-Registry"><a href="#Docker-Registry" class="headerlink" title="Docker Registry"></a>Docker Registry</h3><p>Docker registry 是存储 docker image 的仓库，它在 docker 生态环境中的位置如下图所示：</p><p><a href="/images/1100338-20181012214100277-775657574.jpg" data-fancybox="group" data-caption="image" class="fancybox"><img alt="image" title="image" data-src="/images/1100338-20181012214100277-775657574.jpg" class="lazyload"></a></p><p>运行docker push、docker pull、docker search时，实际上是通过 docker daemon 与 docker registry 通信。</p><h3 id="Docker-Container"><a href="#Docker-Container" class="headerlink" title="Docker Container"></a>Docker Container</h3><p>Docker 容器就是 Docker 镜像的运行实例，是真正运行项目程序、消耗系统资源、提供服务的地方。 Docker Container 提供了系统硬件环境，我们可以使用 Docker Images 这些制作好的系统盘，再加上我们所编写好的项目代码， run 一下就可以提供服务啦。</p><h2 id="Docker组件是如何协作运行容器"><a href="#Docker组件是如何协作运行容器" class="headerlink" title="Docker组件是如何协作运行容器"></a>Docker组件是如何协作运行容器</h2><p>看到这里，我相信各位读者朋友们应该已经对Docker基础架构已经熟悉的差不多了，我们还记得运行的第一个容器吗？现在我们再通过hello-world这个例子来体会一下 Docker 各个组件是如何协作的。</p><p>容器启动过程如下：</p><ul><li>Docker 客户端执行 docker run 命令</li><li>Docker daemon 发现本地没有 hello-world 镜像</li><li>daemon 从 Docker Hub 下载镜像</li><li>下载完成，镜像 hello-world 被保存到本地</li><li>Docker daemon 启动容器</li></ul><p>具体过程可以看如下这幅演示图：</p><p><a href="/images/1100338-20181012214059835-734054348.png" data-fancybox="group" data-caption="image" class="fancybox"><img alt="image" title="image" data-src="/images/1100338-20181012214059835-734054348.png" class="lazyload"></a></p><p>我们可以通过docker images 可以查看到 hello-world 已经下载到本地</p><p><a href="/images/1100338-20181012214059170-1387452245.png" data-fancybox="group" data-caption="image" class="fancybox"><img alt="image" title="image" data-src="/images/1100338-20181012214059170-1387452245.png" class="lazyload"></a></p><p>我们可以通过docker ps 或者 docker container ls 显示正在运行的容器，我们可以看到， hello-world 在输出提示信息以后就会停止运行，容器自动终止，所以我们在查看的时候没有发现有容器在运行。</p><p><a href="/images/1100338-20181012214058803-1594502697.png" data-fancybox="group" data-caption="image" class="fancybox"><img alt="image" title="image" data-src="/images/1100338-20181012214058803-1594502697.png" class="lazyload"></a></p><p>我们把 Docker 容器的工作流程剖析的十分清楚了，我们大体可以知道 Docker 组件协作运行容器可以分为以下几个过程：</p><ol><li>Docker 客户端执行 docker run 命令</li><li>Docker daemon 发现本地没有我们需要的镜像</li><li>daemon 从 Docker Hub 下载镜像</li><li>下载完成后，镜像被保存到本地</li><li>Docker daemon 启动容器</li></ol><p>了解了这些过程以后，我们再来理解这些命令就不会觉得很突兀了，下面我来给大家讲讲 Docker 常用的一些命令操作吧。</p><h2 id="Docker常用命令"><a href="#Docker常用命令" class="headerlink" title="Docker常用命令"></a>Docker常用命令</h2><p>我们可以通过 docker -h 去查看命令的详细的帮助文档。在这里我只会讲一些平常日常比赛或者生活中我们可能会用的比较多的一些命令。</p><p><a href="/images/1100338-20181014202945937-1677031749.png" data-fancybox="group" data-caption="image" class="fancybox"><img alt="image" title="image" data-src="/images/1100338-20181014202945937-1677031749.png" class="lazyload"></a></p><p>例如，我们需要拉取一个 docker 镜像，我们可以用如下命令：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull image_name</span><br></pre></td></tr></table></figure></div><p>image_name 为镜像的名称，而如果我们想从 Docker Hub 上去下载某个镜像，我们可以使用以下命令：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull centos:latest</span><br></pre></td></tr></table></figure></div><p>centos:lastest 是镜像的名称， Docker daemon 发现本地没有我们需要的镜像，会自动去 Docker Hub 上去下载镜像，下载完成后，该镜像被默认保存到 /var/lib/docker 目录下。</p><p>接着我们如果想查看下主机下存在多少镜像，我们可以用如下命令：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure></div><p>我们要想知道当前有哪些容器在运行，我们可以用如下命令：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure></div><p><em>-a 是查看当前所有的容器，包括未运行的</em></p><p>我们该如何去对一个容器进行启动，重启和停止呢？我们可以用如下命令：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker start container_name&#x2F;container_id</span><br><span class="line">docker restart container_name&#x2F;container_id</span><br><span class="line">docker stop container_name&#x2F;container_id</span><br></pre></td></tr></table></figure></div><p>这个时候我们如果想进入到这个容器中，我们可以使用 attach 命令：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker attach container_name&#x2F;container_id</span><br></pre></td></tr></table></figure></div><p>那如果我们想运行这个容器中的镜像的话，并且调用镜像里面的 bash ，我们可以使用如下命令：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -t -i container_name&#x2F;container_id &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure></div><p>那如果这个时候，我们想删除指定镜像的话，由于 image 被某个 container 引用（拿来运行），如果不将这个引用的 container 销毁（删除），那 image 肯定是不能被删除。我们首先得先去停止这个容器：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br><span class="line">docker stop container_name&#x2F;container_id</span><br></pre></td></tr></table></figure></div><p>然后我们用如下命令去删除这个容器：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm container_name&#x2F;container_id</span><br></pre></td></tr></table></figure></div><p>然后这个时候我们再去删除这个镜像：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi image_name</span><br></pre></td></tr></table></figure></div><p>此时，常用的 Docker 相关的命令就讲到这里为止了，我们在后续的文章中还会反复地提到这些命令。</p><h2 id="Dockerfile是什么"><a href="#Dockerfile是什么" class="headerlink" title="Dockerfile是什么"></a>Dockerfile是什么</h2><p>前面我们已经提到了 Docker 的一些基本概念。以 CTF 选手的角度来看，我们可以去使用 Dockerfile 定义镜像，依赖镜像来运行容器，可以去模拟出一个真实的漏洞场景。因此毫无疑问的说， Dockerfile 是镜像和容器的关键，并且 Dockerfile 还可以很轻易的去定义镜像内容，说了这么多，那么 Dockerfile 到底是个什么东西呢？</p><p>Dockerfile 是自动构建 docker 镜像的配置文件， 用户可以使用 Dockerfile 快速创建自定义的镜像。Dockerfile 中的命令非常类似于 linux 下的 shell 命令。</p><p>我们可以通过下面这幅图来直观地感受下 Docker 镜像、容器和 Dockerfile 三者之间的关系。</p><p><a href="/images/1100338-20181014202945505-1291953865.png" data-fancybox="group" data-caption="image" class="fancybox"><img alt="image" title="image" data-src="/images/1100338-20181014202945505-1291953865.png" class="lazyload"></a></p><p>我们从上图中可以看到， Dockerfile 可以自定义镜像，通过 Docker 命令去运行镜像，从而达到启动容器的目的。</p><p>Dockerfile 是由一行行命令语句组成，并且支持已 # 开头的注释行。</p><p>一般来说，我们可以将 Dockerfile 分为四个部分：</p><ul><li><strong>基础镜像(父镜像)信息指令 FROM</strong></li><li><strong>维护者信息指令 MAINTAINER</strong></li><li><strong>镜像操作指令 RUN 、 EVN 、 ADD 和 WORKDIR 等</strong></li><li><strong>容器启动指令 CMD 、 ENTRYPOINT 和 USER 等</strong></li></ul><p>下面是一段简单的Dockerfile的例子：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">FROM python:2.7</span><br><span class="line">MAINTAINER Angel_Kitty &lt;angelkitty6698@gmail.com&gt;</span><br><span class="line">COPY . &#x2F;app</span><br><span class="line">WORKDIR &#x2F;app</span><br><span class="line">RUN pip install -r requirements.txt</span><br><span class="line">EXPOSE 5000</span><br><span class="line">ENTRYPOINT [&quot;python&quot;]</span><br><span class="line">CMD [&quot;app.py&quot;]</span><br></pre></td></tr></table></figure></div><p>我们可以分析一下上面这个过程：</p><ol><li>从 Docker Hub 上 pull 下 python 2.7 的基础镜像</li><li>显示维护者的信息</li><li>copy 当前目录到容器中的 /app 目录下 复制本地主机的 <src> ( Dockerfile 所在目录的相对路径)到容器里 <dest></dest></src></li><li>指定工作路径为 /app</li><li>安装依赖包</li><li>暴露 5000 端口</li><li>启动 app</li></ol><p>这个例子是启动一个 python flask app 的 Dockerfile ( flask 是 python 的一个轻量的 web 框架)，相信大家从这个例子中能够稍微理解了Dockfile的组成以及指令的编写过程。</p><h2 id="Dockerfile常用的指令"><a href="#Dockerfile常用的指令" class="headerlink" title="Dockerfile常用的指令"></a>Dockerfile常用的指令</h2><p>根据上面的例子，我们已经差不多知道了Dockerfile的组成以及指令的编写过程，我们再来理解一下这些常用命令就会得心应手了。</p><p>由于 Dockerfile 中所有的命令都是以下格式：INSTRUCTION argument ，指令 (INSTRUCTION) 不分大小写，但是推荐大写，和sql语句是不是很相似呢？下面我们正式来讲解一下这些指令集吧。</p><h3 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h3><p>FROM 是用于指定基础的 images ，一般格式为 FROM <image> or FORM <image>:<tag> ，所有的 Dockerfile 都用该以 FROM 开头，FROM 命令指明 Dockerfile 所创建的镜像文件以什么镜像为基础，FROM 以后的所有指令都会在 FROM 的基础上进行创建镜像。可以在同一个 Dockerfile 中多次使用 FROM 命令用于创建多个镜像。比如我们要指定 python 2.7 的基础镜像，我们可以像如下写法一样：</tag></image></image></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FROM python:2.7</span><br></pre></td></tr></table></figure></div><h3 id="MAINTAINER"><a href="#MAINTAINER" class="headerlink" title="MAINTAINER"></a>MAINTAINER</h3><p>MAINTAINER 是用于指定镜像创建者和联系方式，一般格式为 MAINTAINER <name> 。这里我设置成我的 ID 和邮箱：</name></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MAINTAINER Angel_Kitty &lt;angelkitty6698@gmail.com&gt;</span><br></pre></td></tr></table></figure></div><h3 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h3><p>COPY 是用于复制本地主机的 <src> (为 Dockerfile 所在目录的相对路径)到容器中的 <dest>。</dest></src></p><p>当使用本地目录为源目录时，推荐使用 COPY 。一般格式为 COPY <src><dest> 。例如我们要拷贝当前目录到容器中的 /app 目录下，我们可以这样操作：</dest></src></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COPY . &#x2F;app</span><br></pre></td></tr></table></figure></div><h3 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h3><p>WORKDIR 用于配合 RUN，CMD，ENTRYPOINT 命令设置当前工作路径。可以设置多次，如果是相对路径，则相对前一个 WORKDIR 命令。默认路径为/。一般格式为 WORKDIR /path/to/work/dir 。例如我们设置/app 路径，我们可以进行如下操作：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WORKDIR &#x2F;app</span><br></pre></td></tr></table></figure></div><h3 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h3><p>RUN 用于容器内部执行命令。每个 RUN 命令相当于在原有的镜像基础上添加了一个改动层，原有的镜像不会有变化。一般格式为 RUN <command> 。例如我们要安装 python 依赖包，我们做法如下：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUN pip install -r requirements.txt</span><br></pre></td></tr></table></figure></div><h3 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h3><p>EXPOSE 命令用来指定对外开放的端口。一般格式为 EXPOSE <port> [<port>…]<br>例如上面那个例子，开放5000端口：</port></port></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPOSE 5000</span><br></pre></td></tr></table></figure></div><h3 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h3><p>ENTRYPOINT 可以让你的容器表现得像一个可执行程序一样。一个 Dockerfile 中只能有一个 ENTRYPOINT，如果有多个，则最后一个生效。<br>ENTRYPOINT 命令也有两种格式：</p><ul><li>ENTRYPOINT [“executable”, “param1”, “param2”] ：推荐使用的 exec形式</li><li>ENTRYPOINT command param1 param2 ：shell 形式</li></ul><p>例如下面这个，我们要将 python 镜像变成可执行的程序，我们可以这样去做：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ENTRYPOINT [&quot;python&quot;]</span><br></pre></td></tr></table></figure></div><h3 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h3><p>CMD 命令用于启动容器时默认执行的命令，CMD 命令可以包含可执行文件，也可以不包含可执行文件。不包含可执行文件的情况下就要用 ENTRYPOINT 指定一个，然后 CMD 命令的参数就会作为ENTRYPOINT的参数。</p><p>CMD 命令有三种格式：</p><ul><li>CMD [“executable”,”param1”,”param2”]：推荐使用的 exec 形式。</li><li>CMD [“param1”,”param2”]：无可执行程序形式</li><li>CMD command param1 param2：shell 形式。</li></ul><p>一个 Dockerfile 中只能有一个CMD，如果有多个，则最后一个生效。而 CMD 的 shell 形式默认调用 /bin/sh -c 执行命令。<br>CMD 命令会被 Docker 命令行传入的参数覆盖：docker run busybox /bin/echo Hello Docker 会把 CMD 里的命令覆盖。<br>例如我们要启动 /app ，我们可以用如下命令实现：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMD [&quot;app.py&quot;]</span><br></pre></td></tr></table></figure></div><p>当然还有一些其他的命令，我们在用到的时候再去一一讲解一下。</p><h2 id="构建Dockerfile"><a href="#构建Dockerfile" class="headerlink" title="构建Dockerfile"></a>构建Dockerfile</h2><p>我们大体已经把Dockerfile的写法讲述完毕，我们可以自己动手写一个例子：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mkdir static_web</span><br><span class="line">cd static_web</span><br><span class="line">touch Dockerfile</span><br><span class="line">然后 vi Dockerfile  开始编辑该文件</span><br><span class="line">输入 i 开始编辑</span><br><span class="line"> </span><br><span class="line">以下是我们构建的Dockerfile内容</span><br><span class="line"></span><br><span class="line">FROM nginx</span><br><span class="line">MAINTAINER Angel_Kitty &lt;angelkitty6698@gmail.com&gt;</span><br><span class="line">RUN echo &#39;&lt;h1&gt;Hello, Docker!&lt;&#x2F;h1&gt;&#39; &gt; &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;index.html</span><br><span class="line"> </span><br><span class="line">编辑完后 按 esc 退出编辑</span><br><span class="line">然后  :wq    写入 退出</span><br></pre></td></tr></table></figure></div><p>我们在 Dockerfile 文件所在目录执行：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t angelkitty&#x2F;nginx_web:v1 .</span><br></pre></td></tr></table></figure></div><p>我们解释一下， -t 是为新镜像设置仓库和名称，其中 angelkitty 为仓库名， nginx_web 为镜像名， :v1为标签（不添加为默认 latest ）</p><p>我们构建完成之后，使用 docker images 命令查看所有镜像，如果存在 REPOSITORY 为 nginx 和 TAG 是 v1 的信息，就表示构建成功。</p><p><a href="/images/1100338-20181015082853781-920978466.png" data-fancybox="group" data-caption="image" class="fancybox"><img alt="image" title="image" data-src="/images/1100338-20181015082853781-920978466.png" class="lazyload"></a></p><p>接下来使用 docker run 命令来启动容器</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name nginx_web -d -p 8080:80   angelkitty&#x2F;nginx_web:v1</span><br></pre></td></tr></table></figure></div><p>这条命令会用 nginx 镜像启动一个容器，命名为 nginx_web ，并且映射了 8080 端口，这样我们可以用浏览器去访问这个 nginx 服务器：<a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080/</a> 或者 http://本机的IP地址:8080/，页面返回信息：</p><p><a href="/images/1100338-20181015082853396-674842375.png" data-fancybox="group" data-caption="image" class="fancybox"><img alt="image" title="image" data-src="/images/1100338-20181015082853396-674842375.png" class="lazyload"></a></p><p>这样一个简单使用 Dockerfile 构建镜像，运行容器的示例就完成了！</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://yeasy.gitbooks.io/docker_practice/content/" target="_blank" rel="noopener" title="Docker — 从入门到实践">Docker — 从入门到实践</a></li><li><a href="http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html" target="_blank" rel="noopener" title="Docker 入门教程">Docker 入门教程</a></li></ul><p>作　　者：<a href="https://www.cnblogs.com/ECJTUACM-873284962/" target="_blank" rel="noopener">Angel_Kitty</a><br>出　　处：<a href="https://www.cnblogs.com/ECJTUACM-873284962/" target="_blank" rel="noopener">https://www.cnblogs.com/ECJTUACM-873284962/</a><br>关于作者：阿里云ACE，目前主要研究方向是Web安全漏洞以及反序列化。如有问题或建议，请多多赐教！ </p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown使用手册</title>
      <link href="/2019/12/31/2019-12-31-Markdown%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/"/>
      <url>/2019/12/31/2019-12-31-Markdown%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Markdown是什么？"><a href="#Markdown是什么？" class="headerlink" title="Markdown是什么？"></a>Markdown是什么？</h2><p>Markdown 是一种轻量级的<code>「标记语言」</code>，创始人为约翰·格鲁伯，用简洁的语法代替排版，目前被越来越多的知识工作者、写作爱好者、程序员或研究员广泛使用。其常用的标记符号不超过十个，相对于更为复杂的 HTML 标记语言来说，Markdown 十分的轻量，学习成本也不需要太多，且一旦熟悉这种语法规则，会有沉浸式编辑的效果。</p><p>除去本文档外，Markdown 本身支持的语法还有很多，这里只对 Rnss 团队日常可能会用到的，进行简要说明；</p><h2 id="支持的语法"><a href="#支持的语法" class="headerlink" title="支持的语法"></a>支持的语法</h2><h4 id="1，设置分级标题"><a href="#1，设置分级标题" class="headerlink" title="1，设置分级标题"></a>1，设置分级标题</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">#### 四级标题</span><br><span class="line">##### 五级标题</span><br><span class="line">###### 六级标题</span><br></pre></td></tr></table></figure></div><p>标题不做示例演示，会影响 TOC 目录的生成结果。</p><h4 id="2，加粗文本"><a href="#2，加粗文本" class="headerlink" title="2，加粗文本"></a>2，加粗文本</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">语法：** 我粗了 **</span><br></pre></td></tr></table></figure></div><p>示例：** 我粗了 **</p><h4 id="3，斜体"><a href="#3，斜体" class="headerlink" title="3，斜体"></a>3，斜体</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">语法：* 我弯了 *</span><br></pre></td></tr></table></figure></div><p>示例：* 我弯了 *</p><h4 id="4，下划线"><a href="#4，下划线" class="headerlink" title="4，下划线"></a>4，下划线</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">语法：&lt;u&gt;我有一双滑板&lt;&#x2F;u&gt;</span><br></pre></td></tr></table></figure></div><p>示例：<u>我有一双滑板</u></p><h4 id="5，删除线"><a href="#5，删除线" class="headerlink" title="5，删除线"></a>5，删除线</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">语法：~~我被干掉了~~</span><br></pre></td></tr></table></figure></div><p>示例：<del>我被干掉了</del></p><h4 id="6，添加分割线"><a href="#6，添加分割线" class="headerlink" title="6，添加分割线"></a>6，添加分割线</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">语法：*** 或 --- 或 ---- 或 *****</span><br></pre></td></tr></table></figure></div><p>示例：<br>我在上面</p><hr><hr><hr><hr><p>我在下面</p><h4 id="7，引用文本"><a href="#7，引用文本" class="headerlink" title="7，引用文本"></a>7，引用文本</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">&gt;锐仕方达（Risfond Executive Search）全称 北京锐仕方达人力资源集团有限公司，成立于2008年5月，总部设在北京。截至目前，锐仕方达在全球70余所城市设有127家分公司，是中国首家获得AAAA评级的猎头机构，员工规模将近4000人，是亚太地区领先的高端招聘服务机构。</span><br><span class="line">&gt;&gt;又是文字</span><br><span class="line">&gt;&gt;&gt;还是文字</span><br><span class="line">&gt;&gt;&gt;&gt;怎么老是文字</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;How are you</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;How old are you</span><br></pre></td></tr></table></figure></div><p>示例：</p><blockquote><p>锐仕方达（Risfond Executive Search）全称 北京锐仕方达人力资源集团有限公司，成立于2008年5月，总部设在北京。截至目前，锐仕方达在全球70余所城市设有127家分公司，是中国首家获得AAAA评级的猎头机构，员工规模将近4000人，是亚太地区领先的高端招聘服务机构。</p><blockquote><p>又是文字</p><blockquote><p>还是文字</p><blockquote><p>怎么老是文字</p><blockquote><p>How are you</p><blockquote><p>How old are you</p></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><h4 id="8，添加符号列表或者数字列表"><a href="#8，添加符号列表或者数字列表" class="headerlink" title="8，添加符号列表或者数字列表"></a>8，添加符号列表或者数字列表</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">1、数字列表</span><br><span class="line">1. 第一行内容</span><br><span class="line">2. 第二行内容</span><br><span class="line">    * 说明</span><br><span class="line">2、符号列表</span><br><span class="line">* 第一行内容</span><br><span class="line">* 第二行内容</span><br></pre></td></tr></table></figure></div><p>示例：<br>1、数字列表</p><ol><li>第一行内容</li><li>第二行内容<ul><li>说明</li></ul></li></ol><p>2、符号列表</p><ul><li>第一行内容</li><li>第二行内容</li></ul><h4 id="9，添加待办事项（复选框）"><a href="#9，添加待办事项（复选框）" class="headerlink" title="9，添加待办事项（复选框）"></a>9，添加待办事项（复选框）</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">* [x] 第一只青蛙-默认选中，且不能更改</span><br><span class="line">* [ ] 第二只青蛙</span><br></pre></td></tr></table></figure></div><p>示例：</p><ul><li><input checked disabled type="checkbox"> 第一只青蛙</li><li><input disabled type="checkbox"> 第二只青蛙</li></ul><h4 id="10，插入链接"><a href="#10，插入链接" class="headerlink" title="10，插入链接"></a>10，插入链接</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">语法：[锐仕方达官网](http:&#x2F;&#x2F;www.risfond.com&#x2F; &quot;title信息&quot;)</span><br><span class="line">title信息可选，非必填</span><br></pre></td></tr></table></figure></div><p>示例：<a href="http://www.risfond.com/" target="_blank" rel="noopener" title="我是官网链接">锐仕方达官网</a></p><h4 id="11，插入图片"><a href="#11，插入图片" class="headerlink" title="11，插入图片"></a>11，插入图片</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">语法：![图片说明文字](&#x2F;images&#x2F;head.jpg)</span><br><span class="line">注：Showdoc的图片，还支持直接从剪切板粘贴，会默认上传到本地服务器</span><br></pre></td></tr></table></figure></div><p>示例：<a href="/images/head.jpg" data-fancybox="group" data-caption="image" class="fancybox"><img alt="image" title="image" data-src="/images/head.jpg" class="lazyload"></a></p><h4 id="12，插入表格"><a href="#12，插入表格" class="headerlink" title="12，插入表格"></a>12，插入表格</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">&#x2F;&#x2F; ..这里必须有个空行</span><br><span class="line">| 参数名 | 必选 | 类型 | 说明 |</span><br><span class="line">| --- | --- | --- | --- |</span><br><span class="line">|username |是  |string |用户名   |</span><br><span class="line">|password |是  |string | 密码    |</span><br><span class="line">|name     |否  |string | 昵称    |</span><br></pre></td></tr></table></figure></div><p>示例：</p><table><thead><tr><th>参数名</th><th>必选</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>username</td><td>是</td><td>string</td><td>用户名</td></tr><tr><td>password</td><td>是</td><td>string</td><td>密码</td></tr><tr><td>name</td><td>否</td><td>string</td><td>昵称</td></tr></tbody></table><h4 id="13，设置目录"><a href="#13，设置目录" class="headerlink" title="13，设置目录"></a>13，设置目录</h4><p>设置之后可以自动根据设置的分级标题来自动生成目录。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">语法：[TOC]</span><br></pre></td></tr></table></figure></div><p>示例参考本文档头部的 [TOC] 标记</p><h4 id="14，插入代码块"><a href="#14，插入代码块" class="headerlink" title="14，插入代码块"></a>14，插入代码块</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">语法：&#96;单行代码&#96;</span><br><span class="line">-------------------</span><br><span class="line">多行代码：</span><br><span class="line">(&#96;&#96;&#96;)</span><br><span class="line">  function func() &#123;</span><br><span class="line">    return &quot;代码示例&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">(&#96;&#96;&#96;)</span><br><span class="line"></span><br><span class="line"> 这里的括号没有意义，只是为了防止转义，实际使用时：</span><br><span class="line">使用三个反引号开始：(&#96;&#96;&#96;)</span><br><span class="line"></span><br><span class="line">以三个反引号结束：(&#96;&#96;&#96;)</span><br></pre></td></tr></table></figure></div><p>示例：<br><code>我是单行代码</code></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; ..我是多行代码示例</span><br><span class="line">function func() &#123;</span><br><span class="line">return &quot;代码示例&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="15，插入流程图"><a href="#15，插入流程图" class="headerlink" title="15，插入流程图"></a>15，插入流程图</h4><p>Showdoc中使用 Markdown 的流程图，还有问题，分支不能正常显示，待补充。。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">注意：多个反引号之间保留了空格，防止被 Markdown 转义</span><br><span class="line">&#96; &#96;&#96;flow</span><br><span class="line">st&#x3D;&gt;start: 开始（注释1）</span><br><span class="line">op&#x3D;&gt;operation: 模块A（注释2）</span><br><span class="line">cond&#x3D;&gt;condition: Yes or No?（注释3）</span><br><span class="line">e&#x3D;&gt;end（注释4）</span><br><span class="line"></span><br><span class="line">st-&gt;op-&gt;cond（说明：从开始到长方形再到判断）</span><br><span class="line">cond(yes)-&gt;e （说明：判断为真的时候执行分支）</span><br><span class="line">cond(no)-&gt;op （说明：判断为假的时候执行分支）</span><br><span class="line">&amp;&#96; &#96;&#96;</span><br><span class="line">--</span><br><span class="line">注释：</span><br><span class="line">每行的前面为“别名”，不限制名称，比如：st、op、cond 都可以修改为其他值，但是需要跟下方分支使用的对应；</span><br><span class="line">--</span><br><span class="line">注释1：st&#x3D;&gt;start: 表示流程图的开始</span><br><span class="line">--</span><br><span class="line">注释2：op1&#x3D;&gt;operation: 定义一个特性形状的图形</span><br><span class="line">可选项有：</span><br><span class="line">operation - 长方形</span><br><span class="line">subroutine - 子程序</span><br><span class="line">inputoutput - 四边形</span><br><span class="line">--</span><br><span class="line">注释3：cond&#x3D;&gt;condition: 定义一个判断，与下方的 流程走向 定义对应</span><br><span class="line">--</span><br><span class="line">注释4：e&#x3D;&gt;end 流程图结束</span><br><span class="line">--</span><br></pre></td></tr></table></figure></div><p>示例：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">st&#x3D;&gt;start: 开始</span><br><span class="line">op&#x3D;&gt;operation: 模块A</span><br><span class="line">cond&#x3D;&gt;condition: Yes or No?</span><br><span class="line">e&#x3D;&gt;end: 结束</span><br><span class="line"></span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;op</span><br><span class="line">&amp;</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      
        <tags>
            
            <tag> -Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ElasticSearch的安装部署</title>
      <link href="/2019/12/31/2019-12-31-ElasticSearch%E7%9A%84%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2/"/>
      <url>/2019/12/31/2019-12-31-ElasticSearch%E7%9A%84%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>一.下载elasticsearch并解压  10服务器上有位置：E:\ES<br>二.打开elasticsearch目录的config文件夹<br><a href="/images/5d2548be161d2.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/5d2548be161d2.png" class="lazyload"></a><br>三.使用记事本打开elasticsearch.yml<br><a href="/images/5d2548f8d2371.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/5d2548f8d2371.png" class="lazyload"></a><br>四.找到network.host和http.port配置放问IP和端口<br>network.host    放问IP地址<br>http.port        放问端口<br>五.命令行进入解压目录的bin文件夹<br><a href="/images/5d2548798fb4e.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/5d2548798fb4e.png" class="lazyload"></a><br>六：双击elasticsearch.bat为启动ES服务 关闭窗口则ES服务关闭<br><a href="/images/5d254994e02f5.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/5d254994e02f5.png" class="lazyload"></a><br>七：系统注册ES服务：命令行输入elasticsearch-service.bat install<br><a href="/images/5d254a008c87b.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/5d254a008c87b.png" class="lazyload"></a><br>八：打开浏览器输入配置的IP和端口，如出现下图提示则启动成功<br><a href="/images/5d254a422ef52.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/5d254a422ef52.png" class="lazyload"></a></p>]]></content>
      
      
      <categories>
          
          <category> ElasticSearch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分词 </tag>
            
            <tag> ElasticSearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SignalR的使用（二）</title>
      <link href="/2019/12/31/2019-12-31-SignalR%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2019/12/31/2019-12-31-SignalR%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>[TOC]</p><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://baike.baidu.com/item/SignalR/5935910" target="_blank" rel="noopener">SignalR</a></p><h4 id="2-文档"><a href="#2-文档" class="headerlink" title="2. 文档"></a>2. 文档</h4><p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://192.168.30.10:8888/index.php?s=/9&page_id=1134" target="_blank" rel="noopener">传输方式</a></p><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3. 代码"></a>3. 代码</h4><p>1.引用Nuget包Microsoft.AspNet.SignalR（MVC项目自带）</p><p>2.在App_Start文件夹下的Startup.cs（没有则新建）中添加代码</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">csharp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configuration</span>(<span class="params">IAppBuilder app</span>)</span></span><br><span class="line"><span class="function"></span>  &#123;</span><br><span class="line">  app.MapSignalR();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></div><p>3.新建集成器Hub，示例代码</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">csharp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">HubName(<span class="meta-string">"DataPushHub"</span>)</span>]</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DataPushHub</span> : <span class="title">Hub</span></span><br><span class="line"> &#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ResumeCount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="comment">//注意：客户端方法首字母必须小写</span></span><br><span class="line">       Clients.All.getResumeCount(<span class="keyword">new</span> &#123; Count = <span class="number">10000</span> &#125;);</span><br><span class="line">&#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></div><p>4.新建控制器，示例代码</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">csharp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestSignalRController</span> : <span class="title">Controller</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// GET: TestSignalR</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ActionResult <span class="title">Index</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> View();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> ActionResult <span class="title">ResumeCount</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> Json(<span class="keyword">new</span> &#123; Count= <span class="number">100</span>,TodayCount=<span class="number">10</span> &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></div><p>5.在页面中引入signalR相关js</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">javascript</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"~/Scripts/jquery-3.3.1.min.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;script src=<span class="string">"~/Scripts/jquery.signalR-2.4.0.min.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;script src=<span class="string">"~/signalr/hubs"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">分别是：</span><br><span class="line">Jquery的js文件、SignalR的js文件、页面运行后SignalR自动生成的js文件：</span><br></pre></td></tr></table></figure></div><p>6.服务端js的用法（增删改操作）</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">javascript</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 引用自动生成的集线器代理</span></span><br><span class="line"><span class="keyword">var</span> pushHub = $.connection.DataPushHub;</span><br><span class="line"><span class="comment">// 集成器连接开始</span></span><br><span class="line">$.connection.hub.start().done(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">pushHub.server.resumeCount();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div><p>7.客户端展示js的用法</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">javascript</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">   $(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="keyword">var</span> pushHub = $.connection.DataPushHub;</span><br><span class="line">     <span class="comment">// 集成器连接开始</span></span><br><span class="line">     $.connection.hub.start().done();</span><br><span class="line">     pushHub.client.ClientResumeCount = <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">       <span class="comment">// 服务端推送，客户端刷新数据</span></span><br><span class="line">       $(<span class="string">"#h1"</span>).html(<span class="string">"总简历数量："</span> + data.Count);</span><br><span class="line">     &#125;;</span><br><span class="line">   &#125;);</span><br><span class="line"> &lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> C# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> SignalR </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SignalR的使用（一）</title>
      <link href="/2019/12/31/2019-12-31-SignalR%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2019/12/31/2019-12-31-SignalR%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>[TOC]</p><h4 id="1-传输方式"><a href="#1-传输方式" class="headerlink" title="1.传输方式"></a>1.传输方式</h4><ul><li>它封装了 WebSocket、ServerSentEvents、ForeverFrame、LongPolling四种主要的传输协议， 默认(优先级)使用webSockets–&gt;ServerSentEvents–&gt;ForeverFrame–&gt;LongPolling。</li></ul><h5 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h5><ul><li>WebSocket 是唯一的能够支持服务器和客户端建立真正持久的双向连接的传输方式，但是就是WebSocket要求的条件比较苛刻。WebSocket真正能够支持只是在最新的IE 浏览器、Chrome、Firefox和一些其他的浏览器比如Opera 和 Safari。（前提是服务器和客户端都可以支持WebSocket ）。</li></ul><h5 id="SeverSentEvents"><a href="#SeverSentEvents" class="headerlink" title="SeverSentEvents"></a>SeverSentEvents</h5><ul><li>SeverSentEvents（服务器发送事件，也成EventSourse）：（除了IE的其他浏览器都支持支持服务器发送事件）。</li><li>请求如下<br><a href="http://192.168.30.10:8888/Public/Uploads/2019-04-11/5caeff369f3f0.png" data-fancybox="group" data-caption="请求报文" class="fancybox"><img alt="请求报文" title="请求报文" data-src="http://192.168.30.10:8888/Public/Uploads/2019-04-11/5caeff369f3f0.png" class="lazyload"></a></li><li>服务器每10秒请求一下客户端，心跳机制，监测客户端是否正常<br><a href="http://192.168.30.10:8888/Public/Uploads/2019-04-11/5caeff5f7a18e.png" data-fancybox="group" data-caption="EventSourse" class="fancybox"><img alt="EventSourse" title="EventSourse" data-src="http://192.168.30.10:8888/Public/Uploads/2019-04-11/5caeff5f7a18e.png" class="lazyload"></a></li></ul><h5 id="LongPolling"><a href="#LongPolling" class="headerlink" title="LongPolling"></a>LongPolling</h5><ul><li>客户端向服务器发送Ajax请求，服务器接到请求后hold住连接，直到有新消息才返回响应信息并关闭连接，客户端处理完响应信息后再向服务器发送新的请求。<br>优点：在无消息的情况下不会频繁的请求，耗费资源小。<br>缺点：服务器hold连接会消耗资源，返回数据顺序无保证，难于管理维护。<br>实例：WebQQ、Hi网页版、Facebook IM。<br><a href="https://www.cnblogs.com/YangJieCheng/p/8367586.html" target="_blank" rel="noopener">DEMO</a></li></ul><h5 id="ForeverFrame"><a href="#ForeverFrame" class="headerlink" title="ForeverFrame"></a>ForeverFrame</h5><ul><li>ForeverFrame(永久帧)：（只有IE浏览器支持）Forever Frame 会创建一个隐藏的IFrame ，这个IFrame 会向服务器发起一个端点请求，但是这个请求不会结束。服务器会不停的发送脚本到客户端马上执行，提供一个从服务器端到客户端的单向实时连接。服务端到客户端和客户端到服务端分别是两个不同的连接，就像一个标准的HTTP请求，一旦有数据需要发送就会创建一个新的连接。<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">html</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SignalR会在IE中自动生成以下标签：</span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"http://192.168.30.7/signalr/connect?transport=foreverFrame<span class="symbol">&amp;amp;</span>clientProtocol=1.5<span class="symbol">&amp;amp;</span>connectionToken=uPeYPZnekRNWhTLhyiEXl6TWzFeMX0x4qcWFpG8LH9Fv%2F9wyj3Sv1B%2BMKTKHctToWw4%2BMcQHcvyI3UTKoKQjIEf9DS6qQgbZ2gTenpOTFqhDD%2BhjSrJRbfyYa0cWzgoV<span class="symbol">&amp;amp;</span>connectionData=%5B%7B%22name%22%3A%22clientreporthub%22%7D%5D<span class="symbol">&amp;amp;</span>tid=7<span class="symbol">&amp;amp;</span>frameId=1"</span> <span class="attr">style</span>=<span class="string">"position:absolute;top:0;left:0;width:0;height:0;visibility:hidden;"</span> <span class="attr">data-signalr-connection-id</span>=<span class="string">"e5af768c-405a-40e3-840b-4e54e7d504a7"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure></div></li></ul><h4 id="2-指定传输方式"><a href="#2-指定传输方式" class="headerlink" title="2.指定传输方式"></a>2.指定传输方式</h4><p><code>conn.start({ transport: &#39;serverSentEvents&#39; }).done(function () {});</code></p><h4 id="3-传输过程选择"><a href="#3-传输过程选择" class="headerlink" title="3.传输过程选择"></a>3.传输过程选择</h4><ol><li>如果浏览器是 Internet Explorer 8 或更早版本，则使用长轮询。</li><li>如果配置 JSONP (即jsonp参数设置为true启动连接时)，使用长轮询。</li><li>如果操作正在进行的跨域连接，(即，如果 SignalR 终结点不在托管的页面所在的域中)，<br>然后 WebSocket 将在满足以下条件：</li><ul><li>客户端支持 CORS （跨域资源共享）</li><li>客户端支持 WebSocket</li><li>服务器支持 WebSocket</li></ul><li>如果未配置 JSONP 并且连接不跨域，如果客户端和服务器支持它，则将使用 WebSocket。</li><li>如果客户端或服务器不支持 WebSocket，如果可用，则使用服务器发送事件。</li><li>如果服务器发送事件不可用，请尝试使用永久帧。</li><li>如果永久帧失败，则使用长轮询。</li></ol><h4 id="4-相关文档"><a href="#4-相关文档" class="headerlink" title="4.相关文档"></a>4.相关文档</h4><p> <a href="https://www.cnblogs.com/yaopengfei/category/1202154.html" target="_blank" rel="noopener">https://www.cnblogs.com/yaopengfei/category/1202154.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> C# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> SignalR </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PC常用软件分享</title>
      <link href="/2019/12/23/2019-12-23-PC%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6%E5%88%86%E4%BA%AB/"/>
      <url>/2019/12/23/2019-12-23-PC%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6%E5%88%86%E4%BA%AB/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>自己常用的几款软件，PC端很实用！不提供下载链接，请自行百度。<br>1.录屏软件-Captura<br>Github 主页：<a href="https://github.com/MathewSachin/Captura/" target="_blank" rel="noopener">https://github.com/MathewSachin/Captura/</a><br>2.音乐软件-Listen1<br>Github 主页：<a href="https://github.com/listen1" target="_blank" rel="noopener">https://github.com/listen1</a><br>3.磁盘分区-DiskGenius5.0<br>4.磁盘清理工具-CCleaner_Pro<br>5.电脑文件图形化-SpaceSniffer<br>6.解压缩软件-winrar<br>7.文件批量改名王1.3<br>8.图标提取BeCyIconGrabber<br>9.Xshell and WinSCP<br>10.win10优化工具-Dism++<br>官网链接 <a href="https://www.chuyu.me/zh-Hans/index.html" target="_blank" rel="noopener">https://www.chuyu.me/zh-Hans/index.html</a><br>11.下载工具-IDM</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Python笔记之模拟键盘鼠标操作</title>
      <link href="/2019/12/04/2019-12-04-Python%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%A8%A1%E6%8B%9F%E9%94%AE%E7%9B%98%E9%BC%A0%E6%A0%87%E6%93%8D%E4%BD%9C/"/>
      <url>/2019/12/04/2019-12-04-Python%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%A8%A1%E6%8B%9F%E9%94%AE%E7%9B%98%E9%BC%A0%E6%A0%87%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>前言：因为手上有两张电话卡，一张是接收验证码用的，而短信转发用的软件是mysms，不巧的是这款软件在ios端无法批量删除短信，好在可以在PC上的web页面处理，可惜仍无法批量操作，所以就有了下面这个简单的小脚本<br>程序内容：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">from pykeyboard import *</span><br><span class="line">from pymouse import *</span><br><span class="line">import time</span><br><span class="line">m&#x3D;PyMouse()</span><br><span class="line">k&#x3D;PyKeyboard()</span><br><span class="line">for i in range(50):</span><br><span class="line">    m.click(254,642,2)</span><br><span class="line">    time.sleep(1)</span><br><span class="line">    m.click(304,728,1)</span><br><span class="line">    time.sleep(1)</span><br><span class="line">    k.tap_key(k.enter_key)</span><br><span class="line">    time.sleep(4)</span><br></pre></td></tr></table></figure></div><p>很简单的一段程序，但是可以批量的完成一些重复的工作，比如删短信。</p><h2 id="脚本使用前提"><a href="#脚本使用前提" class="headerlink" title="脚本使用前提"></a>脚本使用前提</h2><h3 id="安装pyhook"><a href="#安装pyhook" class="headerlink" title="安装pyhook"></a>安装pyhook</h3><p><a href="https://www.lfd.uci.edu/~gohlke/pythonlibs/" target="_blank" rel="noopener">https://www.lfd.uci.edu/~gohlke/pythonlibs/</a><br>根据Python版本下载对于的whl文件<br>pyHook‑1.5.1‑cp37‑cp37m‑win_amd64.whl<br>pip install pyHook‑1.5.1‑cp37‑cp37m‑win_amd64.whl</p><h3 id="安装pyuserinput"><a href="#安装pyuserinput" class="headerlink" title="安装pyuserinput"></a>安装pyuserinput</h3><p>pip install pyuserinput</p><h2 id="一些方法介绍（搬运）"><a href="#一些方法介绍（搬运）" class="headerlink" title="一些方法介绍（搬运）"></a>一些方法介绍（搬运）</h2><h3 id="鼠标操作："><a href="#鼠标操作：" class="headerlink" title="鼠标操作："></a>鼠标操作：</h3><p>m.click(x,y,button,n) 鼠标点击<br>x,y 是坐标位置<br>buttong 1表示左键，2表示点击右键<br>n 点击次数，默认是1次，2表示双击</p><p>m.move(x,y) –鼠标移动到坐标(x,y)<br>坐标可以通过QQ截图获取，在左上角开始点击，然后移动到需要点击位置就可以获取了<br>x_dim, y_dim = m.screen_size() –获得屏幕尺寸</p><h3 id="键盘操作："><a href="#键盘操作：" class="headerlink" title="键盘操作："></a>键盘操作：</h3><p>k.type_string(‘Hello, World!’) –模拟键盘输入字符串<br>k.press_key(‘H’) –模拟键盘按H键<br>k.release_key(‘H’) –模拟键盘松开H键<br>k.tap_key(“H”) –模拟点击H键<br>k.tap_key(‘H’,n=2,interval=5) –模拟点击H键，2次，每次间隔5秒<br>k.tap_key(k.function_keys[5]) –点击功能键F5<br>k.tap_key(k.numpad_keys[5],3) –点击小键盘5,3次</p><h3 id="联合按键模拟"><a href="#联合按键模拟" class="headerlink" title="联合按键模拟"></a>联合按键模拟</h3><p>例如同时按alt+tab键盘<br>k.press_key(k.alt_key) –按住alt键<br>k.tap_key(k.tab_key) –点击tab键<br>k.release_key(k.alt_key) –松开alt键</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Git技巧总结(持续更新)</title>
      <link href="/2019/10/17/2019-10-17-Git%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"/>
      <url>/2019/10/17/2019-10-17-Git%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-git设置快捷脚本"><a href="#1-git设置快捷脚本" class="headerlink" title="1.git设置快捷脚本"></a>1.git设置快捷脚本</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global alias.bp &#39;!hexo clean;hexo g;gulp g;hexo d&#39;</span><br></pre></td></tr></table></figure></div><p>然后使用 git bpush 就可以一键更新博客并发布了(cd 后面的目录为你的博客文件目录）<br>取消方式</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global --unset alias.bpush</span><br></pre></td></tr></table></figure></div><h2 id="2-git快速push-不推荐使用"><a href="#2-git快速push-不推荐使用" class="headerlink" title="2.git快速push(不推荐使用)"></a>2.git快速push(不推荐使用)</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global alias.fp &#39;!git add .;git commit -m &quot;快速push&quot;;git push&#39;</span><br></pre></td></tr></table></figure></div><p>使用方式 git fp 就可以直接三连，但是无法手写commit信息</p>]]></content>
      
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>修改transmission配置，实现远程访问transmission</title>
      <link href="/2019/09/03/2019-09-03-%E4%BF%AE%E6%94%B9transmission%E9%85%8D%E7%BD%AE%EF%BC%8C%E5%AE%9E%E7%8E%B0%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE/"/>
      <url>/2019/09/03/2019-09-03-%E4%BF%AE%E6%94%B9transmission%E9%85%8D%E7%BD%AE%EF%BC%8C%E5%AE%9E%E7%8E%B0%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>如果没有修改下面设置也是能打开transmission的web界面，但是你会发现一片空白，提示正在连接服务器。<br>transmission实现远程访问要开启rpc-authentication-required</p><h1 id="设置方法"><a href="#设置方法" class="headerlink" title="设置方法"></a>设置方法</h1><p>找到transmission安装目录内的settings.json文件<br>使用notepad++或者sublime等文本编辑软件打开<br>修改以下地方：（大约在第43行开始）<br>1.将rpc-authentication-required和rpc-enabled修改为true，启用认证功能<br>2.rpc-username后设置为你的登录用户名<br>3.rpc-password后设置为你的密码<br>4.其他的就按下面的配置修改即可</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&quot;rpc-authentication-required&quot;: true,</span><br><span class="line">&quot;rpc-bind-address&quot;: &quot;0.0.0.0&quot;,</span><br><span class="line">&quot;rpc-enabled&quot;: true,</span><br><span class="line">&quot;rpc-host-whitelist&quot;: &quot;&quot;,</span><br><span class="line">&quot;rpc-host-whitelist-enabled&quot;: true,</span><br><span class="line">&quot;rpc-password&quot;: &quot;123456&quot;,</span><br><span class="line">&quot;rpc-port&quot;: 9091,</span><br><span class="line">&quot;rpc-url&quot;: &quot;&#x2F;transmission&#x2F;&quot;,</span><br><span class="line">&quot;rpc-username&quot;: &quot;admin&quot;,</span><br><span class="line">&quot;rpc-whitelist&quot;: &quot;&quot;,</span><br><span class="line">&quot;rpc-whitelist-enabled&quot;: false,</span><br></pre></td></tr></table></figure></div><p>这个配置的用户名为admin 密码为123456<br>注：密码修改后重启transmission，然后打开settings.json文件，rpc-password会变成了一串加密密钥。</p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> transmission </tag>
            
            <tag> 远程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS更换国内yum源</title>
      <link href="/2019/08/28/2019-08-28-%E3%80%90Linux%E3%80%91CentOS%E6%9B%B4%E6%8D%A2%E5%9B%BD%E5%86%85yum%E6%BA%90/"/>
      <url>/2019/08/28/2019-08-28-%E3%80%90Linux%E3%80%91CentOS%E6%9B%B4%E6%8D%A2%E5%9B%BD%E5%86%85yum%E6%BA%90/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>每次都去百度地址太费劲了，所以整理一下地址</p><h2 id="更换方法"><a href="#更换方法" class="headerlink" title="更换方法"></a>更换方法</h2><p>1.备份默认yum源</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;etc&#x2F;yum.repos.d</span><br><span class="line">mv CentOS-Base.repo CentOS-Base.repo.bak</span><br></pre></td></tr></table></figure></div><p>2.下载更换国内yum源<br>阿里</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;repo&#x2F;Centos-7.repo</span><br><span class="line">mv Centos-7.repo CentOS-Base.repo</span><br></pre></td></tr></table></figure></div><p>网易</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget http:&#x2F;&#x2F;mirrors.163.com&#x2F;.help&#x2F;CentOS7-Base-163.repo</span><br><span class="line">mv CentOS7-Base-163.repo CentOS-Base.repo</span><br></pre></td></tr></table></figure></div><p>3.清理缓存</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum clean all</span><br></pre></td></tr></table></figure></div><p>4.重建缓存</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum makecache</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Contos </tag>
            
            <tag> yum </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac OS 下Sublime Text 3 编译C++</title>
      <link href="/2019/06/27/2019-06-27-Sublime-Text-3-%E6%96%B0%E5%BB%BA%E7%BC%96%E8%AF%91%E7%B3%BB%E7%BB%9F%E7%9A%84%E9%BB%98%E8%AE%A4%E4%BF%9D%E5%AD%98%E7%9B%AE%E5%BD%95/"/>
      <url>/2019/06/27/2019-06-27-Sublime-Text-3-%E6%96%B0%E5%BB%BA%E7%BC%96%E8%AF%91%E7%B3%BB%E7%BB%9F%E7%9A%84%E9%BB%98%E8%AE%A4%E4%BF%9D%E5%AD%98%E7%9B%AE%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="设置步骤"><a href="#设置步骤" class="headerlink" title="设置步骤"></a>设置步骤</h2><p> 1.工具-&gt;编译系统-&gt;新建编译系统<br>然后将下面的内容复制到新打开的文件<br>保存时的文件名为XXX.sublime-build ,其中XXX为工具-&gt;编译系统中显示的文件名</p><p>Mac下的编译系统文件</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;cmd&quot;: [&quot;g++&quot;, &quot;$&#123;file&#125;&quot;, &quot;-o&quot;, &quot;$&#123;file_path&#125;&#x2F;$&#123;file_base_name&#125;&quot;],</span><br><span class="line">    &quot;file_regex&quot;: &quot;^(..[^:]*):([0-9]+):?([0-9]+)?:? (.*)$&quot;,</span><br><span class="line">    &quot;working_dir&quot;: &quot;$&#123;file_path&#125;&quot;,</span><br><span class="line">    &quot;selector&quot;: &quot;source.c, source.c++&quot;,</span><br><span class="line"></span><br><span class="line">    &quot;variants&quot;:</span><br><span class="line">    [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;Run&quot;,</span><br><span class="line">            &quot;cmd&quot;: [&quot;bash&quot;, &quot;-c&quot;, &quot;g++ -std&#x3D;c++11 &#39;$&#123;file&#125;&#39; -o &#39;a&#39; &amp;&amp; open -a terminal &#39;$&#123;file_path&#125;&#x2F;a&#39;&quot;]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>Win10下的编译系统文件：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;   </span><br><span class="line">  &quot;encoding&quot;: &quot;utf-8&quot;,  </span><br><span class="line">  &quot;working_dir&quot;: &quot;$file_path&quot;,  </span><br><span class="line">  &quot;shell_cmd&quot;: &quot;g++ -Wall \&quot;$file_name\&quot; -o \&quot;$file_base_name\&quot;&quot;,   </span><br><span class="line">  &quot;file_regex&quot;: &quot;^(..[^:]*):([0-9]+):?([0-9]+)?:? (.*)$&quot;,            </span><br><span class="line">  &quot;selector&quot;: &quot;source.c++&quot;,     </span><br><span class="line">  &quot;variants&quot;:   </span><br><span class="line">  [     </span><br><span class="line">    &#123;           </span><br><span class="line">      &quot;name&quot;: &quot;Run&quot;,            </span><br><span class="line">      &quot;shell_cmd&quot;: &quot;g++ -Wall  \&quot;$file\&quot; -o \&quot;$file_base_name\&quot; &amp;&amp; start cmd &#x2F;c \&quot;\&quot;$&#123;file_path&#125;&#x2F;$&#123;file_base_name&#125;\&quot; &amp; pause\&quot;&quot;     </span><br><span class="line">    &#125;   </span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="Sublime-Text-3-新建编译系统的默认保存目录"><a href="#Sublime-Text-3-新建编译系统的默认保存目录" class="headerlink" title="Sublime Text 3 新建编译系统的默认保存目录"></a>Sublime Text 3 新建编译系统的默认保存目录</h2><p>要先显示隐藏的目录和文件</p><p>MAC OS⁩ ▸ ⁨用户⁩ ▸ ⁨xxx ▸ ⁨资源库⁩ ▸ ⁨Application Support⁩ ▸ ⁨Sublime Text 3⁩ ▸ ⁨Packages⁩ ▸ ⁨User⁩<br>注：<br>MAC OS修改为你的磁盘名<br>sxz修改为你的用户名</p>]]></content>
      
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mac </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>清除Win10系统Windows Defender中病毒扫描记录</title>
      <link href="/2019/06/23/2019-06-23-%E6%B8%85%E9%99%A4Win10%E7%B3%BB%E7%BB%9FWindows-Defender%E4%B8%AD%E7%97%85%E6%AF%92%E6%89%AB%E6%8F%8F%E8%AE%B0%E5%BD%95/"/>
      <url>/2019/06/23/2019-06-23-%E6%B8%85%E9%99%A4Win10%E7%B3%BB%E7%BB%9FWindows-Defender%E4%B8%AD%E7%97%85%E6%AF%92%E6%89%AB%E6%8F%8F%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在使用一些小工具，小软件的时候 ⁨Windows Defender⁩经常提示木马或者病毒，而扫描到的病毒记录又没有清除按钮，让一些强迫症患者很难受。终于找到了扫描的历史记录位置，终于可以告别右下角的黄色叹号了。<br>文件位置<br>C:\ProgramData⁩\Microsoft⁩\Windows Defender⁩\Scans⁩\History⁩\Service⁩\DetectionHistory⁩<br>ProgramData⁩十个隐藏目录，查看隐藏目录也很简单，鼠标点两下就可以。<br><a href="https://raw.githubusercontent.com/sxz799/blog_tuchuang/master/img/20190623204037.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img width="600px" data-src="https://raw.githubusercontent.com/sxz799/blog_tuchuang/master/img/20190623204037.png" class="lazyload"></a></p>]]></content>
      
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Centos配置本地yum源</title>
      <link href="/2019/06/19/2019-06-19-Centos%E9%85%8D%E7%BD%AE%E6%9C%AC%E5%9C%B0yum%E6%BA%90/"/>
      <url>/2019/06/19/2019-06-19-Centos%E9%85%8D%E7%BD%AE%E6%9C%AC%E5%9C%B0yum%E6%BA%90/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>一、挂载镜像文件</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir &#x2F;mnt&#x2F;cdrom</span><br><span class="line">mount &#x2F;dev&#x2F;cdrom &#x2F;mnt&#x2F;cdrom</span><br></pre></td></tr></table></figure></div><p>二、修改yum源配置文件</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;etc&#x2F;yum.repo.d</span><br><span class="line">rm -rf *.repo</span><br><span class="line">vi &#x2F;etc&#x2F;yum.repo.d&#x2F;Localyum.repo</span><br></pre></td></tr></table></figure></div><p>内容为：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[localyum]</span><br><span class="line">name&#x3D;localyum</span><br><span class="line">baseurl&#x3D;file:&#x2F;&#x2F;&#x2F;mnt&#x2F;cdrom</span><br><span class="line">gpgcheck&#x3D;0</span><br><span class="line">enabled&#x3D;1</span><br></pre></td></tr></table></figure></div><p>三、清空并重建缓存</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum clean all</span><br><span class="line">yum makecache</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MongoDB学习（一）</title>
      <link href="/2019/05/16/MongoDB%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2019/05/16/MongoDB%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="MongoDB简介"><a href="#MongoDB简介" class="headerlink" title="MongoDB简介"></a>MongoDB简介</h1><h2 id="什么是MongoDB"><a href="#什么是MongoDB" class="headerlink" title="什么是MongoDB"></a>什么是MongoDB</h2><p>MongoDB 是一个跨平台的，面向文档的数据库，是当前 NoSQL 数据库产品中最热门的一种。它介于关系数据库和非关系数据库之间，是非关系数据库当中功能最丰富，最像关系数据库的产品。它支持的数据结构非常松散，是类似 JSON 的 BSON 格式，因此可以存储比较复杂的数据类型。</p><h2 id="MongoDB特点"><a href="#MongoDB特点" class="headerlink" title="MongoDB特点"></a>MongoDB特点</h2><p>MongoDB 最大的特点是他支持的查询语言非常强大，其语法有点类似于面向对象的查询语言，几乎可以实现类似关系数据库单表查询的绝大部分功能，而且还支持对数据建立索引。它是一个面向集合的,模式自由的文档型数据库。具体特点总结如下：</p><blockquote><ol><li>面向集合存储，易于存储对象类型的数据</li><li>模式自由</li><li>支持动态查询</li><li>支持完全索引，包含内部对象</li><li>支持复制和故障恢复</li><li>使用高效的二进制数据存储，包括大型对象（如视频等）</li><li>自动处理碎片，以支持云计算层次的扩展性</li><li>支持 Python，PHP，Ruby，Java，C，C#，Javascript，Perl 及 C++语言的驱动程序，社区中也提供了对 Erlang 及.NET 等平台的驱动程序</li><li>文件存储格式为 BSON（一种 JSON 的扩展）</li></ol></blockquote><h2 id="MongoDB的体系结构"><a href="#MongoDB的体系结构" class="headerlink" title="MongoDB的体系结构"></a>MongoDB的体系结构</h2><p>MongoDB 的逻辑结构是一种层次结构。主要由：<font color="red">文档(document)、集合(collection)、数据库(database)</font> 这三部分组成的。逻辑结构是面向用户的，用户使用 MongoDB 开发应用程序使用的就是逻辑结构。</p><blockquote><ol><li>MongoDB 的文档（document），相当于关系数据库中的一行记录。</li><li>多个文档组成一个集合（collection），相当于关系数据库的表。</li><li>多个集合（collection），逻辑上组织在一起，就是数据库（database）。</li><li>一个 MongoDB 实例支持多个数据库（database）。</li></ol></blockquote><p>文档(document)、集合(collection)、数据库(database)的层次结构如下图:</p><p><a href="/images/20180711135831295.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/20180711135831295.png" class="lazyload"></a></p><p>MongoDB与MySQL数据库逻辑结构概念对比如下：</p><p><a href="/images/20180711135923828.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/20180711135923828.png" class="lazyload"></a></p><h2 id="MongoDB的数据类型"><a href="#MongoDB的数据类型" class="headerlink" title="MongoDB的数据类型"></a>MongoDB的数据类型</h2><p><strong><font color="red">null：</font></strong>用于表示空值或者不存在的字段，{“x”:null}</p><p><strong><font color="red">布尔型：</font></strong>布尔类型有两个值true和false，{“x”:true}</p><p><strong><font color="red">数值：</font></strong>shell默认使用64为浮点型数值。{“x”：3.14}或{“x”：3}。对于整型值，可以使用NumberInt（4字节符号整数）或NumberLong（8字节符号整数），{“x”:NumberInt(“3”)}{“x”:NumberLong(“3”)}</p><p><strong><font color="red">字符串：</font></strong>UTF-8字符串都可以表示为字符串类型的数据，{“x”：“呵呵”}</p><p><strong><font color="red">日期：</font></strong>日期被存储为自新纪元依赖经过的毫秒数，不存储时区，{“x”:new Date()}</p><p><strong><font color="red">正则表达式：</font></strong>查询时，使用正则表达式作为限定条件，语法与JavaScript的正则表达式相同，{“x”:/[abc]/}</p><p><strong><font color="red">数组：</font></strong>数据列表或数据集可以表示为数组，{“x”： [“a“，“b”,”c”]}</p><p><strong><font color="red">内嵌文档：</font></strong>文档可以嵌套其他文档，被嵌套的文档作为值来处理，{“x”:{“y”:3 }}</p><p><strong><font color="red">对象Id：</font></strong>对象id是一个12字节的字符串，是文档的唯一标识，{“x”: objectId() }</p><p><strong><font color="red">二进制数据：</font></strong>二进制数据是一个任意字节的字符串。它不能直接在shell中使用。如果要将非utf-字符保存到数据库中，二进制数据是唯一的方式。</p><h1 id="MongoDB的安装与使用"><a href="#MongoDB的安装与使用" class="headerlink" title="MongoDB的安装与使用"></a>MongoDB的安装与使用</h1><h2 id="Windows下MongoDB的安装及配置"><a href="#Windows下MongoDB的安装及配置" class="headerlink" title="Windows下MongoDB的安装及配置"></a>Windows下MongoDB的安装及配置</h2><p>MongoDB下载路径：<a href="https://download.csdn.net/download/wingzhezhe/10534774" target="_blank" rel="noopener">下载</a></p><h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><p><a href="/images/20180711141253965.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/20180711141253965.png" class="lazyload"></a></p><h3 id="启动MongoDB服务"><a href="#启动MongoDB服务" class="headerlink" title="启动MongoDB服务"></a>启动MongoDB服务</h3><p><strong><font color="red">注意</font></strong>：启动之前需要创建数据目录</p><p><a href="/images/20180711141625832.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/20180711141625832.png" class="lazyload"></a></p><h3 id="连接MongoDB"><a href="#连接MongoDB" class="headerlink" title="连接MongoDB"></a>连接MongoDB</h3><p><a href="/images/20180711141940896.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/20180711141940896.png" class="lazyload"></a></p><h2 id="Docker中安装MongoDB"><a href="#Docker中安装MongoDB" class="headerlink" title="Docker中安装MongoDB"></a>Docker中安装MongoDB</h2><h3 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull mongo</span><br></pre></td></tr></table></figure></div><h3 id="启动守护式容器"><a href="#启动守护式容器" class="headerlink" title="启动守护式容器"></a>启动守护式容器</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -di --name&#x3D;tensquare_mongo -p 27017:27017 mongo</span><br></pre></td></tr></table></figure></div><p><a href="/images/20180711142746338.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/20180711142746338.png" class="lazyload"></a></p><h3 id="远程连接MongoDB数据库"><a href="#远程连接MongoDB数据库" class="headerlink" title="远程连接MongoDB数据库"></a>远程连接MongoDB数据库</h3><p><a href="/images/20180711163511441.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/20180711163511441.png" class="lazyload"></a></p><h2 id="MongoDB常用命令"><a href="#MongoDB常用命令" class="headerlink" title="MongoDB常用命令"></a>MongoDB常用命令</h2><h3 id="选择和创建数据库"><a href="#选择和创建数据库" class="headerlink" title="选择和创建数据库"></a>选择和创建数据库</h3><p><strong><font color="red">语法：</font></strong> use 数据库名称</p><p><strong><font color="red">说明：</font></strong>如果数据库不存在，会默认创建数据库</p><p><a href="/images/20180711163734232.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/20180711163734232.png" class="lazyload"></a></p><h3 id="插入与查询文档"><a href="#插入与查询文档" class="headerlink" title="插入与查询文档"></a>插入与查询文档</h3><p>插入文档的语法：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.集合名称.insert(数据);</span><br></pre></td></tr></table></figure></div><p>查询集合的语法：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-- 查询所有</span><br><span class="line">db.集合名称.find()</span><br><span class="line"> </span><br><span class="line">-- 带条件查询</span><br><span class="line">db.集合名称.find(&#123;字段名:条件值&#125;)</span><br><span class="line"> </span><br><span class="line">-- 查询符合条件的第一条数据</span><br><span class="line">db.集合名称.findOne(&#123;字段名:条件值&#125;)</span><br><span class="line"> </span><br><span class="line">-- 指定返回结果的数量</span><br><span class="line">db.集合名称.find().limit(3)</span><br></pre></td></tr></table></figure></div><p><a href="/images/20180711164420660.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/20180711164420660.png" class="lazyload"></a></p><p><strong><font color="red">注意：</font></strong>每条文档会有一个叫<font color="red">_id</font>的字段，这个相当于我们原来关系数据库中表的主键，当你在插入文档记录时没有指定该字段，MongoDB会自动创建，其类型是ObjectID类型。如果我们在插入文档记录时指定该字段也可以，其类型可以是<font color="red">ObjectID</font>类型，也可以是MongoDB支持的任意类型。</p><h3 id="修改与删除文档"><a href="#修改与删除文档" class="headerlink" title="修改与删除文档"></a>修改与删除文档</h3><p>修改文档的语法：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-- 修改文档，此种方式修改后，没有修改的字段都会删除</span><br><span class="line">db.集合名称.update(&#123;条件字段:条件值&#125;, &#123;要修改的字段:修改后的数据值&#125;)</span><br><span class="line"> </span><br><span class="line">-- 使用 $set 修改器来修改，保证只修改要指定的字段，其它字段保持原值</span><br><span class="line">db.集合名称.update(&#123;条件字段:条件值&#125;, &#123;$set:&#123;要修改的字段:修改后的数据值&#125;&#125;)</span><br></pre></td></tr></table></figure></div><p>删除文档的语法：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 删除指定文档</span><br><span class="line">db.集合名称.remove(&#123;条件字段:条件值&#125;)</span><br><span class="line"> </span><br><span class="line">-- 删除所有文档</span><br><span class="line">db.集合名称.remove(&#123;&#125;)</span><br></pre></td></tr></table></figure></div><p><a href="/images/20180711170929791.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/20180711170929791.png" class="lazyload"></a></p><h3 id="统计条数"><a href="#统计条数" class="headerlink" title="统计条数"></a>统计条数</h3><p>统计条数语法：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.spit.count()</span><br></pre></td></tr></table></figure></div><p><a href="/images/2018071117164898.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/2018071117164898.png" class="lazyload"></a></p><h3 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h3><p>MongoDB中的模糊查询是通过正则表达式来实现的，格式为：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 模糊查询，条件是正则表达式</span><br><span class="line">db.spit.find(&#123;条件字段:&#x2F;内容&#x2F;&#125;)</span><br></pre></td></tr></table></figure></div><p><a href="/images/20180711173404129.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/20180711173404129.png" class="lazyload"></a></p><h3 id="大于-小于-不等于"><a href="#大于-小于-不等于" class="headerlink" title="大于 小于 不等于"></a>大于 小于 不等于</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">-- 大于: field &gt; value</span><br><span class="line">db.集合名称.find(&#123; &quot;field&quot; : &#123; $gt: value &#125;&#125;) </span><br><span class="line"> </span><br><span class="line">-- 小于: field &lt; value</span><br><span class="line">db.集合名称.find(&#123; &quot;field&quot; : &#123; $lt: value &#125;&#125;) </span><br><span class="line"> </span><br><span class="line">-- 大于等于: field &gt;&#x3D; value</span><br><span class="line">db.集合名称.find(&#123; &quot;field&quot; : &#123; $gte: value &#125;&#125;) </span><br><span class="line"> </span><br><span class="line">-- 小于等于: field &lt;&#x3D; value</span><br><span class="line">db.集合名称.find(&#123; &quot;field&quot; : &#123; $lte: value &#125;&#125;)</span><br><span class="line"> </span><br><span class="line">-- 不等于: field !&#x3D; value</span><br><span class="line">db.集合名称.find(&#123; &quot;field&quot; : &#123; $ne: value &#125;&#125;)</span><br></pre></td></tr></table></figure></div><h3 id="包含于不包含"><a href="#包含于不包含" class="headerlink" title="包含于不包含"></a>包含于不包含</h3><p>包含使用<font color="red">$in</font>操作符，不包含使用<font color="red">$nin</font>操作符。</p><p><a href="/images/20180711200054812.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/20180711200054812.png" class="lazyload"></a></p><h3 id="条件连接"><a href="#条件连接" class="headerlink" title="条件连接"></a>条件连接</h3><p>需要查询同时满足两个以上条件，需要使用<font color="red">$and</font>操作符将条件进行关联。（相当于SQL的and），如果两个以上条件之间是或者的关系，我们使用 <font color="red">$or</font> 操作符进行关联，与前面 and的使用方式相同，<strong><font color="red">条件连接的格式如下：</font></strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 并列关系</span><br><span class="line">$and:[条件1, 条件2]</span><br><span class="line"> </span><br><span class="line">-- 与关系</span><br><span class="line">$or:[条件1, 条件2]</span><br></pre></td></tr></table></figure></div><p><a href="/images/20180711202958533.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/20180711202958533.png" class="lazyload"></a></p><h3 id="列值增长"><a href="#列值增长" class="headerlink" title="列值增长"></a>列值增长</h3><p>实现对某列值在原有值的基础上进行增加或减少，可以使用 <font color="red">$inc</font> 运算符来实现：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.spit.update(&#123;_id:&quot;2&quot;&#125;,&#123;$inc:&#123;visits:NumberInt(1)&#125;&#125; )</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> MongoDB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MongoDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux下LVM及磁盘配额管理</title>
      <link href="/2019/04/22/2019-04-22-%E3%80%90Linux%E3%80%91Linux%E4%B8%8BLVM%E5%8F%8A%E7%A3%81%E7%9B%98%E9%85%8D%E9%A2%9D%E7%AE%A1%E7%90%86/"/>
      <url>/2019/04/22/2019-04-22-%E3%80%90Linux%E3%80%91Linux%E4%B8%8BLVM%E5%8F%8A%E7%A3%81%E7%9B%98%E9%85%8D%E9%A2%9D%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="一、实验目的"><a href="#一、实验目的" class="headerlink" title="一、实验目的"></a>一、实验目的</h2><p>1.理解磁盘配额管理的概念和应用；掌握磁盘配额管理的命令；<br>2.理解LVM与普通磁盘分区的区别，掌握逻辑卷的创建、扩容等。</p><h2 id="二、实验内容"><a href="#二、实验内容" class="headerlink" title="二、实验内容"></a>二、实验内容</h2><h3 id="1-LVM练习："><a href="#1-LVM练习：" class="headerlink" title="1.LVM练习："></a>1.LVM练习：</h3><p>（1）    新添加2块SCSI硬盘设备（每块8G），每块硬盘创建两个分区，每个分区4G（假设为sdb1,sdb2,sdc1,sdc2）；<br>（2）    每个分区创建物理卷PV；<br>（3）    创建卷组myvg,包含分区sdb1和sdc1；<br>（4）    在卷组myvg上创建逻辑卷mylv（大小为4G），并基于该逻辑卷建立EXT4文件系统；<br>（5）    扩充mylv逻辑卷到大小为6G，并查看该逻辑卷；</p><h3 id="2-磁盘配额管理"><a href="#2-磁盘配额管理" class="headerlink" title="2.磁盘配额管理"></a>2.磁盘配额管理</h3><p>（1）    将上题中的文件系统设置开机后自动挂载，并开启用户、组磁盘配额管理；<br>（2）    添加用户组accp，以及该组中的用户jerry（密码为jerry）<br>（3）    限制用户jerry最多只能使用50M磁盘空间， 当使用磁盘空间超过30M时，10天内给出警告；限制accp组的用户合计最多只能使用500M磁盘空间<br>（4）    使用dd命令创建文件验证用户jerry的配额限制；<br>（5）    使用quota –u ……和repquota ….查看用户配额设置和磁盘使用情况。</p><p>##三、实验命令</p><h3 id="LVM练习："><a href="#LVM练习：" class="headerlink" title="LVM练习："></a>LVM练习：</h3><ol><li>详情见<a href="https://sxz799.ml/2019/04/15/Linux%E4%B8%8B%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA%E6%A0%BC%E5%BC%8F%E5%8C%96/" target="_blank" rel="noopener">上一篇博客</a></li><li>每个分区创建物理卷PV；<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pvcreate &#x2F;dev&#x2F;sdb1</span><br><span class="line">pvcreate &#x2F;dev&#x2F;sdb2</span><br><span class="line">pvcreate &#x2F;dev&#x2F;sdc1</span><br><span class="line">pvcreate &#x2F;dev&#x2F;sdc2</span><br><span class="line">或者</span><br><span class="line">pvcreate &#x2F;dev&#x2F;sdb1 &#x2F;dev&#x2F;sdb2 &#x2F;dev&#x2F;sdc1 &#x2F;dev&#x2F;sdc2</span><br></pre></td></tr></table></figure></div></li><li>创建卷组myvg,包含分区sdb1和sdc1；<br><code>vgcreate myvg /dev/sdb1 /dev/sdc1</code></li><li>在卷组myvg上创建逻辑卷mylv（大小为4G），并基于该逻辑卷建立EXT4文件系统；<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lvcreate -L 4G -n mylv myvg</span><br><span class="line">mkfs.ext4 &#x2F;dev&#x2F;myvg&#x2F;mylv</span><br></pre></td></tr></table></figure></div></li><li>扩充mylv逻辑卷到大小为6G，并查看该逻辑卷；<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lvextend -L +2G &#x2F;dev&#x2F;myvg&#x2F;mylv</span><br><span class="line">lvscan</span><br></pre></td></tr></table></figure></div></li></ol><h3 id="磁盘配额管理"><a href="#磁盘配额管理" class="headerlink" title="磁盘配额管理"></a>磁盘配额管理</h3><ol><li>将上题中的文件系统设置开机后自动挂载，并开启用户、组磁盘配额管理；<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir &#x2F;mnt&#x2F;mylv</span><br><span class="line">vi &#x2F;etc&#x2F;fstab</span><br><span class="line">在最后一行添加下面内容</span><br><span class="line">&#x2F;dev&#x2F;myvg&#x2F;mylv &#x2F;mnt&#x2F;mylv ext4 defaults,usrquota,grpquota 1 2</span><br></pre></td></tr></table></figure></div></li><li>添加用户组accp，以及该组中的用户jerry（密码为jerry）<br>groupadd accp<br>useradd -g accp -p jerry jerry</li><li>限制用户jerry最多只能使用50M磁盘空间， 当使用磁盘空间超过30M时，10天内给出警告；限制accp组的用户合计最多只能使用500M磁盘空间 <div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">先创建磁盘配额管理文件</span><br><span class="line">quotacheck -avug</span><br><span class="line"></span><br><span class="line">本别编辑用户和用户组的磁盘配额管理文件</span><br><span class="line"></span><br><span class="line">edquota -u jerry</span><br><span class="line">修改soft下值为 30720</span><br><span class="line">修改hard下值为 51200</span><br><span class="line"></span><br><span class="line">edquota -g accp</span><br><span class="line">修改hard下值为 512000</span><br><span class="line"></span><br><span class="line">edquota -t</span><br><span class="line">修改Block grace period下值为10days</span><br></pre></td></tr></table></figure></div></li><li>使用dd命令创建文件验证用户jerry的配额限制；<br><code>dd if=/dev/zero bs=1M count=33 of=/mnt/mylv/testfile1</code></li><li>使用quota –u和repquota查看用户配额设置和磁盘使用情况。<br>略</li></ol>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo博客添加Live2D小宠物</title>
      <link href="/2019/04/18/2019-04-18-%E3%80%90Hexo%E5%8D%9A%E5%AE%A2%E3%80%91hexo%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0Live2D%E5%B0%8F%E5%AE%A0%E7%89%A9/"/>
      <url>/2019/04/18/2019-04-18-%E3%80%90Hexo%E5%8D%9A%E5%AE%A2%E3%80%91hexo%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0Live2D%E5%B0%8F%E5%AE%A0%E7%89%A9/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在博客搭建之初这个插件我就用上了，时间久了，难免有些视觉疲劳，所以打算换个宠物。</p><p><a href="https://github.com/EYHN/hexo-helper-live2d" target="_blank" rel="noopener">项目地址</a><br><a href="https://huaji8.top/post/live2d-plugin-2.0/" target="_blank" rel="noopener">预览地址</a></p><h2 id="一、安装Live2D插件"><a href="#一、安装Live2D插件" class="headerlink" title="一、安装Live2D插件"></a>一、安装Live2D插件</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install --save hexo-helper-live2d</span><br><span class="line">npm install xxxxx &#x2F;&#x2F;xxxxx是包名</span><br></pre></td></tr></table></figure></div><p>下面是提供安装的列表，</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">live2d-widget-model-chitose</span><br><span class="line">live2d-widget-model-epsilon2_1</span><br><span class="line">live2d-widget-model-gf</span><br><span class="line">live2d-widget-model-haru&#x2F;01 (use npm install --save live2d-widget-model-haru)</span><br><span class="line">live2d-widget-model-haru&#x2F;02 (use npm install --save live2d-widget-model-haru)</span><br><span class="line">live2d-widget-model-haruto</span><br><span class="line">live2d-widget-model-hibiki</span><br><span class="line">live2d-widget-model-hijiki</span><br><span class="line">live2d-widget-model-izumi</span><br><span class="line">live2d-widget-model-koharu</span><br><span class="line">live2d-widget-model-miku</span><br><span class="line">live2d-widget-model-ni-j</span><br><span class="line">live2d-widget-model-nico</span><br><span class="line">live2d-widget-model-nietzsche</span><br><span class="line">live2d-widget-model-nipsilon</span><br><span class="line">live2d-widget-model-nito</span><br><span class="line">live2d-widget-model-shizuku</span><br><span class="line">live2d-widget-model-tororo</span><br><span class="line">live2d-widget-model-tsumiki</span><br><span class="line">live2d-widget-model-unitychan</span><br><span class="line">live2d-widget-model-wanko</span><br><span class="line">live2d-widget-model-z16</span><br></pre></td></tr></table></figure></div><h2 id="二、修改配置文件"><a href="#二、修改配置文件" class="headerlink" title="二、修改配置文件"></a>二、修改配置文件</h2><p>在博客根目录的_config.yml配置文件中添加下面的内容</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#Live2D动画</span><br><span class="line">live2d:</span><br><span class="line">  enable: true</span><br><span class="line">  scriptFrom: local</span><br><span class="line">  pluginRootPath: live2dw&#x2F;</span><br><span class="line">  pluginJsPath: lib&#x2F;</span><br><span class="line">  pluginModelPath: assets&#x2F;</span><br><span class="line">  tagMode: false</span><br><span class="line">  debug: false</span><br><span class="line">  model:</span><br><span class="line">    use: live2d-widget-model-shizuku</span><br><span class="line">  display:</span><br><span class="line">    position: right </span><br><span class="line">    width: 150</span><br><span class="line">    height: 300</span><br><span class="line">  mobile:</span><br><span class="line">    show: true</span><br></pre></td></tr></table></figure></div><p>主要参数说明</p><ol><li>enable   //是否使用</li><li>model:<br> use: live2d-widget-model-shizuku //要使用的模型名称</li><li>display:<br> position: right  //显示的位置<br> width: 150            //宽度<br> height: 150            //高度<br>mobile:<br> show: true            //移动端是否显示<br>##三、重新编译静态页面<br>下面的步骤就是Hexo三连<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure></div></li></ol>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux下磁盘分区格式化</title>
      <link href="/2019/04/15/2019-04-15-%E3%80%90Linux%E3%80%91Linux%E4%B8%8B%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA%E6%A0%BC%E5%BC%8F%E5%8C%96/"/>
      <url>/2019/04/15/2019-04-15-%E3%80%90Linux%E3%80%91Linux%E4%B8%8B%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA%E6%A0%BC%E5%BC%8F%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="一、实验目的"><a href="#一、实验目的" class="headerlink" title="一、实验目的"></a>一、实验目的</h2><ol><li>了解linux系统支持的常用文件系统</li><li>掌握磁盘分区、格式化，以及磁盘分区挂载的相关命令和操作。</li></ol><h2 id="二、实验内容"><a href="#二、实验内容" class="headerlink" title="二、实验内容"></a>二、实验内容</h2><p>背景：某公司中的Linux服务器中新增了一块硬盘/dev/sdb（大小6G），练习Linux系统下磁盘分区、文件系统的创建、挂载与卸载及自动挂载的实现。<br>在RHEL的虚拟机中添加一个新硬盘（6G大小），进行如下操作：</p><ol><li>查看/dev目录下的磁盘文件情况；</li><li>使用fdisk命令新建/dev/sdb1主分区和/dev/sdb2扩展分区，并在扩展分区中新建逻辑分区/dev/sdb5和/dev/sdb6（每个分区大小为2G），分区完成后查看分区信息；</li><li>删除逻辑分区sdb6, 然后查看分区情况；</li><li>使用mkfs命令为sdb1主分区创建xfs文件系统，为sdb5创建ext4文件系统，</li><li>用fsck命令检查这两个文件系统；</li><li>用mount命令挂载sdb1到/mnt目录下的同名文件夹/mnt/sdb1中；</li><li>查看挂载情况，并卸载sdb1分区；</li><li>设置把这两个文件系统每次启动系统时自动挂载到/mnt中的同名文件夹/mnt/sdb1和/mnt/sdb5下。</li></ol><h2 id="三、实验步骤和实验过程-包含关键截图"><a href="#三、实验步骤和实验过程-包含关键截图" class="headerlink" title="三、实验步骤和实验过程(包含关键截图)"></a>三、实验步骤和实验过程(包含关键截图)</h2><ol><li>查看/dev目录下的磁盘文件情况<br><code>ls /dev</code></li><li>创建2G的主分区<br><code>fdisk /dev/sdb</code><br>n p +2G        //这里的命令是交互式的 注意屏幕的输出提示</li><li>创建拓展分区<br>n e +4G        //这里的命令是交互式的 注意屏幕的输出提示</li><li>创建2个大小为2G的逻辑分区<br>n l +2G        //这里的命令是交互式的 注意屏幕的输出提示</li><li>查看分区情况<br>p</li><li>删除sdb6 分区<br>d 6            //这里的命令是交互式的 注意屏幕的输出提示</li><li>格式化分区<br><code>mkfs -c type /dev/sdb1</code><br><code>mkfs.ext /dev/sdb1</code>        //两者均可</li><li>检查分区<br><code>fsck /dev/sdb1</code><br><code>xfs_repair -f /dev/sdb1</code>   //fsck不可检查xfs分区</li><li>挂载分区<br><code>mkdir /mnt/sdb1</code><br><code>mount /dev/sdb1 /mnt/sdb1</code>        //要挂载到一个空文件夹</li><li>卸载分区<br><code>umount /dev/sdb1</code><br><code>umount /mnt/sdb1</code></li><li>配置开机自动挂载<br><code>vi /etc/fstab</code><br>添加<br><code>/dev/sdb1 /mnt/sdb1 xfs default 0 0</code> </li></ol>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker神器之迅雷远程下载(群辉 &amp; Linux)</title>
      <link href="/2019/04/15/2019-04-15-%E3%80%90%E7%BE%A4%E8%BE%89&amp;%E8%BD%AF%E8%B7%AF%E7%94%B1%E3%80%91Docker%E7%A5%9E%E5%99%A8%E4%B9%8B%E8%BF%85%E9%9B%B7%E8%BF%9C%E7%A8%8B%E4%B8%8B%E8%BD%BD(%E7%BE%A4%E8%BE%89%20&amp;%20Linux)/"/>
      <url>/2019/04/15/2019-04-15-%E3%80%90%E7%BE%A4%E8%BE%89&amp;%E8%BD%AF%E8%B7%AF%E7%94%B1%E3%80%91Docker%E7%A5%9E%E5%99%A8%E4%B9%8B%E8%BF%85%E9%9B%B7%E8%BF%9C%E7%A8%8B%E4%B8%8B%E8%BD%BD(%E7%BE%A4%E8%BE%89%20&amp;%20Linux)/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>镜像作者Docker<a href="https://registry.hub.docker.com/u/yinheli/docker-thunder-xware/" target="_blank" rel="noopener">链接</a></p><p>2019-10-16 19:45:58 更新<br>现在迅雷远程速度很慢，而且设备code也不一定能获取到了，所以不推荐使用了！</p><h1 id="群辉下安装和使用"><a href="#群辉下安装和使用" class="headerlink" title="群辉下安装和使用"></a>群辉下安装和使用</h1><h2 id="一、Docker下载迅雷远程镜像"><a href="#一、Docker下载迅雷远程镜像" class="headerlink" title="一、Docker下载迅雷远程镜像"></a>一、Docker下载迅雷远程镜像</h2><p>注册表搜索 thunder-xware 并下载箭头指向的镜像:yinheli/docker-thunder-xware<br><a href="https://raw.githubusercontent.com/sxz799/blog_tuchuang/master/img/QQ20190425-2016142x.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img width="600px" data-src="https://raw.githubusercontent.com/sxz799/blog_tuchuang/master/img/QQ20190425-2016142x.png" class="lazyload"></a></p><h2 id="二、安装镜像"><a href="#二、安装镜像" class="headerlink" title="二、安装镜像"></a>二、安装镜像</h2><ol><li>勾选使用高权限执行容器</li><li>点击高级设置<a href="https://raw.githubusercontent.com/sxz799/blog_tuchuang/master/img/QQ20190415-222913%402x-min.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img width="600px" data-src="https://raw.githubusercontent.com/sxz799/blog_tuchuang/master/img/QQ20190415-222913%402x-min.png" class="lazyload"></a></li><li>在卷属性卡中点击添加文件，并选择你期望远程迅雷的下载位置（自定义）</li><li>装载路径为 /TDDOWNLOAD （不可更改！！！）<a href="https://raw.githubusercontent.com/sxz799/blog_tuchuang/master/img/QQ20190415-223001%402x-min.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img width="600px" data-src="https://raw.githubusercontent.com/sxz799/blog_tuchuang/master/img/QQ20190415-223001%402x-min.png" class="lazyload"></a></li><li>网络选择左下角的与Docker Host使用相同的网络</li><li>点击应用创建容器<a href="https://raw.githubusercontent.com/sxz799/blog_tuchuang/master/img/QQ20190415-223020%402x-min.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img width="600px" data-src="https://raw.githubusercontent.com/sxz799/blog_tuchuang/master/img/QQ20190415-223020%402x-min.png" class="lazyload"></a></li><li>点开Docker页面左侧的容器选项卡，点击刚创建的容器，然后点击左上角的详情<a href="https://raw.githubusercontent.com/sxz799/blog_tuchuang/master/img/QQ20190415-223057%402x-min.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img width="600px" data-src="https://raw.githubusercontent.com/sxz799/blog_tuchuang/master/img/QQ20190415-223057%402x-min.png" class="lazyload"></a></li><li>在弹出的页面中选择日志选项卡，找到最下面的<code>THE ACTIVE CODE IS: aabbcc</code> ,记录后面的代码<a href="https://raw.githubusercontent.com/sxz799/blog_tuchuang/master/img/QQ20190415-223150%402x-min.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img width="600px" data-src="https://raw.githubusercontent.com/sxz799/blog_tuchuang/master/img/QQ20190415-223150%402x-min.png" class="lazyload"></a></li><li>点击这个链接<a href="http://yuancheng.xunlei.com)" target="_blank" rel="noopener">http://yuancheng.xunlei.com)</a> 登陆迅雷后输入刚才得到的代码即可。</li></ol><h1 id="Linux系统下安装和使用"><a href="#Linux系统下安装和使用" class="headerlink" title="Linux系统下安装和使用"></a>Linux系统下安装和使用</h1><h2 id="一、安装Docker下载迅雷远程镜像"><a href="#一、安装Docker下载迅雷远程镜像" class="headerlink" title="一、安装Docker下载迅雷远程镜像"></a>一、安装Docker下载迅雷远程镜像</h2><p>关于Docker的安装不在多说，请自行搜索安装教程<br>在终端中输入<code>docker pull yinheli/docker-thunder-xware:latest</code> 下载镜像</p><h2 id="二、安装镜像-1"><a href="#二、安装镜像-1" class="headerlink" title="二、安装镜像"></a>二、安装镜像</h2><p>mkdir data  创建一个文件夹用于存放迅雷下载的资源</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --privileged&#x3D;true \</span><br><span class="line">        --name&#x3D;xware \</span><br><span class="line">        --net&#x3D;host \</span><br><span class="line">        -v &lt;自己选择要存放的位置&gt;:&#x2F;app&#x2F;TDDOWNLOAD \</span><br><span class="line">        yinheli&#x2F;docker-thunder-xware</span><br></pre></td></tr></table></figure></div><p>注意这里命令中的data就是上面创建的文件夹，如果不同名记得修改命令中的地址<br><code>docker ps</code>   //查看当前运行的容器<br><code>docker logs xware</code>  //查看迅雷远程的日志<br>在日志的后几行会看到<code>THE ACTIVE CODE IS: aabbcc</code>这样一行代码，记录后面的代码。也就是设备CODE<br>点击这个链接<a href="http://yuancheng.xunlei.com" target="_blank" rel="noopener">http://yuancheng.xunlei.com</a> 登陆迅雷后输入刚才得到的代码即可。</p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 经验 </tag>
            
            <tag> Docker </tag>
            
            <tag> 迅雷 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客个性化定制</title>
      <link href="/2019/04/13/2019-04-13-%E3%80%90Hexo%E5%8D%9A%E5%AE%A2%E3%80%91Hexo%E5%8D%9A%E5%AE%A2%E4%B8%AA%E6%80%A7%E5%8C%96%E5%AE%9A%E5%88%B6/"/>
      <url>/2019/04/13/2019-04-13-%E3%80%90Hexo%E5%8D%9A%E5%AE%A2%E3%80%91Hexo%E5%8D%9A%E5%AE%A2%E4%B8%AA%E6%80%A7%E5%8C%96%E5%AE%9A%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前段时间给博客换了个域名同时更新了博客的Next主题，最新版的7.1，之前是5.x版本。改动太多就直接clone，然后对照之前的一点点修改吧。这里简单记录一下个性化的设置。</p><h2 id="直接在配置文件修改的地方"><a href="#直接在配置文件修改的地方" class="headerlink" title="直接在配置文件修改的地方"></a>直接在配置文件修改的地方</h2><ol><li>网站图标<br><code>favicon:</code><br>将图片定位到/theme/next/source/images</li><li>文章版权<br><code>creative_commons:</code><br>修改post属性为true</li><li>备案<br><code>beian:</code></li><li>菜单定制<br><code>menu:</code></li><li>社交<br><code>social:</code></li><li>友链<br>links:</li><li>头像<br><code>avatar:</code></li><li>阅读全文按钮<br><code>auto_excerpt:</code><br><code>read_more_btn:</code></li><li>字符统计信息<br><code>symbols_count_time:</code><br>需要安装<a href="https://github.com/theme-next/hexo-symbols-count-time" target="_blank" rel="noopener">插件</a><br>同时根目录配置文件<br><code>symbols_count_time:</code></li><li>打赏<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">reward_settings:</span><br><span class="line">enable: true</span><br><span class="line">animation: true</span><br><span class="line">comment: 自定义显示的内容</span><br></pre></td></tr></table></figure></div>下面位置放入你的二维码<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">reward:</span><br><span class="line">wechatpay: &#x2F;images&#x2F;wechatpay.jpg</span><br><span class="line">alipay: &#x2F;images&#x2F;alipay.jpg</span><br></pre></td></tr></table></figure></div></li><li>Valine评论系统<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Valine</span><br><span class="line"># You can get your appid and appkey from https:&#x2F;&#x2F;leancloud.cn</span><br><span class="line"># More info available at https:&#x2F;&#x2F;valine.js.org</span><br><span class="line">valine:</span><br></pre></td></tr></table></figure></div></li><li>本地搜索<br><code>local_search:</code></li><li>代码复制按钮<br><code>codeblock:</code></li><li>阅读人数<br><code>busuanzi_count:</code></li></ol><p>这些都是我自己用到了一下配置，主题配置文件还有很多地方，大家可以去仔细看看</p><h3 id="站点根目录配置文件和其他的地方"><a href="#站点根目录配置文件和其他的地方" class="headerlink" title="站点根目录配置文件和其他的地方"></a>站点根目录配置文件和其他的地方</h3><ol><li>汉化<br><code>language: zh-CN</code>  之前版本是zh-Hans 新版本更新了</li><li>网站标题和描述<br><code>title:</code><br><code>description:</code></li><li>新建博文时文件名添加当前时间<br><code>new_post_name: :year-:month-:day-:title.md</code></li><li>添加网站萌宠</li></ol><p><a href="https://github.com/xiazeyu/live2d-widget.js" target="_blank" rel="noopener">https://github.com/xiazeyu/live2d-widget.js</a><br><a href="https://l2dwidget.js.org/docs/class/src/index.js~L2Dwidget.html#instance-method-init" target="_blank" rel="noopener">https://l2dwidget.js.org/docs/class/src/index.js~L2Dwidget.html#instance-method-init</a></p><ol start="5"><li><p>给文章加密<br>themes/next/layout/_partials/head/head.swig<br>在第5行，也就是第一个if前添加下面代码</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    (function()&#123;</span><br><span class="line">        if(&#39;&#123;&#123; page.password &#125;&#125;&#39;)&#123;</span><br><span class="line">            if (prompt(&#39;请输入文章密码&#39;) !&#x3D;&#x3D; &#39;&#123;&#123; page.password &#125;&#125;&#39;)&#123;</span><br><span class="line">                alert(&#39;密码错误！&#39;);</span><br><span class="line">                history.back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)();</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure></div><p>然后再文章开头的— —内添加password: 密码   //记得有空格</p></li><li><p>修改全局背景<br>/theme/next/source/images目录放入你的背景图片命令为background.jpg<br>然后在/theme/next/source/css/_custom/custom.sty中添加下面代码</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Custom styles.</span><br><span class="line">@media screen and (min-width:1200px) &#123;</span><br><span class="line"></span><br><span class="line">    body &#123;</span><br><span class="line">    background-image:url(&#x2F;images&#x2F;background.jpg);</span><br><span class="line">    background-repeat: no-repeat;</span><br><span class="line">    background-attachment:fixed;</span><br><span class="line">    background-position:50% 50%; </span><br><span class="line">    background-size:cover</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    #footer a &#123;</span><br><span class="line">        color:#eee;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="暂时就想起来这么多，以后会一点点完善的"><a href="#暂时就想起来这么多，以后会一点点完善的" class="headerlink" title="暂时就想起来这么多，以后会一点点完善的"></a>暂时就想起来这么多，以后会一点点完善的</h3><p>关于搭建博客可以看我的另一篇文章<a href="https://sxz799.ml/2019/03/20/%E4%BD%BF%E7%94%A8Github%E6%90%AD%E5%BB%BAhexo%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E6%80%BB%E7%BB%93/#more" target="_blank" rel="noopener">这是链接</a></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FRP内网穿透访问家中的NAS和路由器后台</title>
      <link href="/2019/04/11/2019-04-11-%20%E3%80%90%E7%BE%A4%E8%BE%89&amp;%E8%BD%AF%E8%B7%AF%E7%94%B1%E3%80%91FRP%E7%9A%84%E5%AD%A6%E4%B9%A0%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
      <url>/2019/04/11/2019-04-11-%20%E3%80%90%E7%BE%A4%E8%BE%89&amp;%E8%BD%AF%E8%B7%AF%E7%94%B1%E3%80%91FRP%E7%9A%84%E5%AD%A6%E4%B9%A0%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>自从入手了蜗牛星际以后，一直在折腾，先是安装了软路由，现在换成了PVE下虚拟LEDE软路由和黑群晖。可以远程访问的NAS才是一个完整的NAS,由于在宿舍大家一块用一条网线，虽然有公网地址，但联通公司不给改桥接，后来想想也挺麻烦的，而且宿舍的网线也只有4芯，即使路由器拨号也无法多播，就放弃DDNS了。于是开始研究内网穿透。</p><h2 id="为什么要用FRP"><a href="#为什么要用FRP" class="headerlink" title="为什么要用FRP"></a>为什么要用FRP</h2><p>1.没钱购买花生壳的付费服务，免费的局限性太大<br>2.学习一些新的东西</p><h2 id="对FRP的理解"><a href="#对FRP的理解" class="headerlink" title="对FRP的理解"></a>对FRP的理解</h2><p>感觉frp和远程代理很像，支持的底层协议也很丰富，配置相对简单，而且不需要安装。通过命令行方式启动，有一点Linux基础的用户就可以完美驾驭。<br>作者<a href="https://github.com/fatedier/frp/blob/master/README_zh.md" target="_blank" rel="noopener">github主页</a><br>根据作者的介绍，frp的基础功能是实现远程tcp访问和ssh链接。而用的更多的确实http协议带来的远程web链接，访问家中的NAS和路由器后台。</p><h2 id="下载以及配置"><a href="#下载以及配置" class="headerlink" title="下载以及配置"></a>下载以及配置</h2><p>直接在github页面下载即可(注意服务的与客户端的版本尽量相同)<br>配置过程<br>下载frp：<br><code>wget https://github.com/fatedier/frp/releases/download/v0.26.0/frp_0.26.0_linux_amd64.tar.gz</code><br>解压：<br><code>tar -zxvf frp_0.26.0_linux_amd64.tar.gz</code><br>进入解压后的文件夹：<br><code>cd frp_0.26.0_linux_amd64.tar.gz</code><br>编辑服务端配置文件：<br><code>vi frps.ini</code><br>输入i进入编辑模式<br><code>i</code><br>根据文章后面的内容进行具体配置<br>编辑完成后按一下键盘左上角esc键退出编辑<br>输入:wq保存并退出<br>启动frp服务端并保持后台运行 （第一次测试时不需要&amp;符号即可前台运行，ctrl+c即可退出）<br><code>nohup ./frps -c ./frps.ini &amp;</code><br>客户端和服务端类似，不过将frps更换为frpc （这里的s就是server服务端，c就是client客户端）<br>下载frp：<br><code>wget https://github.com/fatedier/frp/releases/download/v0.26.0/frp_0.26.0_linux_amd64.tar.gz</code><br>解压：<br><code>tar -zxvf frp_0.26.0_linux_amd64.tar.gz</code><br>进入解压后的文件夹：<br><code>cd frp_0.26.0_linux_amd64.tar.gz</code><br>编辑客户端配置文件：<br><code>vi frpc.ini</code>//<br>输入i进入编辑模式<br><code>i</code><br>根据文章后面的内容进行具体配置<br>编辑完成后按一下键盘左上角esc键退出编辑,保存并退出<br><code>:wq</code> 记得按esc退出编辑状态<br>启动frp服务端并保持后台运行<br><code>nohup ./frpc -c ./frpc.ini &amp;</code>  </p><h3 id="服务端配置文件"><a href="#服务端配置文件" class="headerlink" title="服务端配置文件"></a>服务端配置文件</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[common] </span><br><span class="line">#服务器ip</span><br><span class="line">bind_addr &#x3D; 0.0.0.0  </span><br><span class="line">#frp端口 </span><br><span class="line">bind_port &#x3D; 7000</span><br><span class="line">#口令配置</span><br><span class="line">token &#x3D; xxx </span><br><span class="line">##frp协议和端口配置 （根据自己的需要保留即可）</span><br><span class="line">bind_udp_port &#x3D; 7001</span><br><span class="line">kcp_bind_port &#x3D; 7002</span><br><span class="line">vhost_http_port &#x3D; 80     </span><br><span class="line">vhost_https_port &#x3D; 443</span><br><span class="line"></span><br><span class="line">##frp的统计信息，可以浏览器输入http:&#x2F;&#x2F;服务器ip:7500查看，账号密码为admin，可以在下面配置中修改</span><br><span class="line">dashboard_addr &#x3D; 0.0.0.0</span><br><span class="line">dashboard_port &#x3D; 7500</span><br><span class="line">dashboard_user &#x3D; admin</span><br><span class="line">dashboard_pwd &#x3D; admin </span><br><span class="line"></span><br><span class="line">##frp日志配置 </span><br><span class="line">log_file &#x3D; .&#x2F;frps.log</span><br><span class="line">log_level &#x3D; info</span><br><span class="line">log_max_days &#x3D; 3</span><br></pre></td></tr></table></figure></div><h3 id="客户端配置文件"><a href="#客户端配置文件" class="headerlink" title="客户端配置文件"></a>客户端配置文件</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">[common]</span><br><span class="line">####IP也可以是域名 </span><br><span class="line">server_addr &#x3D; x.x.x.x  </span><br><span class="line">frp服务器端口</span><br><span class="line">server_port &#x3D; 7000</span><br><span class="line">#口令配置，要和服务端一致</span><br><span class="line">token &#x3D; xxx </span><br><span class="line">##frp日志配置 （根据自己的需要保留或者删除）</span><br><span class="line">log_file &#x3D; .&#x2F;frpc.log</span><br><span class="line">log_level &#x3D; info</span><br><span class="line">log_max_days &#x3D; 3</span><br><span class="line"></span><br><span class="line">#[]里面的内容自定义，建议用作标示</span><br><span class="line">[lede] </span><br><span class="line">type &#x3D; http</span><br><span class="line">local_ip &#x3D; 192.168.123.1  </span><br><span class="line">local_port &#x3D; 80</span><br><span class="line">custom_domains &#x3D; xxx.youdomain.com</span><br><span class="line"></span><br><span class="line">[nas]</span><br><span class="line">type &#x3D; http     </span><br><span class="line">local_ip &#x3D; 192.168.123.102               </span><br><span class="line">local_port &#x3D; 5000           </span><br><span class="line">custom_domains &#x3D; yyy.youdomain.com  </span><br><span class="line"></span><br><span class="line">[pve]</span><br><span class="line">type &#x3D; https</span><br><span class="line">local_ip &#x3D; 192.168.123.100</span><br><span class="line">local_port &#x3D; 8006</span><br><span class="line">custom_domains &#x3D; zzz.youdomain.com</span><br><span class="line">#这里我的客户端配置，三个域名分别对应三个不同的web页面</span><br><span class="line">#custom_domains是自己的域名</span><br></pre></td></tr></table></figure></div><a href="https://raw.githubusercontent.com/sxz799/blog_tuchuang/master/img/20190411195654.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img data-src="https://raw.githubusercontent.com/sxz799/blog_tuchuang/master/img/20190411195654.png" class="lazyload"></a>## 解决远程Transmission无法使用修改Transmission的配置文件settings.json ，启动密码登录即可（大约在第43行开始）个人猜测这个白名单在内网穿透时无效。（未经验证）<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&quot;rpc-authentication-required&quot;: true,</span><br><span class="line">    &quot;rpc-bind-address&quot;: &quot;0.0.0.0&quot;,</span><br><span class="line">    &quot;rpc-enabled&quot;: true,</span><br><span class="line">    &quot;rpc-host-whitelist&quot;: &quot;&quot;,</span><br><span class="line">    &quot;rpc-host-whitelist-enabled&quot;: true,</span><br><span class="line">    &quot;rpc-password&quot;: &quot;&#123;925c1d0775d6e63d3ccd87a8f97f48d38e9f013fupumAV6s&quot;,</span><br><span class="line">    &quot;rpc-port&quot;: 9091,</span><br><span class="line">    &quot;rpc-url&quot;: &quot;&#x2F;transmission&#x2F;&quot;,</span><br><span class="line">    &quot;rpc-username&quot;: &quot;admin&quot;,</span><br><span class="line">    &quot;rpc-whitelist&quot;: &quot;&quot;,</span><br><span class="line">    &quot;rpc-whitelist-enabled&quot;: false,</span><br></pre></td></tr></table></figure></div>## 总结<p>FRP整体配置还是比较简单的，只要了解了其原理就能轻松使用。</p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内网穿透 </tag>
            
            <tag> 群晖 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>蜗牛星际之安装PVE+LEDE+群辉</title>
      <link href="/2019/04/06/2019-04-06-%E3%80%90%E7%BE%A4%E8%BE%89&amp;%E8%BD%AF%E8%B7%AF%E7%94%B1%E3%80%91%E8%9C%97%E7%89%9B%E6%98%9F%E9%99%85%E4%B9%8B%E5%AE%89%E8%A3%85PVE+LEDE+%E7%BE%A4%E8%BE%89/"/>
      <url>/2019/04/06/2019-04-06-%E3%80%90%E7%BE%A4%E8%BE%89&amp;%E8%BD%AF%E8%B7%AF%E7%94%B1%E3%80%91%E8%9C%97%E7%89%9B%E6%98%9F%E9%99%85%E4%B9%8B%E5%AE%89%E8%A3%85PVE+LEDE+%E7%BE%A4%E8%BE%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上次安装了LEDE软路由后，也挂载了一个500G的硬盘，但总感觉对于J1900+4G内存来说有点浪费，还有那么大哥机箱，如果不做NAS有点对不起他的体积，在加上本来就是个矿机就尽量多压榨一下他的性能。<br>这里只是简单些一下安装流程，不打算上传图片了，更加详细的教程可以看下面的链接<br><a href="https://post.smzdm.com/p/ag89qdw6/" target="_blank" rel="noopener">蜗牛矿渣装机教程 篇一：搞定PVE虚拟机</a>作者主页有更多的教程，一共四个系列。</p><h2 id="一、准备"><a href="#一、准备" class="headerlink" title="一、准备"></a>一、准备</h2><h3 id="1-规划IP地址"><a href="#1-规划IP地址" class="headerlink" title="1.规划IP地址"></a>1.规划IP地址</h3><p>按照自己的需求规划好IP地址，尽量用纸记下来，省的以后乱套。</p><p>建议将PVE地址规划为软路由lan口的子网地址 例如192.168.123.100</p><p>群辉地址也为lan口的子网地址 例如192.168.123.102(这里的102是PVE的虚拟机序号，默认是从100开始)</p><h3 id="2-制作U盘启动"><a href="#2-制作U盘启动" class="headerlink" title="2.制作U盘启动"></a>2.制作U盘启动</h3><p>两个优盘，一个装PE，一个装PVE镜像</p><ol><li><p>PE直接用老毛桃即可。</p></li><li><p>用win32磁盘映像工具将pve的iso镜像写入U盘</p></li></ol><h3 id="3-恢复bios默认设置"><a href="#3-恢复bios默认设置" class="headerlink" title="3.恢复bios默认设置"></a>3.恢复bios默认设置</h3><p>开机接键盘后按del进去bios，然后按F9恢复默认设置，然后F10保存并退出。</p><h2 id="二、安装PVE"><a href="#二、安装PVE" class="headerlink" title="二、安装PVE"></a>二、安装PVE</h2><ol><li><p>插入老毛桃优盘进入PE，进入后将内置16G的mSATA所有分区删除，然后建立一个新分区。NTFS格式，取消勾选ESP和EFI。</p></li><li><p>关机，拔出老毛桃U盘，插入刻录PVE镜像的优盘启动盘。</p></li><li><p>开机按F11选择UEFI开头的U盘，进入PVE安装界面    </p></li><li><p>根据指示安装完成即可。(这里会提示设置PVE的IP地址、子网掩码和网关)</p></li><li><p>添加网卡桥接，默认只有一个桥接网卡，按照格式添加新的桥接网卡即可。建议备注好WAN和LAN口。因为蜗牛只有2个网卡，所以备注好WAN和LAN同时在机箱后备注好WAN和LAN。</p></li></ol><h2 id="三、安装LEDE"><a href="#三、安装LEDE" class="headerlink" title="三、安装LEDE"></a>三、安装LEDE</h2><ol><li><p>新建虚拟机，选择不适用任何介质，硬盘分配1G-2G即可(后面远程连接需要安装docker，所以分配够用即可)，合理配置内存与核心（1G+4cores），网卡选择E1000。</p></li><li><p>下载LEDE镜像并解压。</p></li><li><p>将img2kvm和解压后的镜像上传到PVE的root目录</p></li><li><p>root目录下指令下面命令(Linux系统当前用户目录显示为~)</p></li></ol><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod +x img2kvm</span><br><span class="line">.&#x2F;img2kvm lede.img 101(虚拟机编号) lede-leader-disk(这里可以自定义的)</span><br></pre></td></tr></table></figure></div><ol start="5"><li><p>在虚拟机的硬件页面添加新建的磁盘文件，硬盘接口尽量选择sata</p></li><li><p>硬件添加一个新的网卡。</p></li><li><p>在选项页面调整启动顺序，将新加的文件设置为第一引导</p></li><li><p>启动虚拟机，并在控制台修改LAN口IP,然后reboot即可。</p></li></ol><h2 id="四、安装群辉"><a href="#四、安装群辉" class="headerlink" title="四、安装群辉"></a>四、安装群辉</h2><ol><li><p>和LEDE类似，新建虚拟机，硬盘分配4G以上，配置为3G+4cores,网卡选择E1000。</p></li><li><p>同样的方法挂载引导磁盘，控制器一定要选SATA，不然无法获取IP.</p></li><li><p>调整启动顺序，将引导磁盘设置为第一启动项。</p></li><li><p>下载群辉助手，搜索，安装即可。(这一步用群辉助手搜索即可，可以挂载好硬盘再安装。)</p></li><li><p>如果搜索不到的话看一下本机IP是否在LEDE分配的网段下，因为的我网络环境是光猫拨号，直接获取到光猫分配的IP，导致无法搜索，建议在断网的环境下安装群辉。</p></li></ol><h2 id="五、群辉挂载磁盘"><a href="#五、群辉挂载磁盘" class="headerlink" title="五、群辉挂载磁盘"></a>五、群辉挂载磁盘</h2><ol><li><p>关闭群辉虚拟机</p></li><li><p>插入硬盘</p></li><li><p>用下面的命令查看硬盘名称</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;dev&#x2F;disk&#x2F;by-id</span><br><span class="line">ls</span><br></pre></td></tr></table></figure></div></li><li><p>复制磁盘名</p></li><li><p>用下面的命令挂载到群辉虚拟机<br><code>qm set 102(群辉ID) -sataX(X为序列号，不可与之前的重复) /dev/disk/by-id/XXXXX(XXXX为硬盘名称)</code></p></li><li><p>挂载好以后可以将之前的4G虚拟硬盘分离，然后删除即可。</p></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><p>一定要提前规划好IP</p></li><li><p>群辉引导一定要选择SATA.</p></li><li><p>群辉洗白可以挂载一个ISO格式PE镜像，作为第一引导，在控制台页面修改sn和mac即可。</p></li><li><p>当LEDE作为二级路由，即WAN口协议为DHCP客户端时，要在LAN口的DHCP服务器高级设置中勾选‘强制’ //即使检测到另一台服务器，也要强制使用此网络上的 DHCP。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 虚拟机 </tag>
            
            <tag> LEDE </tag>
            
            <tag> 软路由 </tag>
            
            <tag> PVE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker神器之百度云下载(群辉 &amp; LEDE)</title>
      <link href="/2019/03/30/2019-03-30-%E3%80%90%E7%BE%A4%E8%BE%89&amp;%E8%BD%AF%E8%B7%AF%E7%94%B1%E3%80%91Docker%E7%A5%9E%E5%99%A8%E4%B9%8B%E7%99%BE%E5%BA%A6%E4%BA%91%E4%B8%8B%E8%BD%BD(%E7%BE%A4%E8%BE%89%20&amp;%20LEDE)/"/>
      <url>/2019/03/30/2019-03-30-%E3%80%90%E7%BE%A4%E8%BE%89&amp;%E8%BD%AF%E8%B7%AF%E7%94%B1%E3%80%91Docker%E7%A5%9E%E5%99%A8%E4%B9%8B%E7%99%BE%E5%BA%A6%E4%BA%91%E4%B8%8B%E8%BD%BD(%E7%BE%A4%E8%BE%89%20&amp;%20LEDE)/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>入手了蜗牛星际，安装了lede以后发现酷软中心的aria2和tr都不能正常工作，可能是版本bug，无意间在论坛发现了利用docker这一神奇运行百度云第三方下载，尝试一番发现确实很好用，记录一下折腾的过程。<br>原贴：<br><a href="http://koolshare.cn/thread-154383-1-1.html" target="_blank" rel="noopener">http://koolshare.cn/thread-154383-1-1.html</a><br>我没有使用原贴中的镜像 而是选择了另一位大神oldiy的镜像，下面是他的DockerHub主页和博客。<br><a href="https://hub.docker.com/u/oldiy/" target="_blank" rel="noopener">https://hub.docker.com/u/oldiy/</a><br><a href="https://odcn.top/" target="_blank" rel="noopener">https://odcn.top/</a></p><h1 id="LEDE软路由下使用"><a href="#LEDE软路由下使用" class="headerlink" title="LEDE软路由下使用"></a>LEDE软路由下使用</h1><h2 id="第一步-LEDE酷软中心安装Docker插件"><a href="#第一步-LEDE酷软中心安装Docker插件" class="headerlink" title="第一步 LEDE酷软中心安装Docker插件"></a>第一步 LEDE酷软中心安装Docker插件</h2><p>这里不多解释，直接安装即可</p><h2 id="第二步-配置Docker插件"><a href="#第二步-配置Docker插件" class="headerlink" title="第二步 配置Docker插件"></a>第二步 配置Docker插件</h2><p>按照下图的设置即可<br><a href="https://raw.githubusercontent.com/sxz799/blog_tuchuang/master/img/20190330142552.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img width="600px" data-src="https://raw.githubusercontent.com/sxz799/blog_tuchuang/master/img/20190330142552.png" class="lazyload"></a></p><h2 id="第三步-下载相关镜像"><a href="#第三步-下载相关镜像" class="headerlink" title="第三步 下载相关镜像"></a>第三步 下载相关镜像</h2><p>在注册表页搜索相关镜像即可，如下图为百度云下载<br><a href="https://raw.githubusercontent.com/sxz799/blog_tuchuang/master/img/20190330143001.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img width="600px" data-src="https://raw.githubusercontent.com/sxz799/blog_tuchuang/master/img/20190330143001.png" class="lazyload"></a></p><h2 id="第四步-创建容器"><a href="#第四步-创建容器" class="headerlink" title="第四步 创建容器"></a>第四步 创建容器</h2><p>在镜像页选择已经下载的镜像创建即可。<br><a href="https://raw.githubusercontent.com/sxz799/blog_tuchuang/master/img/20190330143146.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img width="600px" data-src="https://raw.githubusercontent.com/sxz799/blog_tuchuang/master/img/20190330143146.png" class="lazyload"></a><br>在这里对容器进行相关配置，注意端口，和容器中给定的相同最好<br>下面这一张图就能看明白端口和目录的设置了<br>简单来说就是端口号正确且不与lede其他程序冲突就可以进入后台<br>地址正确才能保证文件下载到你指定的位置<br><a href="https://raw.githubusercontent.com/sxz799/blog_tuchuang/master/img/20190330151403.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img width="600px" data-src="https://raw.githubusercontent.com/sxz799/blog_tuchuang/master/img/20190330151403.png" class="lazyload"></a><br>然后点击创建即可</p><h2 id="进入Web页面查看安装情况"><a href="#进入Web页面查看安装情况" class="headerlink" title="进入Web页面查看安装情况"></a>进入Web页面查看安装情况</h2><p>启动成功后就可以通过下面的链接进入web页面了<br>http://你的路由器ip:5299   //这里的5299就是配置容器时的端口，尽量和dockerhub的相同。如果不同应该是进不去相关页面的<br>使用自己的百度账号登录即可，然后点击右上角的设置<br>注意这里的目录，不要修改使用默认即可<br><a href="https://raw.githubusercontent.com/sxz799/blog_tuchuang/master/img/20190330144619.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img width="600px" data-src="https://raw.githubusercontent.com/sxz799/blog_tuchuang/master/img/20190330144619.png" class="lazyload"></a><br><a href="https://raw.githubusercontent.com/sxz799/blog_tuchuang/master/img/20190330144816.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img width="600px" data-src="https://raw.githubusercontent.com/sxz799/blog_tuchuang/master/img/20190330144816.png" class="lazyload"></a></p><h1 id="群辉下使用-（更新内容）"><a href="#群辉下使用-（更新内容）" class="headerlink" title="群辉下使用 （更新内容）"></a>群辉下使用 （更新内容）</h1><h2 id="第一步-群辉套件中心安装Docker插件"><a href="#第一步-群辉套件中心安装Docker插件" class="headerlink" title="第一步 群辉套件中心安装Docker插件"></a>第一步 群辉套件中心安装Docker插件</h2><p>不多解释</p><h2 id="第二步-下载镜像"><a href="#第二步-下载镜像" class="headerlink" title="第二步 下载镜像"></a>第二步 下载镜像</h2><p>在注册表搜索<code>baidu</code>下载下图中的镜像<br><a href="https://raw.githubusercontent.com/sxz799/blog_tuchuang/master/img/1111111.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img width="600px" data-src="https://raw.githubusercontent.com/sxz799/blog_tuchuang/master/img/1111111.png" class="lazyload"></a></p><h2 id="第三步-配置镜像"><a href="#第三步-配置镜像" class="headerlink" title="第三步 配置镜像"></a>第三步 配置镜像</h2><p>按照下图配置即可，配置完成后会自动启动容器<br><a href="https://raw.githubusercontent.com/sxz799/blog_tuchuang/master/img/222222.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img width="600px" data-src="https://raw.githubusercontent.com/sxz799/blog_tuchuang/master/img/222222.png" class="lazyload"></a><br>配置下载路径<br><a href="https://raw.githubusercontent.com/sxz799/blog_tuchuang/master/img/333333.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img width="600px" data-src="https://raw.githubusercontent.com/sxz799/blog_tuchuang/master/img/333333.png" class="lazyload"></a><br>配置端口<br><a href="https://raw.githubusercontent.com/sxz799/blog_tuchuang/master/img/444444.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img width="600px" data-src="https://raw.githubusercontent.com/sxz799/blog_tuchuang/master/img/444444.png" class="lazyload"></a></p><h2 id="第四步-打开Web管理页面"><a href="#第四步-打开Web管理页面" class="headerlink" title="第四步 打开Web管理页面"></a>第四步 打开Web管理页面</h2><p>浏览器输入 <code>&lt;你的IP&gt;:5299</code> 进入web页面</p><h2 id="解决百度云限速"><a href="#解决百度云限速" class="headerlink" title="解决百度云限速"></a>解决百度云限速</h2><p>web的设置页面修改appid为</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">265486</span><br></pre></td></tr></table></figure></div><p>默认工作目录修改为</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;apps&#x2F;baidu_shurufa</span><br></pre></td></tr></table></figure></div><p>百度输入法不限速，所以修改为输入法的id 而默认工作目录就是登陆页面后所展现的目录<br>把要下载的文件移动到/apps/baidu_shurufa 下载即可<br>需要操作其他文件的时换回 266719 即可</p><p>结束<br>2019年03月30日15:02:07<br>更新<br>2019年04月18日23:24:00</p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LEDE </tag>
            
            <tag> Docker </tag>
            
            <tag> 下载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软路由LEDE系统之samba局域网共享</title>
      <link href="/2019/03/29/2019-03-29-%E3%80%90%E7%BE%A4%E8%BE%89&amp;%E8%BD%AF%E8%B7%AF%E7%94%B1%E3%80%91%E8%BD%AF%E8%B7%AF%E7%94%B1LEDE%E7%B3%BB%E7%BB%9F%E4%B9%8Bsamba%E5%B1%80%E5%9F%9F%E7%BD%91%E5%85%B1%E4%BA%AB/"/>
      <url>/2019/03/29/2019-03-29-%E3%80%90%E7%BE%A4%E8%BE%89&amp;%E8%BD%AF%E8%B7%AF%E7%94%B1%E3%80%91%E8%BD%AF%E8%B7%AF%E7%94%B1LEDE%E7%B3%BB%E7%BB%9F%E4%B9%8Bsamba%E5%B1%80%E5%9F%9F%E7%BD%91%E5%85%B1%E4%BA%AB/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上周末看油管的时候发现了一款极具性价比的NAS-蜗牛星际。矿渣nas，三月初就开卖了，当时好像200包邮。我入手有点晚所以价格也高一些。290包邮。不过卖家给改好了双千兆网络。虽然是矿渣，但我这台内部没有多少灰尘。只有风扇上有灰。应该没运行多久。到手后由于没4有显示器和电源线。就去楼下电脑维修店买了根电源线，顺便借老板显示器装了系统。<br>很久之前就想入手软路由了，但是动不动就上千的售价实在是难以接受。看到这个性价比还不错的就入手了。之前用的是k2p。没有usb接口，局域网共享就很难实现，而且就算有U盘，24小时工作也承受不了。现在终于可以好好享受一下samba带来的便携了。后期应该还会安装黑群辉实现更多的功能。<br>如果你的软路由主板usb借了移动硬盘或者sata口连接了机械硬盘，这一步是不需要做的。<br>蜗牛星际主板上带了一个16G的固态硬盘。性能极差。和3.0的U盘速度差不多。装lede还勉强可以接受。现在没有硬盘也只能用这个来代替了。<br>我安装的是<a href="http://koolshare.cn/portal.php" target="_blank" rel="noopener">koolshare论坛</a>的lede系统，酷软中心很多插件，还是挺好用的。<br><a href="https://raw.githubusercontent.com/sxz799/blog_tuchuang/master/img/20190329233210.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img width="600px" data-src="https://raw.githubusercontent.com/sxz799/blog_tuchuang/master/img/20190329233210.png" class="lazyload"></a><br>注：本文借鉴了koolshare论坛的两个帖子 这里简单做了一些总结，和一些自己的经验</p><p><a href="http://koolshare.cn/thread-154153-1-1.html" target="_blank" rel="noopener">http://koolshare.cn/thread-154153-1-1.html</a><br><a href="http://koolshare.cn/forum.php?mod=viewthread&amp;tid=110543&amp;highlight=samba" target="_blank" rel="noopener">http://koolshare.cn/forum.php?mod=viewthread&amp;tid=110543&amp;highlight=samba</a></p><h2 id="一、为安装盘剩余的空间创建新分区"><a href="#一、为安装盘剩余的空间创建新分区" class="headerlink" title="一、为安装盘剩余的空间创建新分区"></a>一、为安装盘剩余的空间创建新分区</h2><p>如果你的软路由主板usb借了移动硬盘或者sata口连接了机械硬盘，这一步是不需要做的。</p><h3 id="先运行分区工具"><a href="#先运行分区工具" class="headerlink" title="先运行分区工具"></a>先运行分区工具</h3><p><code>fdisk /dev/sda</code><br><a href="https://raw.githubusercontent.com/sxz799/blog_tuchuang/master/img/20190329233753.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img width="600px" data-src="https://raw.githubusercontent.com/sxz799/blog_tuchuang/master/img/20190329233753.png" class="lazyload"></a></p><h3 id="输入p查看当前分区"><a href="#输入p查看当前分区" class="headerlink" title="输入p查看当前分区"></a>输入p查看当前分区</h3><a href="https://raw.githubusercontent.com/sxz799/blog_tuchuang/master/img/20190329234053.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img width="600px" data-src="https://raw.githubusercontent.com/sxz799/blog_tuchuang/master/img/20190329234053.png" class="lazyload"></a>### 输入n创建新的分区这里由于我已经创建 就不在截图了 直接连续三次回车键，会默认将剩余的空间创建为一个新的分区。### 输入w保存分区完成后会退出分区工具### 使用mkfs命令格式化新建的分区`mkfs.ext4 /dev/sda5`说明 etx4是文件系统。如果是固态的话建议修改为f2fs。后面的sda5是新建的分区，分区名根据自己的修改即可。`mkfs.f2fs /dev/sda5` （固态硬盘推荐使用）### 赋予新添加的分区权限`chmod -R a+rwx /mnt/sda5`### 重启，使分区表生效（好像不重启也可以，不过还是建议重启）## 二、挂载新创建的分区如果你的软路由主板usb借了移动硬盘或者sata口连接了机械硬盘，这一步也是不需要做的。这里就很简单了，打开路由器管理界面简单设置即可<a href="https://raw.githubusercontent.com/sxz799/blog_tuchuang/master/img/20190329235605.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img width="600px" data-src="https://raw.githubusercontent.com/sxz799/blog_tuchuang/master/img/20190329235605.png" class="lazyload"></a>选择挂载点，在自定义位置填入`/mnt/sda5` (挂载器要创建这个空文件夹，注意不要输错了)<a href="https://raw.githubusercontent.com/sxz799/blog_tuchuang/master/img/20190330000544.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img width="600px" data-src="https://raw.githubusercontent.com/sxz799/blog_tuchuang/master/img/20190330000544.png" class="lazyload"></a>## 三、将新创建的分区添加到samba的共享目录这里也很简单 按照下图的设置即可<a href="https://raw.githubusercontent.com/sxz799/blog_tuchuang/master/img/20190330001456.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img width="600px" data-src="https://raw.githubusercontent.com/sxz799/blog_tuchuang/master/img/20190330001456.png" class="lazyload"></a>### 给samba用户添加密码`smbpasswd -a root` （终端输入）然后输入密码回车最后重启一下软路由即可（想偷懒就直接重启samba服务即可）## 总结其实对于大多用户来说，都会挂载一个硬盘来当做简易的NAS来使用。核心内容就是下面三步1.添加samba用户2.为用户设置密码3.添加该用户可以访问的目录这里我偷懒，加上在家里用，root用户就可以。不必要弄那些复杂的内容。嗯，就这样2019年03月30日00:28:30]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LEDE </tag>
            
            <tag> 软路由 </tag>
            
            <tag> samba </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Github搭建hexo静态博客总结</title>
      <link href="/2019/03/20/2019-03-20-%E3%80%90Hexo%E5%8D%9A%E5%AE%A2%E3%80%91%E4%BD%BF%E7%94%A8Github%E6%90%AD%E5%BB%BAhexo%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E6%80%BB%E7%BB%93/"/>
      <url>/2019/03/20/2019-03-20-%E3%80%90Hexo%E5%8D%9A%E5%AE%A2%E3%80%91%E4%BD%BF%E7%94%A8Github%E6%90%AD%E5%BB%BAhexo%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>第一次搭建博客大约是在18年6月份。当时是在腾讯云vps上安装宝塔，然后宝塔内部一键安装WordPress博客。在18年12月份发现Github+hexo这一神奇组合，果断尝试。然后又经历了期末考试和过年，博客也算是搁置了一段时间。前几天才重新捡起，然后又系统的自学了一下Git。所以打算写这个博客简单记录一下最基础的内容，可能有些小白看不懂，后期可能会慢慢完善的。</p><h2 id="一、什么是Git、Github、Hexo？"><a href="#一、什么是Git、Github、Hexo？" class="headerlink" title="一、什么是Git、Github、Hexo？"></a>一、什么是Git、Github、Hexo？</h2><p>首先要知道这是完全不同的三个东西，但三者结合起来就会发生奇妙的反应。</p><h3 id="什么是Git？"><a href="#什么是Git？" class="headerlink" title="什么是Git？"></a>什么是Git？</h3><p>Git是一个的分布式版本控制系统。</p><h3 id="什么是Github？"><a href="#什么是Github？" class="headerlink" title="什么是Github？"></a>什么是Github？</h3><p>Github是一个提供免费服务的代码托管网站。</p><h3 id="什么是Hexo？"><a href="#什么是Hexo？" class="headerlink" title="什么是Hexo？"></a>什么是Hexo？</h3><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 <a href="http://daringfireball.net/projects/markdown/(或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。(摘抄自hexo官网" target="_blank" rel="noopener">Markdown</a></p><p>如果对github和git的关系感兴趣，可以去这个网站简单了解一下</p><p><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137402760310626208b4f695940a49e5348b689d095fc000" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137402760310626208b4f695940a49e5348b689d095fc000</a></p><h2 id="二、安装Git、Node-js和hexo"><a href="#二、安装Git、Node-js和hexo" class="headerlink" title="二、安装Git、Node.js和hexo"></a>二、安装Git、Node.js和hexo</h2><p>在以下网址下载软件<br>Git官网下载地址 <a href="https://www.git-scm.com/download/" target="_blank" rel="noopener">https://www.git-scm.com/download/</a><br>node.js官网下载地址 <a href="https://nodejs.org/en/" target="_blank" rel="noopener">https://nodejs.org/en/</a> （建议下载LTS版本）<br>这两款软件选好安装目录使用默认设置即可</p><h3 id="hexo安装"><a href="#hexo安装" class="headerlink" title="hexo安装"></a>hexo安装</h3><p>安装好git和node.js后新建一个你要放置博客的文件夹，然后鼠标右键点击 Git bash here，在弹出的窗口输入<br><code>npm install -g hexo-cli         //实际上在任意文件夹下都可以 ，hexo安装的目录由node.js的配置决定</code></p><h2 id="三、Hexo博客相关内容"><a href="#三、Hexo博客相关内容" class="headerlink" title="三、Hexo博客相关内容"></a>三、Hexo博客相关内容</h2><h3 id="初始化hexo博客"><a href="#初始化hexo博客" class="headerlink" title="初始化hexo博客"></a>初始化hexo博客</h3><p>在博客目录鼠标右键点击 Git bash here 在弹出的窗口依次输入<br><code>hexo init //初始化博客</code><br><code>npm install //安装hexo需要的依赖包</code><br><code>npm  install hexo-deployer-git  --save    // 安装部署到github所需要的依赖包</code><br>这时就可以写博客了（建议先了解一下md语法然后下载一个md编辑器进行创作）</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo n 博客文章名&#x2F;&#x2F;在source&#x2F;_post目录生成对应md文件</span><br><span class="line">hexo g &#x2F;&#x2F;hexo转化为静态网页</span><br><span class="line">hexo s &#x2F;&#x2F;本地服务器，可以实时预览博客</span><br></pre></td></tr></table></figure></div><p>建议先了解一下md语法然后下载一个md编辑器进行创作<br>完成这一步 在浏览器打开下面的链接</p><p><code>http://localhost:4000/</code></p><p>就可以看见系统默认的一篇博客了和你写的博客了</p><p>到这里博客就大致成型了<br>但是服务搭建在本地是没有什么意义的，我们需要发布到互联网。可以选择购买服务器，自行搭建git服务，也可以用github免费的代码托管服务</p><h3 id="注册github并新建博客仓库"><a href="#注册github并新建博客仓库" class="headerlink" title="注册github并新建博客仓库"></a>注册github并新建博客仓库</h3><p>github官网 <a href="https://github.com/" target="_blank" rel="noopener">https://github.com/</a><br>自行注册<br>然后新建一个名为 xxx.github.io 的仓库 //xxx为你的github用户名，这里不能错！！！不能自定义，必须要和github用户名相同</p><a href="https://raw.githubusercontent.com/sxz799/blog_tuchuang/master/img/QQ20190324-140631%402x.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img width="600px" data-src="https://raw.githubusercontent.com/sxz799/blog_tuchuang/master/img/QQ20190324-140631%402x.png" class="lazyload"></a><h3 id="生成ssh密钥并将公钥添加到github"><a href="#生成ssh密钥并将公钥添加到github" class="headerlink" title="生成ssh密钥并将公钥添加到github"></a>生成ssh密钥并将公钥添加到github</h3><p>在命令提示符输入</p><p><code>ssh-keygen -t rsa -C &quot;注册github时的email&quot;</code><br>打开用户目录下隐藏的.ssh文件夹，打开id_rsa.pub文件，复制全部内容，粘贴到github的ssh处</p><a href="https://raw.githubusercontent.com/sxz799/blog_tuchuang/master/img/QQ20190324-140304%402x.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img width="600px" data-src="https://raw.githubusercontent.com/sxz799/blog_tuchuang/master/img/QQ20190324-140304%402x.png" class="lazyload"></a><a href="https://raw.githubusercontent.com/sxz799/blog_tuchuang/master/img/20190324140332.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img width="600px" data-src="https://raw.githubusercontent.com/sxz799/blog_tuchuang/master/img/20190324140332.png" class="lazyload"></a><h3 id="修改博客配置文件"><a href="#修改博客配置文件" class="headerlink" title="修改博客配置文件"></a>修改博客配置文件</h3><p>配置博客目录下的_config.yml配置文件</p><a href="https://raw.githubusercontent.com/sxz799/blog_tuchuang/master/img/20190324140126.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img width="600px" data-src="https://raw.githubusercontent.com/sxz799/blog_tuchuang/master/img/20190324140126.png" class="lazyload"></a><p>这时就可以通过下面的命令将博客同步到github的仓库中</p><p><code>hexo d</code> //发布博客</p><p>接下来就可以在链接到互联网的设备中输入下面链接访问你的博客了</p><p><a href="http://xxxxx.github.io" target="_blank" rel="noopener">http://xxxxx.github.io</a>   //xxxxx为你的用户名</p><h2 id="四、添加DNS个性化域名并使用cdn加速"><a href="#四、添加DNS个性化域名并使用cdn加速" class="headerlink" title="四、添加DNS个性化域名并使用cdn加速"></a>四、添加DNS个性化域名并使用cdn加速</h2><h3 id="注册一个域名"><a href="#注册一个域名" class="headerlink" title="注册一个域名"></a>注册一个域名</h3><p>这一步不详细介绍了，域名自己选购</p><h3 id="添加域名解析"><a href="#添加域名解析" class="headerlink" title="添加域名解析"></a>添加域名解析</h3><p>域名解析的记录类型为CNAME 记录值为xxxxx.github.io   //xxxxx为你的用户名</p><p>在博客目录的source文件夹添加一个CNAME文件 没有.txt或者其他</p><p>文件内容为<strong>个人域名</strong>(注意：没有http://和www)</p><p>然后一系列的命令同步到github远程仓库</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure></div><p>等域名解析更新后就可以通过域名访问博客了</p><h2 id="五、新电脑上继续写博客"><a href="#五、新电脑上继续写博客" class="headerlink" title="五、新电脑上继续写博客"></a>五、新电脑上继续写博客</h2><p>现在新电脑上安装Git 、 node.js</p><h3 id="克隆远程代码到本地"><a href="#克隆远程代码到本地" class="headerlink" title="克隆远程代码到本地"></a>克隆远程代码到本地</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone xxxxxxx</span><br></pre></td></tr></table></figure></div><h3 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure></div><h3 id="安装hexo需要的依赖包"><a href="#安装hexo需要的依赖包" class="headerlink" title="安装hexo需要的依赖包"></a>安装hexo需要的依赖包</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure></div><h3 id="安装部署到github所需要的依赖包"><a href="#安装部署到github所需要的依赖包" class="headerlink" title="安装部署到github所需要的依赖包"></a>安装部署到github所需要的依赖包</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm  install hexo-deployer-git  --save</span><br></pre></td></tr></table></figure></div><h3 id="安装gulp"><a href="#安装gulp" class="headerlink" title="安装gulp"></a>安装gulp</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install gulp -g</span><br></pre></td></tr></table></figure></div><p>然后就是正常些博客的步骤了</p><h2 id="快速发布博客快捷设置"><a href="#快速发布博客快捷设置" class="headerlink" title="快速发布博客快捷设置"></a>快速发布博客快捷设置</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global alias.bp &#39;!hexo clean;hexo g;gulp g;hexo d&#39;</span><br></pre></td></tr></table></figure></div><p>然后使用 git bp 就可以一键更新博客并发布了(cd 后面的目录为你的博客文件目录）<br>取消方式</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global --unset alias.bp</span><br></pre></td></tr></table></figure></div><h3 id="快速推送"><a href="#快速推送" class="headerlink" title="快速推送"></a>快速推送</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global alias.fp &#39;!git add .;git commit -m &quot;快速push&quot;;git push&#39;</span><br></pre></td></tr></table></figure></div><p>取消方法同上，不建议使用，最好老老实实写commit</p><p>关于博客的个性化可以看我的另一篇文章<a href="https://sxz799.ml/2019/04/13/Hexo%E5%8D%9A%E5%AE%A2%E4%B8%AA%E6%80%A7%E5%8C%96%E5%AE%9A%E5%88%B6/" target="_blank" rel="noopener">这是链接</a></p><p>转载注明出处 谢谢</p>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结 </tag>
            
            <tag> 经验 </tag>
            
            <tag> 博客 </tag>
            
            <tag> hexo </tag>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>存储器与CPU的连接</title>
      <link href="/2019/03/19/2019-03-19-%E3%80%90%E4%B8%8A%E8%AF%BE%E6%80%BB%E7%BB%93%E3%80%91%E5%AD%98%E5%82%A8%E5%99%A8%E4%B8%8ECPU%E7%9A%84%E8%BF%9E%E6%8E%A5/"/>
      <url>/2019/03/19/2019-03-19-%E3%80%90%E4%B8%8A%E8%AF%BE%E6%80%BB%E7%BB%93%E3%80%91%E5%AD%98%E5%82%A8%E5%99%A8%E4%B8%8ECPU%E7%9A%84%E8%BF%9E%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>课堂知识点记录</p><h2 id="一、存储器容量的扩展"><a href="#一、存储器容量的扩展" class="headerlink" title="一、存储器容量的扩展"></a>一、存储器容量的扩展</h2><h3 id="1-位扩展-增加存储字长"><a href="#1-位扩展-增加存储字长" class="headerlink" title="1.位扩展(增加存储字长)"></a>1.位扩展(增加存储字长)</h3><a href="https://raw.githubusercontent.com/sxz799/blog_tuchuang/master/img/20190319173054.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img width="600px" data-src="https://raw.githubusercontent.com/sxz799/blog_tuchuang/master/img/20190319173054.png" class="lazyload"></a><h3 id="2-字扩展（增加存储字的数量）"><a href="#2-字扩展（增加存储字的数量）" class="headerlink" title="2.字扩展（增加存储字的数量）"></a>2.字扩展（增加存储字的数量）</h3><a href="https://raw.githubusercontent.com/sxz799/blog_tuchuang/master/img/20190319173301.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img width="600px" data-src="https://raw.githubusercontent.com/sxz799/blog_tuchuang/master/img/20190319173301.png" class="lazyload"></a><h3 id="3-字和位同时扩展"><a href="#3-字和位同时扩展" class="headerlink" title="3.字和位同时扩展"></a>3.字和位同时扩展</h3><a href="https://raw.githubusercontent.com/sxz799/blog_tuchuang/master/img/20190319173429.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img width="600px" data-src="https://raw.githubusercontent.com/sxz799/blog_tuchuang/master/img/20190319173429.png" class="lazyload"></a><h2 id="二、存储器与CPU连接"><a href="#二、存储器与CPU连接" class="headerlink" title="二、存储器与CPU连接"></a>二、存储器与CPU连接</h2><pre><code>1.合理选择存储芯片2.数据线的连接3.读写命令线的连接4.地址线的连接5.片选线的连接6.其他，如 时序、负载</code></pre><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">设CPU有16根地址线、8根数据线，公用MREQ作为访存控制信号（低电平有效），用WR作为读写控制信号（高电平读，低电平写）。现有下列存储芯片：其中RAM芯片有1K×4、 4K×8、 8K×8，ROM芯片有2K×8、 4K×8、 8K×8，及74138译码器和各种门电路。</span><br><span class="line">画出CPU与存储器的连接图，要求如下：</span><br><span class="line">贮存地址空间分配：</span><br><span class="line">1）6000H~67FFH为系统程序区。</span><br><span class="line">6800H~6BFFH为用户程序区。</span><br><span class="line">2) 合理选用上述存储芯片，说明各选几片。</span><br><span class="line">3) 详细画出存储芯片的片选逻辑图。</span><br></pre></td></tr></table></figure></div><p>解答<br><a href="https://raw.githubusercontent.com/sxz799/blog_tuchuang/master/img/IMG_0260FF5CA11A-1.jpeg" data-fancybox="group" data-caption="undefined" class="fancybox"><img width="600px" data-src="https://raw.githubusercontent.com/sxz799/blog_tuchuang/master/img/IMG_0260FF5CA11A-1.jpeg" class="lazyload"></a><br>说明<br>1.16位地址线在ROM工作时A0-A10用于传送地址，A11-A13作为译码器的输入，A14-15和CPU的MRER作为74138译码器的使能输入。<br>2.当RAM工作时A10空闲，但是在CPU与存储器连接时不可以有空闲的地址线，故与74138的Y5输出通过与非门作用于RAM使其工作。<br>3.CPU的WR信号没有接入ROM是因为操作系统程序区一般不进行写操作。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
            <tag> 存储器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VMware虚拟机体验koolshare论坛LEDE固件</title>
      <link href="/2019/03/17/2019-03-17-%E3%80%90%E7%BE%A4%E8%BE%89&amp;%E8%BD%AF%E8%B7%AF%E7%94%B1%E3%80%91VMware%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%BD%93%E9%AA%8Ckoolshare%E8%AE%BA%E5%9D%9BLEDE%E5%9B%BA%E4%BB%B6/"/>
      <url>/2019/03/17/2019-03-17-%E3%80%90%E7%BE%A4%E8%BE%89&amp;%E8%BD%AF%E8%B7%AF%E7%94%B1%E3%80%91VMware%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%BD%93%E9%AA%8Ckoolshare%E8%AE%BA%E5%9D%9BLEDE%E5%9B%BA%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>​        博主自用的是路由器是斐讯K2P A2版，性能足够满足大多数家庭的需要了，但还是听说koolshare论坛的lede固件功能丰富，是软路由很常用的固件。只是现在用不到，也没有条件使用（毕竟价格接近4位数）。但看论坛截图里丰富的功能有些手痒，就打算在虚拟机里装上过过瘾。</p><h2 id="一、固件下载"><a href="#一、固件下载" class="headerlink" title="一、固件下载"></a>一、固件下载</h2><p>链接：<a href="http://firmware.koolshare.cn/LEDE_X64_fw867/" target="_blank" rel="noopener">http://firmware.koolshare.cn/LEDE_X64_fw867/</a><br>​链接是x64设备用的固件，有img格式和vmdk虚拟机专用的格式，这里选择虚拟机专用格式下载。</p><a href="https://raw.githubusercontent.com/sxz799/blog_tuchuang/master/img/QQ%E6%88%AA%E5%9B%BE20190317211318.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img width="800px" data-src="https://raw.githubusercontent.com/sxz799/blog_tuchuang/master/img/QQ%E6%88%AA%E5%9B%BE20190317211318.png" class="lazyload"></a><h2 id="二、安装LEDE"><a href="#二、安装LEDE" class="headerlink" title="二、安装LEDE"></a>二、安装LEDE</h2><p>和安装其他虚拟机没有什么区别，有几处需要注意的地方我已经在图中标记出来了。<br><a href="https://raw.githubusercontent.com/sxz799/blog_tuchuang/master/img/QQ%E6%88%AA%E5%9B%BE20190317211410.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img width="600px" data-src="https://raw.githubusercontent.com/sxz799/blog_tuchuang/master/img/QQ%E6%88%AA%E5%9B%BE20190317211410.png" class="lazyload"></a><br><a href="https://raw.githubusercontent.com/sxz799/blog_tuchuang/master/img/QQ%E6%88%AA%E5%9B%BE20190317211447.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img width="600px" data-src="https://raw.githubusercontent.com/sxz799/blog_tuchuang/master/img/QQ%E6%88%AA%E5%9B%BE20190317211447.png" class="lazyload"></a><br><a href="https://raw.githubusercontent.com/sxz799/blog_tuchuang/master/img/QQ%E6%88%AA%E5%9B%BE20190317211507.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img width="600px" data-src="https://raw.githubusercontent.com/sxz799/blog_tuchuang/master/img/QQ%E6%88%AA%E5%9B%BE20190317211507.png" class="lazyload"></a><br><a href="https://raw.githubusercontent.com/sxz799/blog_tuchuang/master/img/QQ%E6%88%AA%E5%9B%BE20190317211520.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img width="600px" data-src="https://raw.githubusercontent.com/sxz799/blog_tuchuang/master/img/QQ%E6%88%AA%E5%9B%BE20190317211520.png" class="lazyload"></a><br><a href="https://raw.githubusercontent.com/sxz799/blog_tuchuang/master/img/QQ%E6%88%AA%E5%9B%BE20190317211543.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img width="600px" data-src="https://raw.githubusercontent.com/sxz799/blog_tuchuang/master/img/QQ%E6%88%AA%E5%9B%BE20190317211543.png" class="lazyload"></a><br><a href="https://raw.githubusercontent.com/sxz799/blog_tuchuang/master/img/QQ%E6%88%AA%E5%9B%BE20190317211600.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img width="600px" data-src="https://raw.githubusercontent.com/sxz799/blog_tuchuang/master/img/QQ%E6%88%AA%E5%9B%BE20190317211600.png" class="lazyload"></a><br><a href="https://raw.githubusercontent.com/sxz799/blog_tuchuang/master/img/QQ%E6%88%AA%E5%9B%BE20190317211639.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img width="600px" data-src="https://raw.githubusercontent.com/sxz799/blog_tuchuang/master/img/QQ%E6%88%AA%E5%9B%BE20190317211639.png" class="lazyload"></a><br>安装到这里就差不多了。主要区别就是选择稍后安装操作系统，然后磁盘选择第一步中下载的文件和添加了一张网卡而已。<br>安装后不要启动！<br>安装后不要启动！<br>安装后不要启动！</p><h2 id="三、虚拟机网卡配置"><a href="#三、虚拟机网卡配置" class="headerlink" title="三、虚拟机网卡配置"></a>三、虚拟机网卡配置</h2><p>和上一篇文章类似，设置VMware虚拟网卡。这里设置桥接网卡为计算机的网卡。nat地址和上一篇文章一样。<br><a href="https://raw.githubusercontent.com/sxz799/blog_tuchuang/master/img/QQ%E6%88%AA%E5%9B%BE20190317212324.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img width="600px" data-src="https://raw.githubusercontent.com/sxz799/blog_tuchuang/master/img/QQ%E6%88%AA%E5%9B%BE20190317212324.png" class="lazyload"></a><br><a href="https://raw.githubusercontent.com/sxz799/blog_tuchuang/master/img/QQ%E6%88%AA%E5%9B%BE20190317212400.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img width="600px" data-src="https://raw.githubusercontent.com/sxz799/blog_tuchuang/master/img/QQ%E6%88%AA%E5%9B%BE20190317212400.png" class="lazyload"></a><br>然后设置lede系统的网卡<br><a href="https://raw.githubusercontent.com/sxz799/blog_tuchuang/master/img/QQ%E6%88%AA%E5%9B%BE20190317212958.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img width="600px" data-src="https://raw.githubusercontent.com/sxz799/blog_tuchuang/master/img/QQ%E6%88%AA%E5%9B%BE20190317212958.png" class="lazyload"></a><br>配置好以后启动虚拟机。启动完毕后鼠标点击虚拟机内部<br>然后输入<br><code>vi /etc/config/network</code><br>修改lan口的地址<br><a href="https://raw.githubusercontent.com/sxz799/blog_tuchuang/master/img/QQ%E6%88%AA%E5%9B%BE20190317212511.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img width="600px" data-src="https://raw.githubusercontent.com/sxz799/blog_tuchuang/master/img/QQ%E6%88%AA%E5%9B%BE20190317212511.png" class="lazyload"></a><br>然后取消勾选本地连接中的ipv4和ipv6协议。  重点！重点！重点！重点！</p><h2 id="四、配置VMware-Network-Adapter-VMnet8"><a href="#四、配置VMware-Network-Adapter-VMnet8" class="headerlink" title="四、配置VMware Network Adapter VMnet8"></a>四、配置VMware Network Adapter VMnet8</h2><p>和上篇文章不同的是，这里我们的目的是通过虚拟机路由器系统进行上网，所以要配置上网关<br>如下图<br><a href="https://raw.githubusercontent.com/sxz799/blog_tuchuang/master/img/20190320192006.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img width="600px" data-src="https://raw.githubusercontent.com/sxz799/blog_tuchuang/master/img/20190320192006.png" class="lazyload"></a></p><p>教程结束！<br>//2019年03月20日19:26:46 更新</p><p>转载注明出处 谢谢</p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 虚拟机 </tag>
            
            <tag> 路由器 </tag>
            
            <tag> LEDE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚拟机内系统通过NAT方式连接外网，同时与本机进行通信</title>
      <link href="/2019/03/13/2019-03-13-%E3%80%90%E7%BE%A4%E8%BE%89&amp;%E8%BD%AF%E8%B7%AF%E7%94%B1%E3%80%91%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%86%85%E7%B3%BB%E7%BB%9F%E9%80%9A%E8%BF%87NAT%E6%96%B9%E5%BC%8F%E8%BF%9E%E6%8E%A5%E5%A4%96%E7%BD%91%EF%BC%8C%E5%90%8C%E6%97%B6%E4%B8%8E%E6%9C%AC%E6%9C%BA%E8%BF%9B%E8%A1%8C%E9%80%9A%E4%BF%A1/"/>
      <url>/2019/03/13/2019-03-13-%E3%80%90%E7%BE%A4%E8%BE%89&amp;%E8%BD%AF%E8%B7%AF%E7%94%B1%E3%80%91%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%86%85%E7%B3%BB%E7%BB%9F%E9%80%9A%E8%BF%87NAT%E6%96%B9%E5%BC%8F%E8%BF%9E%E6%8E%A5%E5%A4%96%E7%BD%91%EF%BC%8C%E5%90%8C%E6%97%B6%E4%B8%8E%E6%9C%AC%E6%9C%BA%E8%BF%9B%E8%A1%8C%E9%80%9A%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>就在今天下午上课的时候突然发现自己好久没有写blog了，可能最近学习太忙，也可能最近没啥好写的。今天上课的时候有同学问到我关于虚拟机系统连接外网的问题，所以打算写这么一篇blog，也算加深一下自己的印象吧。</p><p>自求学以来，实验课用到的虚拟机软件都是VMware，相信大部分人对这个软件也不陌生，除了这个就是win10自带的Hyper-V虚拟机了.这里就简单的写一下VMware用NAT方式连接外网。</p><h2 id="第一步-配置VMware的虚拟网络编辑器"><a href="#第一步-配置VMware的虚拟网络编辑器" class="headerlink" title="第一步 配置VMware的虚拟网络编辑器"></a>第一步 配置VMware的虚拟网络编辑器</h2><p>①    在VMware的菜单栏中点击编辑，在弹出的菜单中选择虚拟网络编辑器，在弹出的窗口中点击更改设置，可能会提示需要管理员权限，确定即可。<br><a href="https://raw.githubusercontent.com/sxz799/blog_tuchuang/master/img/20190313230606.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img width="600px" data-src="https://raw.githubusercontent.com/sxz799/blog_tuchuang/master/img/20190313230606.png" class="lazyload"></a><br>②    在新弹出的界面中点击VMware8 这是VMware默认的nat模式，可以用这个默认的网络，也可以新建一个，这里没有什么区别。选中该网络后修改配置为图中的配置。下方的子网网段可自己定义。没有什么影响，只要不和上面的网络冲突即可（建议使用默认的）。然后点击图中的NAT设置，网关可以修改，建议使用默认，并记住这个网关。<br><a href="https://raw.githubusercontent.com/sxz799/blog_tuchuang/master/img/20190313230623.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img width="600px" data-src="https://raw.githubusercontent.com/sxz799/blog_tuchuang/master/img/20190313230623.png" class="lazyload"></a><br>③    设置虚拟机网卡为VMware8 NAT模式，这个就很简单了，根据图中的步骤来即可。到这里VMware的设计就完成了。<br><a href="https://raw.githubusercontent.com/sxz799/blog_tuchuang/master/img/20190313230929.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img width="600px" data-src="https://raw.githubusercontent.com/sxz799/blog_tuchuang/master/img/20190313230929.png" class="lazyload"></a><br><a href="https://raw.githubusercontent.com/sxz799/blog_tuchuang/master/img/20190313230938.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img width="600px" data-src="https://raw.githubusercontent.com/sxz799/blog_tuchuang/master/img/20190313230938.png" class="lazyload"></a></p><h2 id="第二步-修改虚拟机系统的网络连接设置"><a href="#第二步-修改虚拟机系统的网络连接设置" class="headerlink" title="第二步 修改虚拟机系统的网络连接设置"></a>第二步 修改虚拟机系统的网络连接设置</h2><p>这一步非常简单，因为大家用的系统不一样，设置界面也不尽相同，这里以centos7系统为例，简单介绍一下。这里的IP地址不是固定的只要在同一网段内即可。但是网关地址一定是上一步中nat设置中的网关地址。完成这一步虚拟机应该就可以连接外网使用百度了。<br><a href="https://raw.githubusercontent.com/sxz799/blog_tuchuang/master/img/20190313231100.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img width="600px" data-src="https://raw.githubusercontent.com/sxz799/blog_tuchuang/master/img/20190313231100.png" class="lazyload"></a><br><a href="https://raw.githubusercontent.com/sxz799/blog_tuchuang/master/img/20190313231107.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img width="600px" data-src="https://raw.githubusercontent.com/sxz799/blog_tuchuang/master/img/20190313231107.png" class="lazyload"></a></p><h2 id="三-建立虚拟机与宿主机的连接。"><a href="#三-建立虚拟机与宿主机的连接。" class="headerlink" title="三 建立虚拟机与宿主机的连接。"></a>三 建立虚拟机与宿主机的连接。</h2><p>此时虚拟机虽然可以连接外网，但并不能和宿主机进行通信，也就是说此时的宿主机并不能ping通虚拟机的ip。想要建立连接也很简单。只需要设置一下网络适配器中的VMware Network Adapter VMnet8 网卡的ip和子网掩码即可。<br><a href="https://raw.githubusercontent.com/sxz799/blog_tuchuang/master/img/20190313231137.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img width="600px" data-src="https://raw.githubusercontent.com/sxz799/blog_tuchuang/master/img/20190313231137.png" class="lazyload"></a><br><a href="https://raw.githubusercontent.com/sxz799/blog_tuchuang/master/img/20190313231145.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img width="600px" data-src="https://raw.githubusercontent.com/sxz799/blog_tuchuang/master/img/20190313231145.png" class="lazyload"></a></p><p>注：如果是学校的机房，或者用过脚本优化的电脑可能开机后不会启动VMware的一些必要的服务，可以手动开启。详见下图<br><a href="https://raw.githubusercontent.com/sxz799/blog_tuchuang/master/img/20190320191922.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img data-src="https://raw.githubusercontent.com/sxz799/blog_tuchuang/master/img/20190320191922.png" class="lazyload"></a><br><a href="https://raw.githubusercontent.com/sxz799/blog_tuchuang/master/img/20190320191944.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img width="600px" data-src="https://raw.githubusercontent.com/sxz799/blog_tuchuang/master/img/20190320191944.png" class="lazyload"></a></p><p>//2019年03月20日19:25:10 更新<br>转载注明出处 谢谢</p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EntityFramework延迟查询与事务实现</title>
      <link href="/2019/03/02/EntityFramework%E5%BB%B6%E8%BF%9F%E6%9F%A5%E8%AF%A2%E4%B8%8E%E4%BA%8B%E5%8A%A1%E5%AE%9E%E7%8E%B0/"/>
      <url>/2019/03/02/EntityFramework%E5%BB%B6%E8%BF%9F%E6%9F%A5%E8%AF%A2%E4%B8%8E%E4%BA%8B%E5%8A%A1%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ol><li>各种复杂查询</li><li>EF状态跟踪，本地增删改实现</li><li>Context生命周期，多种事务</li><li>EF延迟查询，导航属性加载&amp;增加&amp;删除</li></ol><h2 id="EF执行SQl语句"><a href="#EF执行SQl语句" class="headerlink" title="EF执行SQl语句"></a>EF执行SQl语句</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">string sql &#x3D;&quot;update [user] set name&#x3D;&#39;张三&#39; where id&#x3D;@id&quot;</span><br><span class="line">SqlParameter parameter &#x3D; new SqlParameter(&quot;id&quot;,1)</span><br><span class="line">--更新</span><br><span class="line">dbContext.Database.ExecuteSqlCommand(sql,parameter)</span><br><span class="line">--查询</span><br><span class="line">var list &#x3D; dbContext.Database.SqlQuery&lt;User&gt;(sql,parameter).ToList();</span><br></pre></td></tr></table></figure></div><h2 id="Context生命周期"><a href="#Context生命周期" class="headerlink" title="Context生命周期"></a>Context生命周期</h2><p><strong>SaveChanges：</strong>是以context为标准的，如果监听到任何数据的变化，会一次性的同步到数据库，而且会开启事务</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--打印当前实体状态</span><br><span class="line">context.Entry&lt;User&gt;(userNew).State</span><br></pre></td></tr></table></figure></div><p><strong>枚举EntityEntry</strong></p><p>Detached ：无状态<br>Unchanged：实体将有上下文跟踪并存在于数据库中，其属性值与数据库中的值相同<br>Added：实体将由上下文跟踪，但是在书库中还不存在<br>Deleted：实体将有上下文跟踪并删除，但存在数据库中<br>Modified：实体将有上下文跟踪并存在于数据库中，已修改其中的一些或所有属性值</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EntityFramework </tag>
            
            <tag> EF6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EntityFramework三种模式对比应用</title>
      <link href="/2019/03/02/EntityFramework%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%BC%8F%E5%AF%B9%E6%AF%94%E5%BA%94%E7%94%A8/"/>
      <url>/2019/03/02/EntityFramework%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%BC%8F%E5%AF%B9%E6%AF%94%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><a href="/images/20200302173306.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/20200302173306.png" class="lazyload"></a></p><h3 id="什么时ORM"><a href="#什么时ORM" class="headerlink" title="什么时ORM"></a>什么时ORM</h3><p>Object Relational Mapping</p><p>对象关系映射（Object Relational Mapping，简称ORM）是通过使用描述对象和数据库之间映射的元数据，将面向对象语言程序中的对象自动持久化到关系数据库中</p><p><strong>常用ORM</strong></p><blockquote><p>NHibernate<br>EF<br>LinqToSql<br>Dapper<br>IBatis.Net<br>SqlSugar</p></blockquote><p><strong>EF6的特点：</strong>支持多个数据库；支持函数；存储过程；跟VS结合很好；跟项目完美结合；</p><blockquote><p><strong>context：</strong>映射数据库实例</p></blockquote><p><strong>EF中查询Sql语句的方式</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1：通过Sql Server Profiler</span><br><span class="line">2：context.Database.Log +&#x3D; s &#x3D;&gt; Console.WriteLine($&quot;当前执行的SQL:&#123;s&#125;&quot;);</span><br></pre></td></tr></table></figure></div><h2 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h2><ol><li>特性映射</li><li>OnModelCreating完成链式映射</li><li>映射类文件</li></ol><h2 id="DBFirst"><a href="#DBFirst" class="headerlink" title="DBFirst"></a>DBFirst</h2><p>数据库优先，传统的开发模式，有个很重的<strong>edmx</strong></p><h2 id="CodeFirst"><a href="#CodeFirst" class="headerlink" title="CodeFirst"></a>CodeFirst</h2><h3 id="来自数据库的CodeFirst"><a href="#来自数据库的CodeFirst" class="headerlink" title="来自数据库的CodeFirst"></a>来自数据库的CodeFirst</h3><p>先有数据库</p><h3 id="CodeFirst-1"><a href="#CodeFirst-1" class="headerlink" title="CodeFirst"></a>CodeFirst</h3><p>代码先行，不关心数据库，从业务出发，能自动生成数据库</p><p><a href="/images/20200302182832.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/images/20200302182832.png" class="lazyload"></a></p><h2 id="ModelFirst"><a href="#ModelFirst" class="headerlink" title="ModelFirst"></a>ModelFirst</h2><p>空的数据库模型</p><blockquote><p>其实大体上EF之有DBFirst和CodeFirst两种方式</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EntityFramework </tag>
            
            <tag> EF6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RSA的签名加密</title>
      <link href="/2019/01/12/2019-01-12-%E3%80%90%E4%B8%8A%E8%AF%BE%E6%80%BB%E7%BB%93%E3%80%91RSA%E7%AE%80%E4%BB%8B%E5%8F%8A%E7%AD%BE%E5%90%8D%E5%8A%A0%E5%AF%86%E4%BB%8B%E7%BB%8D/"/>
      <url>/2019/01/12/2019-01-12-%E3%80%90%E4%B8%8A%E8%AF%BE%E6%80%BB%E7%BB%93%E3%80%91RSA%E7%AE%80%E4%BB%8B%E5%8F%8A%E7%AD%BE%E5%90%8D%E5%8A%A0%E5%AF%86%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>RSA公钥密码算法是由美国麻省理工学院的Rivest，Shamir和Adleman在1978年提出来的。RSA方案是唯一被广泛接受并实现的通用公钥密码算法，目前已经成为公钥密码的国际标准。该算法的数学基础是初等数论中的Eular定理，其安全性建立在大整数因子分解的困难性之上。</p><h3 id="RSA算法描述"><a href="#RSA算法描述" class="headerlink" title="RSA算法描述"></a>RSA算法描述</h3><p>1.选择两个互异的大素数p和q（保密），计算n=p*q。φ(n)=(p-1)(q-1) (保密)。选择一个随机整数e（大于0小于φ(n)）。计算d为e关于φ(n)的乘法逆元。公钥为{e,n},私钥为{d,n}。<br>2.加密 C=M^e mod n<br>3.解密 M=C^d mod n</p><h3 id="RSA签名加密"><a href="#RSA签名加密" class="headerlink" title="RSA签名加密"></a>RSA签名加密</h3><p>1.发送方先通过杂凑函数计算出明文的消息摘要，然后用自己私钥对消息摘要进行加密，然后用接收方的公钥对加密后消息摘要进行二次加密和对要发送的明文进行加密。发送给接收方。<br>2.接收方收到消息后先用自己的私钥对收到的二次加密后的消息摘要和密文进行解密。此时接收方收到明文和发送方用其私钥加密的消息摘要。接收方用发送方的公钥对加密后消息签名进行解密获得消息摘要。此时接收方用同样的杂凑函数获取解密后的明文的消息摘要，然后与收到的消息摘要对比。如果相同则证明是真正的发送方的消息。而且保证消息的完整性。<br>注意：消息摘要进行了2次加密，第一次是发送方的私钥加密，第二次是发送方的公钥。<br>转载注明出处 谢谢</p>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 密码学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ARM处理的八种寻址方式</title>
      <link href="/2018/12/24/2018-12-24-%E3%80%90%E4%B8%8A%E8%AF%BE%E6%80%BB%E7%BB%93%E3%80%91ARM%E5%A4%84%E7%90%86%E7%9A%84%E5%85%AB%E7%A7%8D%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F/"/>
      <url>/2018/12/24/2018-12-24-%E3%80%90%E4%B8%8A%E8%AF%BE%E6%80%BB%E7%BB%93%E3%80%91ARM%E5%A4%84%E7%90%86%E7%9A%84%E5%85%AB%E7%A7%8D%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>ARM处理的八种寻址方式 </p><h2 id="一、寄存器寻址"><a href="#一、寄存器寻址" class="headerlink" title="一、寄存器寻址"></a>一、寄存器寻址</h2><p>操作数的值在寄存器中，指令中的地址码字段指出的是寄存器编号，指令执行时直接取出寄存器值来操作。<br><a href="https://i.loli.net/2018/12/24/5c20e29b21058.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img width="600px" data-src="https://i.loli.net/2018/12/24/5c20e29b21058.png" class="lazyload"></a><br><a href="https://i.loli.net/2018/12/24/5c20e2abf2454.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img width="600px" data-src="https://i.loli.net/2018/12/24/5c20e2abf2454.png" class="lazyload"></a></p><h2 id="二、立即寻址"><a href="#二、立即寻址" class="headerlink" title="二、立即寻址"></a>二、立即寻址</h2><p>立即寻址指令中的操作码字段后面的地址码部分即是操作数本身，也就是说，数据就包含在指令当中，取出指令也就取出了可以立即使用的操作数(这样的数称为立即数)。<br><a href="https://i.loli.net/2018/12/24/5c20e371131db.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img width="600px" data-src="https://i.loli.net/2018/12/24/5c20e371131db.png" class="lazyload"></a><br><a href="https://i.loli.net/2018/12/24/5c20e382ab2b5.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img width="600px" data-src="https://i.loli.net/2018/12/24/5c20e382ab2b5.png" class="lazyload"></a></p><h2 id="三、寄存器移位寻址"><a href="#三、寄存器移位寻址" class="headerlink" title="三、寄存器移位寻址"></a>三、寄存器移位寻址</h2><p>寄存器移位寻址是ARM指令集特有的寻址方式。当第2个操作数是寄存器移位方式时，第2个寄存器操作数在与第1个操作数结合之前，选择进行移位操作。<br><a href="https://i.loli.net/2018/12/24/5c20e418ef3ba.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img width="600px" data-src="https://i.loli.net/2018/12/24/5c20e418ef3ba.png" class="lazyload"></a><br><a href="https://i.loli.net/2018/12/24/5c20e42bd67b7.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img width="600px" data-src="https://i.loli.net/2018/12/24/5c20e42bd67b7.png" class="lazyload"></a></p><h2 id="四、寄存器间接寻址"><a href="#四、寄存器间接寻址" class="headerlink" title="四、寄存器间接寻址"></a>四、寄存器间接寻址</h2><p>寄存器间接寻址指令中的地址码给出的是一个通用寄存器的编号，所需的操作数保存在寄存器指定地址的存储单元中，即寄存器为操作数的地址指针。<br><a href="https://i.loli.net/2018/12/24/5c20e54ac11a9.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img width="600px" data-src="https://i.loli.net/2018/12/24/5c20e54ac11a9.png" class="lazyload"></a><br><a href="https://i.loli.net/2018/12/24/5c20e51dede59.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img width="600px" data-src="https://i.loli.net/2018/12/24/5c20e51dede59.png" class="lazyload"></a></p><h2 id="五、基址寻址"><a href="#五、基址寻址" class="headerlink" title="五、基址寻址"></a>五、基址寻址</h2><p>基址寻址就是将基址寄存器的内容与指令中给出的偏移量相加，形成操作数的有效地址。基址寻址用于访问基址附近的存储单元，常用于查表、数组操作、功能部件寄存器问等。<br><a href="https://i.loli.net/2018/12/24/5c20e5c9e91ee.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img width="600px" data-src="https://i.loli.net/2018/12/24/5c20e5c9e91ee.png" class="lazyload"></a><br><a href="https://i.loli.net/2018/12/24/5c20e5df5c5bd.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img width="600px" data-src="https://i.loli.net/2018/12/24/5c20e5df5c5bd.png" class="lazyload"></a></p><h2 id="六、多寄存器寻址"><a href="#六、多寄存器寻址" class="headerlink" title="六、多寄存器寻址"></a>六、多寄存器寻址</h2><p>多寄存器寻址一次可传送几个寄存器值，允许一条指令传送16个寄存器的任何子集或所有寄存器。<br><a href="https://i.loli.net/2018/12/24/5c20e62d70e87.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img width="600px" data-src="https://i.loli.net/2018/12/24/5c20e62d70e87.png" class="lazyload"></a><br><a href="https://i.loli.net/2018/12/24/5c20e63d66e3e.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img width="600px" data-src="https://i.loli.net/2018/12/24/5c20e63d66e3e.png" class="lazyload"></a><br>在多寄存器寻址中会进行2个操作，①是操作数据②是修改地址<br>LDMIA中的A表示先进行①操作，再进行②操作。如果是LDMIB则先②后①<br>LDMIA中的I表示存储器地址由低到高操作。如果是D则表示由高到低。  </p><h2 id="七、堆栈寻址"><a href="#七、堆栈寻址" class="headerlink" title="七、堆栈寻址"></a>七、堆栈寻址</h2><p>堆栈是一个按特定顺序进行存取的存储区，操作顺序为“后进先出” 。堆栈寻址是隐含的，它使用一个专门的寄存器(堆栈指针)  指向一块存储区域(堆栈，指针所指向的存储单元即是堆栈的栈顶。存储器堆栈可分为两种：<br>向上生长：向高地址方向生长，称为递增堆栈<br>向下生长：向低地址方向生长，称为递减堆栈<br>堆栈指针指向最后压入的堆栈的有效数据项，称为满堆栈；堆栈指针指向下一个待压入数据的空位置，称为空堆栈。<br>所有可以组合出四种类型的堆栈方式：<br>满递增：堆栈向上增长，堆栈指针指向内含有效数据项的最高地址。指令如LDMFA、STMFA等；<br>空递增：堆栈向上增长，堆栈指针指向堆栈上的第一个空位置。指令如LDMEA、STMEA等；<br>满递减：堆栈向下增长，堆栈指针指向内含有效数据项的最低地址。指令如LDMFD、STMFD等；<br>空递减：堆栈向下增长，堆栈指针向堆栈下的第一个空位置。指令如LDMED、STMED等。<br><a href="https://i.loli.net/2018/12/24/5c20e77846866.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img width="600px" data-src="https://i.loli.net/2018/12/24/5c20e77846866.png" class="lazyload"></a><br><a href="https://i.loli.net/2018/12/24/5c20e7875aa60.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img width="600px" data-src="https://i.loli.net/2018/12/24/5c20e7875aa60.png" class="lazyload"></a></p><h2 id="八、相对寻址"><a href="#八、相对寻址" class="headerlink" title="八、相对寻址"></a>八、相对寻址</h2><p>相对寻址是基址寻址的一种变通。由程序计数器PC提供基准地址，指令中的地址码字段作为偏移量，两者相加后得到的地址即为操作数的有效地址。<br><a href="https://i.loli.net/2018/12/24/5c20e7b55552c.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img width="600px" data-src="https://i.loli.net/2018/12/24/5c20e7b55552c.png" class="lazyload"></a></p><p>转载注明出处 谢谢</p>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> ARM嵌入式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《ARM嵌入式》提纲总结</title>
      <link href="/2018/12/20/2018-12-20-%E3%80%90%E4%B8%8A%E8%AF%BE%E6%80%BB%E7%BB%93%E3%80%91%E3%80%8AARM%E5%B5%8C%E5%85%A5%E5%BC%8F%E3%80%8B%E6%8F%90%E7%BA%B2%E6%80%BB%E7%BB%93/"/>
      <url>/2018/12/20/2018-12-20-%E3%80%90%E4%B8%8A%E8%AF%BE%E6%80%BB%E7%BB%93%E3%80%91%E3%80%8AARM%E5%B5%8C%E5%85%A5%E5%BC%8F%E3%80%8B%E6%8F%90%E7%BA%B2%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="一、Bootloader在嵌入式系统中主要起什么作用？完成哪些工作？"><a href="#一、Bootloader在嵌入式系统中主要起什么作用？完成哪些工作？" class="headerlink" title="一、Bootloader在嵌入式系统中主要起什么作用？完成哪些工作？"></a>一、Bootloader在嵌入式系统中主要起什么作用？完成哪些工作？</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">答：Boot Loader是在操作系统内核运行之前运行的一段小程序。属于嵌入式软件最底层的部分。</span><br><span class="line">​    整个系统的加载启动任务就完全由Bootloader完成</span><br><span class="line">​    Bootloader初始化硬件设备、建立内存空间的映射图，从而将系统的软硬件环境设定在一个正确的状态，以便接下来加载操作系统内核、运行用户应用程序。</span><br><span class="line">​Bootloader两种加载方式：</span><br><span class="line">​①启动加载模式：也称自主（Autonomous）模式 ，是指Bootloader从目标机上的某个固态存储设备上将操作系统加载到RAM中运行，整个过程并没有用户的介入。是Bootloader的正常工作模式，在嵌入式产品完工交付时或者实际使用时，必须使得Bootloader工作在这种模式下 。</span><br><span class="line">​②下载模式：目标板上的Bootloader将先通过串口连接或网络连接等通信手段从主机下载文件，Bootloader 的这种模式通常在开发过程中以及第一次安装内核与根文件系统时被使用，此外，以后的系统更新也会用到Bootloader的这种工作模式。这种模式下的Bootloader通常都会向它的终端用户提供一个简单的命令行接口</span><br></pre></td></tr></table></figure></div><h3 id="二、ARM核用于存储PC的是什么寄存器？R13-R14分别存储什么？"><a href="#二、ARM核用于存储PC的是什么寄存器？R13-R14分别存储什么？" class="headerlink" title="二、ARM核用于存储PC的是什么寄存器？R13,R14分别存储什么？"></a>二、ARM核用于存储PC的是什么寄存器？R13,R14分别存储什么？</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">​R15用于存储PC(程序计数寄存器)。</span><br><span class="line">​R13通常作为堆栈指针(SP),用于保存待使用的寄存器内容。</span><br><span class="line">​R14称为链接寄存器（LR)</span><br><span class="line">​①使用BL指令调用子程序时，返回地址自动存入R14中；</span><br><span class="line">​②发生异常时，R14对应得异常模式版本设置为异常返回地址。</span><br></pre></td></tr></table></figure></div><h3 id="三、嵌入式系统的概念，组成，特点？"><a href="#三、嵌入式系统的概念，组成，特点？" class="headerlink" title="三、嵌入式系统的概念，组成，特点？"></a>三、嵌入式系统的概念，组成，特点？</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">​通俗来说：包含（安装）在电子装置（应用对象）内部的计算机系统称为嵌入式系统。</span><br><span class="line">​国内高校流行的定义：嵌入式系统是以应用为中心，以计算机技术为基础，并且软硬件可裁剪，适用于应用系统对功能、可靠性、成本、体积、功耗有严格要求的专用计算机系统。</span><br><span class="line">​组成：一般是由嵌入式微处理器、外围硬件设备、嵌入式操作系统以及用户的应用程序组成。</span><br><span class="line">​硬件：</span><br><span class="line">​嵌入式处理器、各种类型存储器、模拟电路及电源、接口控制器及接插件</span><br><span class="line">​软件：</span><br><span class="line">​实时操作系统（RTOS）、设备驱动（Device Driver）、协议栈（Protocol Stack）、应用程序（Application）</span><br><span class="line">​特点：</span><br><span class="line">​1专门用于特定任务</span><br><span class="line">​2技术融合</span><br><span class="line">​3有实时约束</span><br><span class="line">​4有功耗约束</span><br><span class="line">​5软件没有系统和应用的区别，软件固化。</span><br><span class="line">​6系统内核小</span><br><span class="line">​7软硬件可裁剪</span><br><span class="line">​8高可靠性</span><br><span class="line">​9资源比PC少得多</span><br><span class="line">​10嵌入式系统需要专用的开发工具</span><br><span class="line">​11非垄断市场</span><br></pre></td></tr></table></figure></div><h3 id="四、有时要使用thumb的原因？"><a href="#四、有时要使用thumb的原因？" class="headerlink" title="四、有时要使用thumb的原因？"></a>四、有时要使用thumb的原因？</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">​平衡代码性能和系统成本</span><br><span class="line">​准许编码为更短的16位机器指令</span><br></pre></td></tr></table></figure></div><h3 id="五、ARM处理器的工作模式有哪几种？"><a href="#五、ARM处理器的工作模式有哪几种？" class="headerlink" title="五、ARM处理器的工作模式有哪几种？"></a>五、ARM处理器的工作模式有哪几种？</h3><a href="https://i.loli.net/2018/12/20/5c1ac4e7ca676.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img width="600px" data-src="https://i.loli.net/2018/12/20/5c1ac4e7ca676.png" class="lazyload"></a><h3 id="六、寄存器CPSR，SPSR的功能各是什么？"><a href="#六、寄存器CPSR，SPSR的功能各是什么？" class="headerlink" title="六、寄存器CPSR，SPSR的功能各是什么？"></a>六、寄存器CPSR，SPSR的功能各是什么？</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CPSR：当前程序状态寄存器</span><br><span class="line">SPSR：程序状态保存寄存器（备份程序状态寄存器）</span><br><span class="line">CPSR在任何处理器模式下都可以访问，用于用户级编程时保存条件码</span><br><span class="line">​异常发生时，SPSR保存CPSR的状态（内容），异常恢复后用SPSR来回复CPSR</span><br><span class="line">​注意：用户模式和系统模式不是异常中断模式，所以没有SPSR!</span><br></pre></td></tr></table></figure></div><h3 id="七、ARM异常有几种？各进入什么工作模式？退出时采用什么指令？"><a href="#七、ARM异常有几种？各进入什么工作模式？退出时采用什么指令？" class="headerlink" title="七、ARM异常有几种？各进入什么工作模式？退出时采用什么指令？"></a>七、ARM异常有几种？各进入什么工作模式？退出时采用什么指令？</h3><p>​    <a href="https://i.loli.net/2018/12/24/5c20aa2fa69c8.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img width="600px" data-src="https://i.loli.net/2018/12/24/5c20aa2fa69c8.png" class="lazyload"></a><br>​    <a href="https://i.loli.net/2018/12/24/5c20aa3be4191.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img width="600px" data-src="https://i.loli.net/2018/12/24/5c20aa3be4191.png" class="lazyload"></a><br>​    异常的优先级：<br>​    <a href="https://i.loli.net/2018/12/24/5c20aa202c103.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img width="600px" data-src="https://i.loli.net/2018/12/24/5c20aa202c103.png" class="lazyload"></a></p><h3 id="八、什么是小端、大端存储器组织？"><a href="#八、什么是小端、大端存储器组织？" class="headerlink" title="八、什么是小端、大端存储器组织？"></a>八、什么是小端、大端存储器组织？</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">​小端：较高的有效字节存放在较高的存储器地址，较低的有效字节存放在较低的存储器地址。（同同小）</span><br><span class="line">​大端：较高的有效字节存放在较低的存储器地址，较低的有效字节存放在较高的存储器地址。（正反大）</span><br></pre></td></tr></table></figure></div><h3 id="九、-ARM7TDMI中的T、D、M、I分别表示什么含义？"><a href="#九、-ARM7TDMI中的T、D、M、I分别表示什么含义？" class="headerlink" title="九、    ARM7TDMI中的T、D、M、I分别表示什么含义？"></a>九、    ARM7TDMI中的T、D、M、I分别表示什么含义？</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">​ARM7是基于ARM体系结构V4版本的低端ARM核，弥补了ARM6很难在低于5V的电压下稳定工作的不足，并增加了一下功能</span><br><span class="line">​T:支持高密度16位的Thumb指令集</span><br><span class="line">​D:支持片上调试</span><br><span class="line">​M:支持64位乘法</span><br><span class="line">​I:支持EmbededICE观察硬件</span><br><span class="line">​注意：ARM核并非芯片，于RAM、ROM、片内外设等其他硬件组合在一起才称为芯片！</span><br></pre></td></tr></table></figure></div><h3 id="十、ARM7TDMI采用什么样的体系结构？其可寻址空间有多大？"><a href="#十、ARM7TDMI采用什么样的体系结构？其可寻址空间有多大？" class="headerlink" title="十、ARM7TDMI采用什么样的体系结构？其可寻址空间有多大？"></a>十、ARM7TDMI采用什么样的体系结构？其可寻址空间有多大？</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">​ARM7TDMI采用冯·诺依曼结构，指令和结构公用一条32位总线</span><br><span class="line">​数据可以是字节(8位)2^32、半字（16位）2^31或者字(32位)2^30。</span><br></pre></td></tr></table></figure></div><h3 id="十一、ARM7TDMI处理器采用几级流水线处理，使用何种存储器编址方式？"><a href="#十一、ARM7TDMI处理器采用几级流水线处理，使用何种存储器编址方式？" class="headerlink" title="十一、ARM7TDMI处理器采用几级流水线处理，使用何种存储器编址方式？"></a>十一、ARM7TDMI处理器采用几级流水线处理，使用何种存储器编址方式？</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">​ARM7TDMI处理器采用三级流水线</span><br><span class="line">​取址：从寄存器装载一条指令</span><br><span class="line">​编码：识别将要被执行的指令</span><br><span class="line">​执行：处理指令并将结果写会寄存器</span><br></pre></td></tr></table></figure></div><h3 id="十二、ARM处理器模式和ARM处理器状态有什么区别？"><a href="#十二、ARM处理器模式和ARM处理器状态有什么区别？" class="headerlink" title="十二、ARM处理器模式和ARM处理器状态有什么区别？"></a>十二、ARM处理器模式和ARM处理器状态有什么区别？</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">​ARM处理器模式共有7种</span><br><span class="line">​ARM处理器状态有2种，ARM状态和Thumb状态</span><br><span class="line">​两种状态均有7种处理器模式，且状态切换不影响处理器模式或寄存器内容</span><br></pre></td></tr></table></figure></div><h3 id="十三、MOV指令和LDR加载指令的区别和用途？"><a href="#十三、MOV指令和LDR加载指令的区别和用途？" class="headerlink" title="十三、MOV指令和LDR加载指令的区别和用途？"></a>十三、MOV指令和LDR加载指令的区别和用途？</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">​MOV指令用于将数据从一个寄存器传送到另一个寄存器，或者将一个常数传送到一个寄存器中，但是不能访问内存</span><br><span class="line">​LDR指令用于将内存中的数据放入寄存器中（后续会详细介绍ARM指令）</span><br></pre></td></tr></table></figure></div><h3 id="十四、ARM7TDMI支持哪几种指令集，各有什么特点？"><a href="#十四、ARM7TDMI支持哪几种指令集，各有什么特点？" class="headerlink" title="十四、ARM7TDMI支持哪几种指令集，各有什么特点？"></a>十四、ARM7TDMI支持哪几种指令集，各有什么特点？</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">​ARM指令集：指令32位，效率高，代码密度低，所有ARM指令都可以有条件执行</span><br><span class="line">​Thumb指令：指令16位，代码密度高，仅有一条指令具备条件执行功能，是ARM集的子集。</span><br></pre></td></tr></table></figure></div><p>转载注明出处 谢谢</p>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> ARM嵌入式 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
